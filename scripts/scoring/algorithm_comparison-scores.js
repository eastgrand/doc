/**

 * Algorithm Comparison Scoring Script - Data-Driven Algorithm
 * 
 * Generated using data_driven_shap methodology from SHAP feature importance analysis
 * Formula: algorithm_comparison_score = (0.295 × mp10104a_b_p_normalized) + (0.248 × genalphacy_p_normalized) + (0.233 × mp10116a_b_p_normalized) + (0.224 × mp10120a_b_p_normalized)
 * 
 * Components (4 total):
 *   1. mp10104a_b_p (weight: 0.295)
 *      Feature contributes to  analysis through data-driven importance
 *   2. genalphacy_p (weight: 0.248)
 *      Feature contributes to  analysis through data-driven importance
 *   3. mp10116a_b_p (weight: 0.233)
 *      Feature contributes to  analysis through data-driven importance
 *   4. mp10120a_b_p (weight: 0.224)
 *      Feature contributes to  analysis through data-driven importance
 * 
 * Generated by: Data-Driven Scoring Algorithm Generator
 * Timestamp: {"timestamp": "2025-01-01T00:00:00Z"}

 */


const fs = require('fs');
const path = require('path');

console.log('🎯 Starting Data-Driven Scoring Analysis...');



// Load the analysis data from endpoints
const dataPath = path.join(__dirname, '../../public/data/endpoints/correlation-analysis.json');
const analysisData = JSON.parse(fs.readFileSync(dataPath, 'utf8'));

if (!analysisData || !analysisData.results) {
  console.error('❌ No analysis dataset found');
  process.exit(1);
}

console.log(`📊 Processing ${analysisData.results.length} records for scoring...`);



function calculateAlgorithmComparisonScore(record) {
  // Data-driven scoring function generated from SHAP importance analysis
  
  let totalScore = 0;
  let componentCount = 0;
  

  // Component: mp10104a_b_p (weight: 0.295)
  const mp10104a_b_p_raw = Number(record.MP10104A_B_P) || Number(record.mp10104a_b_p) || 0;
  let mp10104a_b_p_normalized = 0;
  
  if (mp10104a_b_p_raw > 0) {
    // Normalization: min_max_scale
    mp10104a_b_p_normalized = Math.min((mp10104a_b_p_raw - 0) / (100) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.295 * mp10104a_b_p_normalized;

    componentCount++;
  }

  // Component: genalphacy_p (weight: 0.248)
  const genalphacy_p_raw = Number(record.GENALPHACY_P) || Number(record.genalphacy_p) || 0;
  let genalphacy_p_normalized = 0;
  
  if (genalphacy_p_raw > 0) {
    // Normalization: min_max_scale
    genalphacy_p_normalized = Math.min((genalphacy_p_raw - 0) / (100) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.248 * genalphacy_p_normalized;

    componentCount++;
  }

  // Component: mp10116a_b_p (weight: 0.233)
  const mp10116a_b_p_raw = Number(record.MP10116A_B_P) || Number(record.mp10116a_b_p) || 0;
  let mp10116a_b_p_normalized = 0;
  
  if (mp10116a_b_p_raw > 0) {
    // Normalization: min_max_scale
    mp10116a_b_p_normalized = Math.min((mp10116a_b_p_raw - 0) / (100) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.233 * mp10116a_b_p_normalized;

    componentCount++;
  }

  // Component: mp10120a_b_p (weight: 0.224)
  const mp10120a_b_p_raw = Number(record.MP10120A_B_P) || Number(record.mp10120a_b_p) || 0;
  let mp10120a_b_p_normalized = 0;
  
  if (mp10120a_b_p_raw > 0) {
    // Normalization: min_max_scale
    mp10120a_b_p_normalized = Math.min((mp10120a_b_p_raw - 0) / (100) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.224 * mp10120a_b_p_normalized;

    componentCount++;
  }

  
  // Ensure score is in 0-100 range
  const finalScore = Math.max(0, Math.min(100, totalScore));
  
  return Math.round(finalScore * 100) / 100;
}



// Calculate scores for each record
let processedCount = 0;
const scoreStats = {
  min: 100,
  max: 0,
  sum: 0,
  scores: []
};

console.log('🔄 Calculating algorithm_comparison scores using data-driven algorithm...');

analysisData.results.forEach((record, index) => {
  const score = calculateAlgorithmComparisonScore(record);
  record.algorithm_comparison_score = score;
  
  // Track statistics
  scoreStats.min = Math.min(scoreStats.min, score);
  scoreStats.max = Math.max(scoreStats.max, score);
  scoreStats.sum += score;
  scoreStats.scores.push(score);
  
  processedCount++;
  
  if (processedCount % 500 === 0) {
    console.log(`   Processed ${processedCount}/${analysisData.results.length} records...`);
  }
});



// Calculate final statistics
const avgScore = scoreStats.sum / processedCount;
scoreStats.scores.sort((a, b) => a - b);
const medianScore = scoreStats.scores[Math.floor(scoreStats.scores.length / 2)];

console.log('📈 Algorithm Comparison Scoring Statistics (Data-Driven):');
console.log(`   📊 Records processed: ${processedCount.toLocaleString()}`);
console.log(`   📊 Score range: ${scoreStats.min.toFixed(1)} - ${scoreStats.max.toFixed(1)}`);
console.log(`   📊 Average score: ${avgScore.toFixed(1)}`);
console.log(`   📊 Median score: ${medianScore.toFixed(1)}`);

// Show score distribution
const scoreRanges = {
  'Exceptional Performance (90-100)': scoreStats.scores.filter(s => s >= 90).length,
  'High Performance (75-89)': scoreStats.scores.filter(s => s >= 75 && s < 90).length,
  'Good Performance (60-74)': scoreStats.scores.filter(s => s >= 60 && s < 75).length,
  'Moderate Performance (45-59)': scoreStats.scores.filter(s => s >= 45 && s < 60).length,
  'Limited Performance (0-44)': scoreStats.scores.filter(s => s < 45).length
};

console.log('📊 Algorithm Comparison Distribution:');
Object.entries(scoreRanges).forEach(([range, count]) => {
  const percentage = (count / processedCount * 100).toFixed(1);
  console.log(`   ${range}: ${count.toLocaleString()} (${percentage}%)`);
});



// Show top performing records
const topPerformers = analysisData.results
  .sort((a, b) => b.algorithm_comparison_score - a.algorithm_comparison_score)
  .slice(0, 15);

console.log('🏆 Top 15 Algorithm Comparison Opportunities (Data-Driven):');
topPerformers.forEach((record, index) => {
  console.log(`   ${index + 1}. ${record.DESCRIPTION || record.ID}: ${record.algorithm_comparison_score.toFixed(1)} score`);
});

// Add scoring metadata
analysisData.algorithm_comparison_scoring_metadata = {
  scoring_methodology: 'data_driven_shap_importance',
  algorithm_source: 'generated_from_feature_importance_analysis',
  generation_timestamp: new Date().toISOString(),
  score_statistics: {
    mean: avgScore,
    median: medianScore,
    min: scoreStats.min,
    max: scoreStats.max,
    distribution: scoreRanges
  },
  top_performers: topPerformers.slice(0, 10).map(record => ({
    id: record.ID,
    name: record.DESCRIPTION,
    score: record.algorithm_comparison_score
  }))
};

// Save updated data
console.log('💾 Saving updated dataset...');
fs.writeFileSync(dataPath, JSON.stringify(analysisData, null, 2));

console.log('✅ Algorithm Comparison scoring complete!');
console.log(`📄 Updated dataset saved to: ${dataPath}`);
console.log(`🎯 All ${processedCount.toLocaleString()} records now include algorithm_comparison_score field`);

console.log('\n📋 Next steps:');
console.log('   1. ✅ Created data-driven algorithm_comparison_score for all records');
console.log('   2. ✅ Added scoring metadata and statistics');
console.log('   3. 🔄 Update analysis processors to use new scores');
console.log('   4. 🔄 Test analysis endpoint performance');

