/**

 * Strategic Scoring Script - Data-Driven Algorithm
 * 
 * Generated using data_driven_shap methodology from SHAP feature importance analysis
 * Formula: strategic_score = (0.350 × market_component) + (0.300 × competitive_component) + (0.200 × demographic_component) + (0.150 × economic_component)
 * 
 * Components (3 total):
 *   1. market_share_field (weight: 0.350)
 *      Market share indicates competitive position
 *   2. population_field (weight: 0.300)
 *      Population size indicates market potential
 *   3. income_field (weight: 0.200)
 *      Income indicates purchasing power
 * 
 * Generated by: Data-Driven Scoring Algorithm Generator
 * Timestamp: {"timestamp": "2025-01-01T00:00:00Z"}

 */


const fs = require('fs');
const path = require('path');

console.log('🎯 Starting Data-Driven Scoring Analysis...');



// Load the microservice data
const dataPath = path.join(__dirname, '../../public/data/microservice-export.json');
const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));

// Access analysis dataset - try multiple possible sources
let analysisData = null;
const possibleDatasets = ['correlation_analysis', 'strategic_analysis', 'competitive_analysis', 'demographic_analysis'];

for (const datasetName of possibleDatasets) {
  if (data.datasets && data.datasets[datasetName] && data.datasets[datasetName].results) {
    analysisData = data.datasets[datasetName];
    console.log(`📊 Using dataset: ${datasetName} with ${analysisData.results.length} records`);
    break;
  }
}

if (!analysisData || !analysisData.results) {
  console.error('❌ No analysis dataset found');
  process.exit(1);
}

console.log(`📊 Processing ${analysisData.results.length} records for scoring...`);



function calculateStrategicScore(record) {
  // Data-driven scoring function generated from SHAP importance analysis
  
  let totalScore = 0;
  let componentCount = 0;
  

  // Component: market_share_field (weight: 0.350)
  const market_share_field_raw = Number(record.mp30034a_b_p) || Number(record.market_share_field) || 0;
  let market_share_field_normalized = 0;
  
  if (market_share_field_raw > 0) {
    // Normalization: min_max_scale
    market_share_field_normalized = Math.min((market_share_field_raw - 0) / (50) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.350 * market_share_field_normalized;

    componentCount++;
  }

  // Component: population_field (weight: 0.300)
  const population_field_raw = Number(record.total_population) || Number(record.population_field) || 0;
  let population_field_normalized = 0;
  
  if (population_field_raw > 0) {
    // Normalization: min_max_scale
    population_field_normalized = Math.min((population_field_raw - 0) / (500000) * 100, 100);
    
    // Transformation: log scale
    const population_field_transformed = Math.log(population_field_normalized + 1) * (100 / Math.log(101));
    totalScore += 0.300 * population_field_transformed;

    componentCount++;
  }

  // Component: income_field (weight: 0.200)
  const income_field_raw = Number(record.median_income) || Number(record.income_field) || 0;
  let income_field_normalized = 0;
  
  if (income_field_raw > 0) {
    // Normalization: percentile_scale
    income_field_normalized = Math.min((income_field_raw / 200000) * 100, 100);
    
    // Transformation: direct normalization
    totalScore += 0.200 * income_field_normalized;

    componentCount++;
  }

  
  // Ensure score is in 0-100 range
  const finalScore = Math.max(0, Math.min(100, totalScore));
  
  return Math.round(finalScore * 100) / 100;
}



// Calculate scores for each record
let processedCount = 0;
const scoreStats = {
  min: 100,
  max: 0,
  sum: 0,
  scores: []
};

console.log('🔄 Calculating strategic scores using data-driven algorithm...');

analysisData.results.forEach((record, index) => {
  const score = calculateStrategicScore(record);
  record.strategic_score = score;
  
  // Track statistics
  scoreStats.min = Math.min(scoreStats.min, score);
  scoreStats.max = Math.max(scoreStats.max, score);
  scoreStats.sum += score;
  scoreStats.scores.push(score);
  
  processedCount++;
  
  if (processedCount % 500 === 0) {
    console.log(`   Processed ${processedCount}/${analysisData.results.length} records...`);
  }
});



// Calculate final statistics
const avgScore = scoreStats.sum / processedCount;
scoreStats.scores.sort((a, b) => a - b);
const medianScore = scoreStats.scores[Math.floor(scoreStats.scores.length / 2)];

console.log('📈 Strategic Scoring Statistics (Data-Driven):');
console.log(`   📊 Records processed: ${processedCount.toLocaleString()}`);
console.log(`   📊 Score range: ${scoreStats.min.toFixed(1)} - ${scoreStats.max.toFixed(1)}`);
console.log(`   📊 Average score: ${avgScore.toFixed(1)}`);
console.log(`   📊 Median score: ${medianScore.toFixed(1)}`);

// Show score distribution
const scoreRanges = {
  'Exceptional Performance (90-100)': scoreStats.scores.filter(s => s >= 90).length,
  'High Performance (75-89)': scoreStats.scores.filter(s => s >= 75 && s < 90).length,
  'Good Performance (60-74)': scoreStats.scores.filter(s => s >= 60 && s < 75).length,
  'Moderate Performance (45-59)': scoreStats.scores.filter(s => s >= 45 && s < 60).length,
  'Limited Performance (0-44)': scoreStats.scores.filter(s => s < 45).length
};

console.log('📊 Strategic Distribution:');
Object.entries(scoreRanges).forEach(([range, count]) => {
  const percentage = (count / processedCount * 100).toFixed(1);
  console.log(`   ${range}: ${count.toLocaleString()} (${percentage}%)`);
});



// Show top performing records
const topPerformers = analysisData.results
  .sort((a, b) => b.strategic_score - a.strategic_score)
  .slice(0, 15);

console.log('🏆 Top 15 Strategic Opportunities (Data-Driven):');
topPerformers.forEach((record, index) => {
  console.log(`   ${index + 1}. ${record.DESCRIPTION || record.ID}: ${record.strategic_score.toFixed(1)} score`);
});

// Add scoring metadata
analysisData.strategic_scoring_metadata = {
  scoring_methodology: 'data_driven_shap_importance',
  algorithm_source: 'generated_from_feature_importance_analysis',
  generation_timestamp: new Date().toISOString(),
  score_statistics: {
    mean: avgScore,
    median: medianScore,
    min: scoreStats.min,
    max: scoreStats.max,
    distribution: scoreRanges
  },
  top_performers: topPerformers.slice(0, 10).map(record => ({
    id: record.ID,
    name: record.DESCRIPTION,
    score: record.strategic_score
  }))
};

// Save updated data
console.log('💾 Saving updated dataset...');
fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));

console.log('✅ Strategic scoring complete!');
console.log(`📄 Updated dataset saved to: ${dataPath}`);
console.log(`🎯 All ${processedCount.toLocaleString()} records now include strategic_score field`);

console.log('\n📋 Next steps:');
console.log('   1. ✅ Created data-driven strategic_score for all records');
console.log('   2. ✅ Added scoring metadata and statistics');
console.log('   3. 🔄 Update analysis processors to use new scores');
console.log('   4. 🔄 Test analysis endpoint performance');

