TS7006 patch-style preview (top 30 files)
Generated: 2025-09-16T01:03:22.716Z
Total files with edits: 573
Total suggested annotations: 7574


*** FILE: app/api/claude/housing-generate-response/route.ts
@@ lines 34-52 @@
-   const originalZips: string[] = originalAnalysis.match(/\b\d{5}\b/g) || [];
-   
-   // Check for California ZIP codes (90xxx, 91xxx, 92xxx, 93xxx, 94xxx, 95xxx, 96xxx)
-   const californiaZips = responseZips.filter(zip => /^9[0-6]\d{3}$/.test(zip));
-   if (californiaZips.length > 0) {
-     issues.push(`California ZIP codes found: ${californiaZips.join(', ')}`);
-   }
-   
-   // Check for ZIP codes in response that aren't in original
-   const hallucinatedZips = responseZips.filter(zip => !originalZips.includes(zip));
-   if (hallucinatedZips.length > 0) {
-     issues.push(`Hallucinated ZIP codes: ${hallucinatedZips.join(', ')}`);
-   }
-   
-   // Check for suspicious score patterns (like scores ending in .2, .6, .1, .9 which might be generated)
-   const suspiciousScores = response.match(/\d+\.\d/g)?.filter(score => {
-     const decimal = parseFloat(score) % 1;
-     return Math.abs(decimal - 0.2) < 0.01 || Math.abs(decimal - 0.6) < 0.01 || 
-            Math.abs(decimal - 0.1) < 0.01 || Math.abs(decimal - 0.9) < 0.01;
---
+   const originalZips: string[] = originalAnalysis.match(/\b\d{5}\b/g) || [];
+   
+   // Check for California ZIP codes (90xxx, 91xxx, 92xxx, 93xxx, 94xxx, 95xxx, 96xxx)
+   const californiaZips = responseZips.filter(zip: any => /^9[0-6]\d{3}$/.test(zip));
+   if (californiaZips.length > 0) {
+     issues.push(`California ZIP codes found: ${californiaZips.join(', ')}`);
+   }
+   
+   // Check for ZIP codes in response that aren't in original
+   const hallucinatedZips = responseZips.filter(zip: any => !originalZips.includes(zip));
+   if (hallucinatedZips.length > 0) {
+     issues.push(`Hallucinated ZIP codes: ${hallucinatedZips.join(', ')}`);
+   }
+   
+   // Check for suspicious score patterns (like scores ending in .2, .6, .1, .9 which might be generated)
+   const suspiciousScores = response.match(/\d+\.\d/g)?.filter(score: any => {
+     const decimal = parseFloat(score) % 1;
+     return Math.abs(decimal - 0.2) < 0.01 || Math.abs(decimal - 0.6) < 0.01 || 
+            Math.abs(decimal - 0.1) < 0.01 || Math.abs(decimal - 0.9) < 0.01;
+   }) || [];
+   
+   if (suspiciousScores.length > 3) {
@@ lines 222-228 @@
-   };
-   
-   // Sort by the appropriate score field to get full range representation
-   const sorted = [...features].sort((a, b) => {
-     // Handle both flat and double-nested properties (feature.properties.properties)
-     const propsA = (a && typeof a === 'object') ? (a as any).properties || a : {};
-     const propsB = (b && typeof b === 'object') ? (b as any).properties || b : {};
---
+   };
+   
+   // Sort by the appropriate score field to get full range representation
+   const sorted = [...features].sort((a: any, b: any) => {
+     // Handle both flat and double-nested properties (feature.properties.properties)
+     const propsA = (a && typeof a === 'object') ? (a as any).properties || a : {};
+     const propsB = (b && typeof b === 'object') ? (b as any).properties || b : {};
+     const nestedA = (propsA && typeof propsA === 'object') ? (propsA as any).properties || propsA : propsA;
+     const nestedB = (propsB && typeof propsB === 'object') ? (propsB as any).properties || propsB : propsB;
+ 
@@ lines 259-266 @@
-       (b as any)?.value
-     ];
- 
-     const numA = Number(scoreCandidatesA.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
-     const numB = Number(scoreCandidatesB.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
-     return numB - numA; // Highest scores first
-   });
-   
---
+       (b as any)?.value
+     ];
+ 
+     const numA = Number(scoreCandidatesA.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
+     const numB = Number(scoreCandidatesB.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
+     return numB - numA; // Highest scores first
+   });
+   
+   // Use FULL dataset for accurate analysis - no sampling limits
+   topFeatures = sorted; // Use all features for comprehensive analysis
+   
@@ lines 1051-1057 @@
-     .map((f: any) => (f?.properties || f || {})[scoreField])
-     .filter((v: any) => typeof v === 'number' && !Number.isNaN(v)) as number[];
-   if (vals.length === 0) return null;
-   const sorted = [...vals].sort((a,b)=>a-b);
-   const n = sorted.length;
-   const q = (p: number) => {
-     const idx = (n - 1) * p;
---
+     .map((f: any) => (f?.properties || f || {})[scoreField])
+     .filter((v: any) => typeof v === 'number' && !Number.isNaN(v)) as number[];
+   if (vals.length === 0) return null;
+   const sorted = [...vals].sort((a: any,b: any)=>a-b);
+   const n = sorted.length;
+   const q = (p: number) => {
+     const idx = (n - 1) * p;
+     const lo = Math.floor(idx), hi = Math.ceil(idx);
+     if (lo === hi) return sorted[lo];
+     return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
@@ lines 1061-1067 @@
-   };
-   const min = sorted[0];
-   const max = sorted[n-1];
-   const avg = vals.reduce((a,b)=>a+b,0)/n;
-   return {
-     count: n,
-     min,
---
+   };
+   const min = sorted[0];
+   const max = sorted[n-1];
+   const avg = vals.reduce((a: any,b: any)=>a+b,0)/n;
+   return {
+     count: n,
+     min,
+     max,
+     avg,
+     q1: q(0.25),
@@ lines 1216-1222 @@
-                          lowerFieldName.includes('mlb') ||     // Specific sport fan percentages
-                          lowerFieldName.includes('nba') ||     // Specific sport fan percentages
-                          lowerFieldName.includes('nhl') ||     // Specific sport fan percentages
-                          layerConfig?.fields?.some(f => f?.label?.includes('%')) ||
-                          layerConfig?.metadata?.valueType === 'percentage');
-     
-     // REFINED CURRENCY DETECTION (CHECK THIRD)
---
+                          lowerFieldName.includes('mlb') ||     // Specific sport fan percentages
+                          lowerFieldName.includes('nba') ||     // Specific sport fan percentages
+                          lowerFieldName.includes('nhl') ||     // Specific sport fan percentages
+                          layerConfig?.fields?.some(f: any => f?.label?.includes('%')) ||
+                          layerConfig?.metadata?.valueType === 'percentage');
+     
+     // REFINED CURRENCY DETECTION (CHECK THIRD)
+     const isCurrency = !isIndex && !isPercentage && ( // Ensure not index or percentage
+                        lowerFieldName.includes('income') ||
+                        lowerFieldName.includes('spending') ||
@@ lines 1230-1236 @@
-                        lowerFieldName.includes('value') ||
-                        lowerFieldName.includes('budget') ||
-                        lowerFieldName.includes('$') ||
-                        layerConfig?.fields?.some(f => f?.label?.includes('$')) ||
-                        layerConfig?.metadata?.valueType === 'currency');
- 
-     // First check for NaN values
---
+                        lowerFieldName.includes('value') ||
+                        lowerFieldName.includes('budget') ||
+                        lowerFieldName.includes('$') ||
+                        layerConfig?.fields?.some(f: any => f?.label?.includes('$')) ||
+                        layerConfig?.metadata?.valueType === 'currency');
+ 
+     // First check for NaN values
+     if (isNaN(value)) {
+       return 'N/A';
+     }
@@ lines 1307-1319 @@
-     const candidates: any[] = [
-       nested?.[primaryField],
-       props?.[primaryField],
-       ...legacyFields.flatMap((f) => [nested?.[f], props?.[f]]),
-       nested?.target_value,
-       props?.target_value,
-       feature?.[primaryField],
-       feature?.value
-     ];
-     const chosen = candidates.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v))));
-     if (chosen === undefined) return undefined;
-     const num = Number(chosen);
-     return isNaN(num) ? undefined : num;
---
+     const candidates: any[] = [
+       nested?.[primaryField],
+       props?.[primaryField],
+       ...legacyFields.flatMap((f: any) => [nested?.[f], props?.[f]]),
+       nested?.target_value,
+       props?.target_value,
+       feature?.[primaryField],
+       feature?.value
+     ];
+     const chosen = candidates.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v))));
+     if (chosen === undefined) return undefined;
+     const num = Number(chosen);
+     return isNaN(num) ? undefined : num;
+   } catch {
+     return undefined;
+   }
@@ lines 1324-1330 @@
- 
- // **MODIFIED** Sorts a list of attribute objects by a field value
- function sortAttributesByField(attributeList: FeatureProperties[], field: string): FeatureProperties[] {
-   return [...attributeList].sort((a, b) => {
-     const valueA = Number(a[field]);
-     const valueB = Number(b[field]);
- 
---
+ 
+ // **MODIFIED** Sorts a list of attribute objects by a field value
+ function sortAttributesByField(attributeList: FeatureProperties[], field: string): FeatureProperties[] {
+   return [...attributeList].sort((a: any, b: any) => {
+     const valueA = Number(a[field]);
+     const valueB = Number(b[field]);
+ 
+     if (isNaN(valueA) && !isNaN(valueB)) return 1;
+     if (!isNaN(valueA) && isNaN(valueB)) return -1;
+     if (isNaN(valueA) && isNaN(valueB)) return 0;
@@ lines 1620-1631 @@
-     
-     // Rest of the function remains the same
-     let totalLength = 0;
-     chunks.forEach(chunk => {
-         totalLength += chunk.length;
-     });
-     const result = new Uint8Array(totalLength);
-     let offset = 0;
-     chunks.forEach(chunk => {
-         result.set(chunk, offset);
-         offset += chunk.length;
-     });
---
+     
+     // Rest of the function remains the same
+     let totalLength = 0;
+     chunks.forEach(chunk: any => {
+         totalLength += chunk.length;
+     });
+     const result = new Uint8Array(totalLength);
+     let offset = 0;
+     chunks.forEach(chunk: any => {
+         result.set(chunk, offset);
+         offset += chunk.length;
+     });
+     return Buffer.from(result); // Keep Buffer for now, will decode later
+ }
+ 
@@ lines 1797-1809 @@
-         // 🌟 NEW: Geographic Analysis Detection using new Geo-Awareness System
-         const geoEngine = GeoAwarenessEngine.getInstance();
-         const geoResult = await geoEngine.processGeoQuery(currentQuery, []);
-         const detectedCities = geoResult.matchedEntities.map(e => e.name);
-         const isCityQuery = geoResult.matchedEntities.length > 0;
-         const isCityComparison = geoResult.matchedEntities.length >= 2 && currentQuery.toLowerCase().includes('vs');
-         
-         if (isCityQuery) {
-           console.log('🏙️ [GEO ANALYSIS] Detected geographic query:', {
-             entities: geoResult.matchedEntities.map(e => ({ name: e.name, type: e.type })),
-             filterMethod: geoResult.filterStats.filterMethod,
-             isComparison: isCityComparison,
-             query: currentQuery
---
+         // 🌟 NEW: Geographic Analysis Detection using new Geo-Awareness System
+         const geoEngine = GeoAwarenessEngine.getInstance();
+         const geoResult = await geoEngine.processGeoQuery(currentQuery, []);
+         const detectedCities = geoResult.matchedEntities.map(e: any => e.name);
+         const isCityQuery = geoResult.matchedEntities.length > 0;
+         const isCityComparison = geoResult.matchedEntities.length >= 2 && currentQuery.toLowerCase().includes('vs');
+         
+         if (isCityQuery) {
+           console.log('🏙️ [GEO ANALYSIS] Detected geographic query:', {
+             entities: geoResult.matchedEntities.map(e: any => ({ name: e.name, type: e.type })),
+             filterMethod: geoResult.filterStats.filterMethod,
+             isComparison: isCityComparison,
+             query: currentQuery
+           });
+         }
+         if (metadata?.matched_fields) {
@@ lines 1862-1868 @@
-               const allAreas = [...(ls.top || []), ...(ls.bottom || [])];
-               
-               // Filter out national parks from sampling to ensure Claude gets legitimate business areas
-               const nonParkAreas = allAreas.filter(area => {
-                 const areaId = area.id || '';
-                 const areaName = area.name || '';
-                 
---
+               const allAreas = [...(ls.top || []), ...(ls.bottom || [])];
+               
+               // Filter out national parks from sampling to ensure Claude gets legitimate business areas
+               const nonParkAreas = allAreas.filter(area: any => {
+                 const areaId = area.id || '';
+                 const areaName = area.name || '';
+                 
+                 // Filter out national parks using same logic as analysisLens
+                 if (String(areaId).startsWith('000')) return false;
+                 
@@ lines 1875-1898 @@
-                   /state\s+park/i, /\bpark\b.*national/i, /\bnational\b.*\bpark\b/i,
-                   /\bnp\b/i, /\bnm\b/i, /\bnf\b/i
-                 ];
-                 return !parkPatterns.some(pattern => pattern.test(nameStr));
-               });
-               
-               console.log(`🔍 [HYBRID SAMPLING] Filtered ${allAreas.length - nonParkAreas.length} parks from ${allAreas.length} total areas`);
-               
-               if (nonParkAreas.length > 0) {
-                 const sortedByScore = nonParkAreas.sort((a, b) => (b.value || 0) - (a.value || 0));
-                 const scores = sortedByScore.map(a => a.value || 0);
-                 
-                 console.log(`🔍 [HYBRID SAMPLING] Non-park sampling from ${nonParkAreas.length} legitimate areas`);
-                 console.log(`🔍 [HYBRID SAMPLING] Top 5 non-park areas: ${sortedByScore.slice(0, 5).map(a => `${a.id}(${a.value?.toFixed(1)})`).join(', ')}`);
-                 
-                 // Calculate statistical measures
-                 const mean = scores.reduce((sum, val) => sum + val, 0) / scores.length;
-                 const median = scores.length % 2 === 0 
-                   ? (scores[Math.floor(scores.length / 2 - 1)] + scores[Math.floor(scores.length / 2)]) / 2
-                   : scores[Math.floor(scores.length / 2)];
-                 const stdDev = Math.sqrt(scores.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / scores.length);
-                 
-                 // 1. Top 15 absolute performers
-                 examples.push(...sortedByScore.slice(0, 15));
---
+                   /state\s+park/i, /\bpark\b.*national/i, /\bnational\b.*\bpark\b/i,
+                   /\bnp\b/i, /\bnm\b/i, /\bnf\b/i
+                 ];
+                 return !parkPatterns.some(pattern: any => pattern.test(nameStr));
+               });
+               
+               console.log(`🔍 [HYBRID SAMPLING] Filtered ${allAreas.length - nonParkAreas.length} parks from ${allAreas.length} total areas`);
+               
+               if (nonParkAreas.length > 0) {
+                 const sortedByScore = nonParkAreas.sort((a: any, b: any) => (b.value || 0) - (a.value || 0));
+                 const scores = sortedByScore.map(a: any => a.value || 0);
+                 
+                 console.log(`🔍 [HYBRID SAMPLING] Non-park sampling from ${nonParkAreas.length} legitimate areas`);
+                 console.log(`🔍 [HYBRID SAMPLING] Top 5 non-park areas: ${sortedByScore.slice(0, 5).map(a: any => `${a.id}(${a.value?.toFixed(1)})`).join(', ')}`);
+                 
+                 // Calculate statistical measures
+                 const mean = scores.reduce((sum: any, val: any) => sum + val, 0) / scores.length;
+                 const median = scores.length % 2 === 0 
+                   ? (scores[Math.floor(scores.length / 2 - 1)] + scores[Math.floor(scores.length / 2)]) / 2
+                   : scores[Math.floor(scores.length / 2)];
+                 const stdDev = Math.sqrt(scores.reduce((sum: any, val: any) => sum + Math.pow(val - mean, 2), 0) / scores.length);
+                 
+                 // 1. Top 15 absolute performers
+                 examples.push(...sortedByScore.slice(0, 15));
+                 
+                 // 2. Bottom 5 absolute performers
+                 examples.push(...sortedByScore.slice(-5));
@@ lines 1902-1923 @@
-                 
-                 // 3. Areas closest to median (find 3 closest)
-                 const medianCandidates = sortedByScore
-                   .map(area => ({ area, diff: Math.abs((area.value || 0) - median) }))
-                   .sort((a, b) => a.diff - b.diff)
-                   .slice(0, 3)
-                   .map(item => item.area);
-                 examples.push(...medianCandidates);
-                 
-                 // 4. Areas closest to mean (find 3 closest)
-                 const meanCandidates = sortedByScore
-                   .map(area => ({ area, diff: Math.abs((area.value || 0) - mean) }))
-                   .sort((a, b) => a.diff - b.diff)
-                   .slice(0, 3)
-                   .map(item => item.area);
-                 examples.push(...meanCandidates);
-                 
-                 // 5. Statistical outliers (>2σ from mean)
-                 const outliers = sortedByScore.filter(area => 
-                   Math.abs((area.value || 0) - mean) > (2 * stdDev)
-                 );
-                 examples.push(...outliers);
---
+                 
+                 // 3. Areas closest to median (find 3 closest)
+                 const medianCandidates = sortedByScore
+                   .map(area: any => ({ area, diff: Math.abs((area.value || 0) - median) }))
+                   .sort((a: any, b: any) => a.diff - b.diff)
+                   .slice(0, 3)
+                   .map(item: any => item.area);
+                 examples.push(...medianCandidates);
+                 
+                 // 4. Areas closest to mean (find 3 closest)
+                 const meanCandidates = sortedByScore
+                   .map(area: any => ({ area, diff: Math.abs((area.value || 0) - mean) }))
+                   .sort((a: any, b: any) => a.diff - b.diff)
+                   .slice(0, 3)
+                   .map(item: any => item.area);
+                 examples.push(...meanCandidates);
+                 
+                 // 5. Statistical outliers (>2σ from mean)
+                 const outliers = sortedByScore.filter(area: any => 
+                   Math.abs((area.value || 0) - mean) > (2 * stdDev)
+                 );
+                 examples.push(...outliers);
+                 
+                 // 6. Representative from each score decile (10 areas)
+                 for (let i = 0; i < 10; i++) {
@@ lines 1934-1940 @@
-                 
-                 // Remove duplicates while preserving order
-                 const seen = new Set();
-                 const uniqueExamples = examples.filter(ex => {
-                   const key = `${ex.id}_${ex.value}`;
-                   if (seen.has(key)) return false;
-                   seen.add(key);
---
+                 
+                 // Remove duplicates while preserving order
+                 const seen = new Set();
+                 const uniqueExamples = examples.filter(ex: any => {
+                   const key = `${ex.id}_${ex.value}`;
+                   if (seen.has(key)) return false;
+                   seen.add(key);
+                   return true;
+                 });
+                 
@@ lines 1947-1957 @@
-                 console.log(`🔍 [HYBRID SAMPLING] Layer ${idx}: Processed ${allAreas.length} total areas`);
-                 console.log(`🔍 [HYBRID SAMPLING] Statistics: mean=${mean.toFixed(2)}, median=${median.toFixed(2)}, stdDev=${stdDev.toFixed(2)}`);
-                 console.log(`🔍 [HYBRID SAMPLING] Sample composition: ${examples.length} unique areas (top 15 + bottom 5 + median 3 + mean 3 + outliers ${outliers.length} + decile reps 10)`);
-                 console.log(`🔍 [HYBRID SAMPLING] Sample IDs: ${examples.slice(0, 10).map(e => `${e.id}(${e.value?.toFixed(1)})`).join(', ')}${examples.length > 10 ? '...' : ''}`);
-                 console.log(`🔍 [HYBRID SAMPLING] Examples vs Samples ID comparison:`, {
-                   examplesIds: examples.slice(0, 5).map(e => e.id),
-                   samplesIds: ls.samples?.slice(0, 5).map((s: any) => s.id || s.ID) || [],
-                   samplesMatchCheck: examples.slice(0, 3).map(e => ({
-                     exampleId: e.id,
-                     foundInSamples: !!ls.samples?.find((s: any) => s.id === e.id || s.ID === e.id)
-                   }))
---
+                 console.log(`🔍 [HYBRID SAMPLING] Layer ${idx}: Processed ${allAreas.length} total areas`);
+                 console.log(`🔍 [HYBRID SAMPLING] Statistics: mean=${mean.toFixed(2)}, median=${median.toFixed(2)}, stdDev=${stdDev.toFixed(2)}`);
+                 console.log(`🔍 [HYBRID SAMPLING] Sample composition: ${examples.length} unique areas (top 15 + bottom 5 + median 3 + mean 3 + outliers ${outliers.length} + decile reps 10)`);
+                 console.log(`🔍 [HYBRID SAMPLING] Sample IDs: ${examples.slice(0, 10).map(e: any => `${e.id}(${e.value?.toFixed(1)})`).join(', ')}${examples.length > 10 ? '...' : ''}`);
+                 console.log(`🔍 [HYBRID SAMPLING] Examples vs Samples ID comparison:`, {
+                   examplesIds: examples.slice(0, 5).map(e: any => e.id),
+                   samplesIds: ls.samples?.slice(0, 5).map((s: any) => s.id || s.ID) || [],
+                   samplesMatchCheck: examples.slice(0, 3).map(e: any => ({
+                     exampleId: e.id,
+                     foundInSamples: !!ls.samples?.find((s: any) => s.id === e.id || s.ID === e.id)
+                   }))
+                 });
+               } else if (allAreas.length > 0) {
+                 // Fallback: use all areas but still filter parks
@@ lines 1966-1972 @@
-                 console.log(`🔍 [HYBRID SAMPLING] No areas available for sampling`);
-               }
- 
-               const features = examples.map((e, i) => {
-                 // Find corresponding sample data to get additional fields
-                 // Try multiple matching strategies: exact ID match, exact name match, or positional fallback
-                 let sample = ls.samples?.find((s: any) => 
---
+                 console.log(`🔍 [HYBRID SAMPLING] No areas available for sampling`);
+               }
+ 
+               const features = examples.map((e: any, i: any) => {
+                 // Find corresponding sample data to get additional fields
+                 // Try multiple matching strategies: exact ID match, exact name match, or positional fallback
+                 let sample = ls.samples?.find((s: any) => 
+                   s.id === e.id || 
+                   s.name === e.name || 
+                   s.id === String(e.id) || 
@@ lines 2097-2103 @@
-                 // Chat sends featureData as [{layerId, features: [...]}] format
-                 // Extract features from the layer objects for contextual chat
-                 if (featureData[0]?.features) {
-                     processedLayersData = featureData.map(layer => ({
-                         layerId: layer.layerId || 'contextual_chat',
-                         layerName: layer.layerName || 'Chat Context',
-                         layerType: layer.layerType || 'polygon',
---
+                 // Chat sends featureData as [{layerId, features: [...]}] format
+                 // Extract features from the layer objects for contextual chat
+                 if (featureData[0]?.features) {
+                     processedLayersData = featureData.map(layer: any => ({
+                         layerId: layer.layerId || 'contextual_chat',
+                         layerName: layer.layerName || 'Chat Context',
+                         layerType: layer.layerType || 'polygon',
+                         layer: null as any,
+                         features: layer.features || [],
+                         extent: null
@@ lines 2129-2137 @@
-         if (isCityQuery && processedLayersData.length > 0) {
-           console.log('🏙️ [GEO FILTER] Applying geographic filtering for detected cities:', detectedCities);
-           
-           const originalFeatureCount = processedLayersData.reduce((total, layer) => total + layer.features.length, 0);
-           
-           processedLayersData = await Promise.all(processedLayersData.map(async (layer) => {
-             // Apply geo filtering to the layer's features
-             const geoFilterResult = await geoEngine.processGeoQuery(currentQuery, layer.features);
-             
---
+         if (isCityQuery && processedLayersData.length > 0) {
+           console.log('🏙️ [GEO FILTER] Applying geographic filtering for detected cities:', detectedCities);
+           
+           const originalFeatureCount = processedLayersData.reduce((total: any, layer: any) => total + layer.features.length, 0);
+           
+           processedLayersData = await Promise.all(processedLayersData.map(async (layer: any) => {
+             // Apply geo filtering to the layer's features
+             const geoFilterResult = await geoEngine.processGeoQuery(currentQuery, layer.features);
+             
+             const filteredFeatures = geoFilterResult.filteredRecords;
+             console.log(`🏙️ [GEO FILTER] Layer "${layer.layerId}": ${layer.features.length} -> ${filteredFeatures.length} features`);
+             
@@ lines 2144-2159 @@
-             };
-           }));
-           
-           const filteredFeatureCount = processedLayersData.reduce((total, layer) => total + layer.features.length, 0);
-           console.log(`🏙️ [GEO FILTER] Total features filtered: ${originalFeatureCount} -> ${filteredFeatureCount}`);
-           
-           // Log which FSAs were found for debugging
-           const foundFSAs = processedLayersData.flatMap(layer => 
-             layer.features.map(f => f.properties?.FSA_ID || f.properties?.ID || f.properties?.id).filter(Boolean)
-           );
-           console.log(`🏙️ [GEO FILTER] FSAs in filtered results:`, foundFSAs.slice(0, 20));
-           console.log(`🏙️ [GEO FILTER] Montreal FSAs (H-series):`, foundFSAs.filter(fsa => String(fsa).startsWith('H')).slice(0, 10));
-           console.log(`🏙️ [GEO FILTER] Quebec City FSAs (G-series):`, foundFSAs.filter(fsa => String(fsa).startsWith('G')).slice(0, 10));
-         }
- 
-         // 🎯 FULL PATH: For initial questions, use complete data processing
---
+             };
+           }));
+           
+           const filteredFeatureCount = processedLayersData.reduce((total: any, layer: any) => total + layer.features.length, 0);
+           console.log(`🏙️ [GEO FILTER] Total features filtered: ${originalFeatureCount} -> ${filteredFeatureCount}`);
+           
+           // Log which FSAs were found for debugging
+           const foundFSAs = processedLayersData.flatMap(layer: any => 
+             layer.features.map(f: any => f.properties?.FSA_ID || f.properties?.ID || f.properties?.id).filter(Boolean)
+           );
+           console.log(`🏙️ [GEO FILTER] FSAs in filtered results:`, foundFSAs.slice(0, 20));
+           console.log(`🏙️ [GEO FILTER] Montreal FSAs (H-series):`, foundFSAs.filter(fsa: any => String(fsa).startsWith('H')).slice(0, 10));
+           console.log(`🏙️ [GEO FILTER] Quebec City FSAs (G-series):`, foundFSAs.filter(fsa: any => String(fsa).startsWith('G')).slice(0, 10));
+         }
+ 
+         // 🎯 FULL PATH: For initial questions, use complete data processing
+   else if (processedLayersData.length === 0 && featureData) {
+           console.log('[Claude] Processing featureData from request body');
+           console.log('[Claude DEBUG] featureData structure:', {
@@ lines 2260-2266 @@
-           }
- 
-           // Convert OptimizedLayerData to ProcessedLayerResult (existing logic)
-           processedLayersData = featureDataFromBlob.features.map(layer => {
-             // PATCH: Flatten FeatureCollection if present
-             let featuresArray = layer.features;
-             if (Array.isArray(featuresArray) && featuresArray.length === 1 && featuresArray[0]?.type === 'FeatureCollection' && Array.isArray(featuresArray[0].features)) {
---
+           }
+ 
+           // Convert OptimizedLayerData to ProcessedLayerResult (existing logic)
+           processedLayersData = featureDataFromBlob.features.map(layer: any => {
+             // PATCH: Flatten FeatureCollection if present
+             let featuresArray = layer.features;
+             if (Array.isArray(featuresArray) && featuresArray.length === 1 && featuresArray[0]?.type === 'FeatureCollection' && Array.isArray(featuresArray[0].features)) {
+               featuresArray = featuresArray[0].features;
+             }
+ 
@@ lines 2318-2324 @@
-         // Log layer structure for debugging if needed
-         if (process.env.NODE_ENV === 'development' && processedLayersData.length > 0) {
-           console.log(`[Claude] Processing ${processedLayersData.length} layers`);
-           processedLayersData.forEach((layer, idx) => {
-             console.log(`[Claude] Layer ${idx}: ${layer.layerId} (${layer.features?.length || 0} features)`);
-           });
-         }
---
+         // Log layer structure for debugging if needed
+         if (process.env.NODE_ENV === 'development' && processedLayersData.length > 0) {
+           console.log(`[Claude] Processing ${processedLayersData.length} layers`);
+           processedLayersData.forEach((layer: any, idx: any) => {
+             console.log(`[Claude] Layer ${idx}: ${layer.layerId} (${layer.features?.length || 0} features)`);
+           });
+         }
+ 
+         // --- Data Processing and Statistics Calculation ---
+         if (!processedLayersData || !Array.isArray(processedLayersData) || processedLayersData.length === 0) {
@@ lines 2330-2336 @@
- 
-         console.log('[Claude] Mapping featureData.features to processedLayersData...'); // Log before map
-         // Convert OptimizedLayerData to ProcessedLayerResult (reassign instead of redeclare)
-         processedLayersData = processedLayersData.map(layer => {
-             // PATCH: Flatten FeatureCollection if present
-             let featuresArray = layer.features;
-             // Type-safe check for FeatureCollection wrapper
---
+ 
+         console.log('[Claude] Mapping featureData.features to processedLayersData...'); // Log before map
+         // Convert OptimizedLayerData to ProcessedLayerResult (reassign instead of redeclare)
+         processedLayersData = processedLayersData.map(layer: any => {
+             // PATCH: Flatten FeatureCollection if present
+             let featuresArray = layer.features;
+             // Type-safe check for FeatureCollection wrapper
+             if (
+               Array.isArray(featuresArray) &&
+               featuresArray.length === 1 &&
@@ lines 2405-2411 @@
-                 layerName: layer.layerName || layer.layerId,
-                 layerType: layer.layerType || 'unknown',
-                 layer: layerConfig,
-                 features: featuresArray.map(feature => {
-                   // If already a LocalGeospatialFeature, use as-is
-                   if (feature && typeof feature === 'object' && 'type' in feature && 'properties' in feature) {
-                     return feature as LocalGeospatialFeature;
---
+                 layerName: layer.layerName || layer.layerId,
+                 layerType: layer.layerType || 'unknown',
+                 layer: layerConfig,
+                 features: featuresArray.map(feature: any => {
+                   // If already a LocalGeospatialFeature, use as-is
+                   if (feature && typeof feature === 'object' && 'type' in feature && 'properties' in feature) {
+                     return feature as LocalGeospatialFeature;
+                   }
+                   // Extract properties correctly to avoid double nesting
+                   let props: any = {};
@@ lines 2450-2456 @@
-         processedLayersData = processedLayersDataForAI;
-     
-         // If all layers have zero features after filtering, return an explanatory response
-         const totalFeaturesAfterFiltering = processedLayersData.reduce((sum, l) => sum + ((l && l.features && l.features.length) || 0), 0);
-         if (totalFeaturesAfterFiltering === 0) {
-           if (isContextualChat) {
-             console.log('[Claude] Contextual chat with no features after filtering - proceeding');
---
+         processedLayersData = processedLayersDataForAI;
+     
+         // If all layers have zero features after filtering, return an explanatory response
+         const totalFeaturesAfterFiltering = processedLayersData.reduce((sum: any, l: any) => sum + ((l && l.features && l.features.length) || 0), 0);
+         if (totalFeaturesAfterFiltering === 0) {
+           if (isContextualChat) {
+             console.log('[Claude] Contextual chat with no features after filtering - proceeding');
+           } else {
+             console.warn('[Claude] No features remain after spatial filtering. Aborting LLM call to avoid hallucinated output.');
+             return NextResponse.json({
@@ lines 2565-2572 @@
-                       primaryAnalysisField = relevantFields[0];
-                   } else {
-                       // Further Fallback: first numeric field found that isn't OBJECTID, or just OBJECTID
-                       const availableNumericFields = Object.keys(firstFeatureProps).filter(key => typeof firstFeatureProps[key] === 'number');
-                       primaryAnalysisField = availableNumericFields.find(f => f.toUpperCase() !== 'OBJECTID') || availableNumericFields[0];
-                   }
-               }
-           }
---
+                       primaryAnalysisField = relevantFields[0];
+                   } else {
+                       // Further Fallback: first numeric field found that isn't OBJECTID, or just OBJECTID
+                       const availableNumericFields = Object.keys(firstFeatureProps).filter(key: any => typeof firstFeatureProps[key] === 'number');
+                       primaryAnalysisField = availableNumericFields.find(f: any => f.toUpperCase() !== 'OBJECTID') || availableNumericFields[0];
+                   }
+               }
+           }
+     
+ 
+         if (process.env.NODE_ENV === 'development') {
@@ lines 2578-2585 @@
- 
-           // --- Check if Relevant Data Found ---
-           let relevantDataFound = false;
-         if (primaryAnalysisField && processedLayersData.some(layer =>
-                layer.features && layer.features.some(feature => feature.properties?.[primaryAnalysisField!] !== undefined)))
-           {
-               relevantDataFound = true;
-               console.log(`[Claude Prompt Gen] Using primary analysis field: ${primaryAnalysisField}`);
---
+ 
+           // --- Check if Relevant Data Found ---
+           let relevantDataFound = false;
+         if (primaryAnalysisField && processedLayersData.some(layer: any =>
+                layer.features && layer.features.some(feature: any => feature.properties?.[primaryAnalysisField!] !== undefined)))
+           {
+               relevantDataFound = true;
+               console.log(`[Claude Prompt Gen] Using primary analysis field: ${primaryAnalysisField}`);
+           } else {
+            console.warn(`[Claude Prompt Gen] Could not determine a relevant primary numeric field for layer ${primaryLayerResult.layerId} based on query: \"${messages?.[messages.length - 1]?.content || metadata?.query || 'Analyze data'}\".`);
+           }
@@ lines 2613-2619 @@
-             const allWantedFields: string[] = Array.from(new Set((metadata?.matched_fields as string[]) || []));
-             if (allWantedFields.length > 0 && processedLayersData.length > 1) {
-               const unionLayer = unionByGeoId(
-                 processedLayersData.map(l => ({ layerId: l.layerId, features: l.features })),
-                 allWantedFields,
-                 'ID'
-               );
---
+             const allWantedFields: string[] = Array.from(new Set((metadata?.matched_fields as string[]) || []));
+             if (allWantedFields.length > 0 && processedLayersData.length > 1) {
+               const unionLayer = unionByGeoId(
+                 processedLayersData.map(l: any => ({ layerId: l.layerId, features: l.features })),
+                 allWantedFields,
+                 'ID'
+               );
+               processedLayersData.unshift({
+                 layerId: unionLayer.layerId,
+                 layerName: unionLayer.name,
@@ lines 2777-2783 @@
-               
-               const strategicValues = features
-                 .map(extractStrategicScore)
-                 .filter(v => typeof v === 'number' && !isNaN(v));
-               
-               // Get comprehensive statistics from originalSummary for context
-               let fullDatasetStats = originalSummary?.statistics;
---
+               
+               const strategicValues = features
+                 .map(extractStrategicScore)
+                 .filter(v: any => typeof v === 'number' && !isNaN(v));
+               
+               // Get comprehensive statistics from originalSummary for context
+               let fullDatasetStats = originalSummary?.statistics;
+               
+               // If statistics aren't in expected format, extract from datasetOverview or fieldStatistics
+               if (!fullDatasetStats || !fullDatasetStats.quartiles) {
@@ lines 2839-2853 @@
-               console.log(`🔍 [Strategic Analysis Debug] Sample values:`, strategicValues.slice(0, 5));
-               
-               if (strategicValues.length > 0) {
-                 const sortedValues = strategicValues.sort((a, b) => a - b);
-                 const count = sortedValues.length;
-                 const min = sortedValues[0];
-                 const max = sortedValues[count - 1];
-                 const median = count % 2 === 0 ? 
-                   (sortedValues[count / 2 - 1] + sortedValues[count / 2]) / 2 : 
-                   sortedValues[Math.floor(count / 2)];
-                 const mean = strategicValues.reduce((a, b) => a + b, 0) / count;
-                 const variance = sortedValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
-                 const stdDev = Math.sqrt(variance);
-                 
-                 dataSummary += `\n=== 🚨 CRITICAL: FULL DATASET STATISTICS (IGNORE THE SAMPLES BELOW) ===\n`;
---
+               console.log(`🔍 [Strategic Analysis Debug] Sample values:`, strategicValues.slice(0, 5));
+               
+               if (strategicValues.length > 0) {
+                 const sortedValues = strategicValues.sort((a: any, b: any) => a - b);
+                 const count = sortedValues.length;
+                 const min = sortedValues[0];
+                 const max = sortedValues[count - 1];
+                 const median = count % 2 === 0 ? 
+                   (sortedValues[count / 2 - 1] + sortedValues[count / 2]) / 2 : 
+                   sortedValues[Math.floor(count / 2)];
+                 const mean = strategicValues.reduce((a: any, b: any) => a + b, 0) / count;
+                 const variance = sortedValues.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / count;
+                 const stdDev = Math.sqrt(variance);
+                 
+                 dataSummary += `\n=== 🚨 CRITICAL: FULL DATASET STATISTICS (IGNORE THE SAMPLES BELOW) ===\n`;
+                 dataSummary += `⛔⛔⛔ DO NOT USE THE ${count} SAMPLE EXAMPLES FOR STATISTICS ⛔⛔⛔\n`;
+                 dataSummary += `🚨 The following statistics represent ALL ${fullDatasetStats?.total || 421} markets in the dataset:\n`;
+                 
@@ lines 2897-2914 @@
-                 console.log('🏠 [HOUSING API] Using actual feature data instead of samples');
-                 
-                 // Get real features from processedLayersData
-                 const allRealFeatures = processedLayersData.flatMap(layer => layer.features || []);
-                 console.log(`🚨 [URGENT DEBUG] Total features from processedLayersData: ${allRealFeatures.length}`);
-                 
-                 // Check if any have demographic data
-                 const featuresWithDemographics = allRealFeatures.filter(f => {
-                   const props = f.properties || f;
-                   return props.ECYPTAPOP !== undefined || props.ECYHRIAVG !== undefined;
-                 });
-                 console.log(`🚨 [URGENT DEBUG] Features with demographic data: ${featuresWithDemographics.length}`);
-                 
-                 // Sample first 3 features demographic data
-                 allRealFeatures.slice(0, 3).forEach((f, i) => {
-                   const props = f.properties || f;
-                   console.log(`🚨 [URGENT DEBUG] Feature ${i} demographics:`, {
-                     id: props.ID || props.id,
---
+                 console.log('🏠 [HOUSING API] Using actual feature data instead of samples');
+                 
+                 // Get real features from processedLayersData
+                 const allRealFeatures = processedLayersData.flatMap(layer: any => layer.features || []);
+                 console.log(`🚨 [URGENT DEBUG] Total features from processedLayersData: ${allRealFeatures.length}`);
+                 
+                 // Check if any have demographic data
+                 const featuresWithDemographics = allRealFeatures.filter(f: any => {
+                   const props = f.properties || f;
+                   return props.ECYPTAPOP !== undefined || props.ECYHRIAVG !== undefined;
+                 });
+                 console.log(`🚨 [URGENT DEBUG] Features with demographic data: ${featuresWithDemographics.length}`);
+                 
+                 // Sample first 3 features demographic data
+                 allRealFeatures.slice(0, 3).forEach((f: any, i: any) => {
+                   const props = f.properties || f;
+                   console.log(`🚨 [URGENT DEBUG] Feature ${i} demographics:`, {
+                     id: props.ID || props.id,
+                     ECYPTAPOP: props.ECYPTAPOP,
+                     ECYHRIAVG: props.ECYHRIAVG,
+                     ECYMTN2534: props.ECYMTN2534,
@@ lines 3021-3033 @@
-               // Use SAME method as calculateBasicStats from statsCalculator
-               const brandDiffValues = features
-                 .map(extractScore)
-                 .filter(v => typeof v === 'number' && !isNaN(v));
-               
-               console.log(`🔍 [AI Analysis Debug] Extracted ${brandDiffValues.length} brand difference values using statsCalculator method`);
-               console.log(`🔍 [AI Analysis Debug] Sample values:`, brandDiffValues.slice(0, 5));
-               
-               if (brandDiffValues.length > 0) {
-                 const sortedValues = brandDiffValues.sort((a, b) => a - b);
-                 const count = sortedValues.length;
-                 console.log(`🔍 [AI Analysis Debug] AI Analysis Range: ${sortedValues[0].toFixed(1)}% to ${sortedValues[count - 1].toFixed(1)}% (${count} markets)`);
-                 console.log(`🔍 [AI Analysis Debug] Expected: -16.7% to 0.0% (984 markets)`);
---
+               // Use SAME method as calculateBasicStats from statsCalculator
+               const brandDiffValues = features
+                 .map(extractScore)
+                 .filter(v: any => typeof v === 'number' && !isNaN(v));
+               
+               console.log(`🔍 [AI Analysis Debug] Extracted ${brandDiffValues.length} brand difference values using statsCalculator method`);
+               console.log(`🔍 [AI Analysis Debug] Sample values:`, brandDiffValues.slice(0, 5));
+               
+               if (brandDiffValues.length > 0) {
+                 const sortedValues = brandDiffValues.sort((a: any, b: any) => a - b);
+                 const count = sortedValues.length;
+                 console.log(`🔍 [AI Analysis Debug] AI Analysis Range: ${sortedValues[0].toFixed(1)}% to ${sortedValues[count - 1].toFixed(1)}% (${count} markets)`);
+                 console.log(`🔍 [AI Analysis Debug] Expected: -16.7% to 0.0% (984 markets)`);
+                 if (count !== 984 || sortedValues[0] > -16.7) {
+                   console.error(`⚠️ [AI Analysis Debug] DATA MISMATCH DETECTED!`);
+                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
@@ lines 3036-3046 @@
-                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
-                   console.error(`🔍 [AI Analysis Debug] First feature sample:`, features[0]);
-                 }
-                 const mean = sortedValues.reduce((a, b) => a + b, 0) / count;
-                 const median = count % 2 === 0 
-                   ? (sortedValues[Math.floor(count / 2) - 1] + sortedValues[Math.floor(count / 2)]) / 2
-                   : sortedValues[Math.floor(count / 2)];
-                 const variance = sortedValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
-                 const stdDev = Math.sqrt(variance);
-                 
-                 dataSummary += `\n=== BRAND DIFFERENCE STATISTICS (CRITICAL FOR RANGE) ===\n`;
---
+                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
+                   console.error(`🔍 [AI Analysis Debug] First feature sample:`, features[0]);
+                 }
+                 const mean = sortedValues.reduce((a: any, b: any) => a + b, 0) / count;
+                 const median = count % 2 === 0 
+                   ? (sortedValues[Math.floor(count / 2) - 1] + sortedValues[Math.floor(count / 2)]) / 2
+                   : sortedValues[Math.floor(count / 2)];
+                 const variance = sortedValues.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / count;
+                 const stdDev = Math.sqrt(variance);
+                 
+                 dataSummary += `\n=== BRAND DIFFERENCE STATISTICS (CRITICAL FOR RANGE) ===\n`;
+                 dataSummary += `🚨 MANDATORY: Use these statistics for your analysis range, NOT individual examples\n`;
+                 dataSummary += `• Markets analyzed: ${count}\n`;
+                 dataSummary += `• Average difference: ${mean.toFixed(2)}%\n`;
@@ lines 3252-3271 @@
-             if (features.length > 0) {
-                 const firstFeature = features[0];
-                 const allProperties = firstFeature.properties || firstFeature;
-                 const availableFields = Object.keys(allProperties).filter(key => 
-                     typeof allProperties[key] === 'number' && !isNaN(allProperties[key])
-                 );
-                 
-                 // Debug: Check for Nike/Adidas fields specifically
-                 const nikeField = availableFields.find(f => f.toLowerCase().includes('mp30034a_b'));
-                 const adidasField = availableFields.find(f => f.toLowerCase().includes('mp30029a_b'));
-                 console.log(`[DEBUG Nike/Adidas] Layer ${layerName}: Nike field found: ${nikeField}, Adidas field found: ${adidasField}`);
-                 if (nikeField) console.log(`[DEBUG Nike] Sample value: ${allProperties[nikeField]}`);
-                 if (adidasField) console.log(`[DEBUG Adidas] Sample value: ${allProperties[adidasField]}`);
-                 
-                 if (availableFields.length > 0) {
-                     dataSummary += `- Available Data Fields:\n`;
-                     availableFields.forEach(fieldName => {
-                         const humanReadableName = getHumanReadableFieldName(fieldName);
-                         const sampleValue = allProperties[fieldName];
-                         // Determine field type and unit for better context
---
+             if (features.length > 0) {
+                 const firstFeature = features[0];
+                 const allProperties = firstFeature.properties || firstFeature;
+                 const availableFields = Object.keys(allProperties).filter(key: any => 
+                     typeof allProperties[key] === 'number' && !isNaN(allProperties[key])
+                 );
+                 
+                 // Debug: Check for Nike/Adidas fields specifically
+                 const nikeField = availableFields.find(f: any => f.toLowerCase().includes('mp30034a_b'));
+                 const adidasField = availableFields.find(f: any => f.toLowerCase().includes('mp30029a_b'));
+                 console.log(`[DEBUG Nike/Adidas] Layer ${layerName}: Nike field found: ${nikeField}, Adidas field found: ${adidasField}`);
+                 if (nikeField) console.log(`[DEBUG Nike] Sample value: ${allProperties[nikeField]}`);
+                 if (adidasField) console.log(`[DEBUG Adidas] Sample value: ${allProperties[adidasField]}`);
+                 
+                 if (availableFields.length > 0) {
+                     dataSummary += `- Available Data Fields:\n`;
+                     availableFields.forEach(fieldName: any => {
+                         const humanReadableName = getHumanReadableFieldName(fieldName);
+                         const sampleValue = allProperties[fieldName];
+                         // Determine field type and unit for better context
+                         const fieldType = getFieldDataType(fieldName, layerConfig);
+                         const formattedSampleValue = formatFieldValue(sampleValue, fieldName, layerConfig);
+                         
@@ lines 3301-3307 @@
-                       const finalValue = value1 !== undefined ? value1 : value2;
-                       return Number(finalValue);
-                     })
-                     .filter(v => !isNaN(v)); // Filter out NaN values
-                 console.log(`[Claude Prompt Gen] Layer ${layerName}: Found ${validValues.length} valid numeric values for ${currentLayerPrimaryField}.`);
-             } catch (e) {
-                 console.error(`[Claude Prompt Gen] Error extracting/converting values for ${currentLayerPrimaryField} in layer ${layerName}:`, e);
---
+                       const finalValue = value1 !== undefined ? value1 : value2;
+                       return Number(finalValue);
+                     })
+                     .filter(v: any => !isNaN(v)); // Filter out NaN values
+                 console.log(`[Claude Prompt Gen] Layer ${layerName}: Found ${validValues.length} valid numeric values for ${currentLayerPrimaryField}.`);
+             } catch (e) {
+                 console.error(`[Claude Prompt Gen] Error extracting/converting values for ${currentLayerPrimaryField} in layer ${layerName}:`, e);
+                 validValues = [];
+             }
+ 
@@ lines 3311-3322 @@
-             if (validValues.length > 0) {
-                 // Cap values for competitive analysis (thematic_value should be 1-10 scale)
-                 const cappedValues = currentLayerPrimaryField === 'thematic_value' ? 
-                   validValues.map(v => v > 10 ? Math.max(1.0, Math.min(10.0, v)) : v) : 
-                   validValues;
-                 
-                 const minValue = Math.min(...cappedValues);
-                 const maxValue = Math.max(...cappedValues);
-                 const meanValue = cappedValues.reduce((a, b) => a + b, 0) / cappedValues.length;
- 
-                           dataSummary += `- ${humanReadableFieldName} Range: ${formatFieldValue(minValue, currentLayerPrimaryField, layerConfig)} to ${formatFieldValue(maxValue, currentLayerPrimaryField, layerConfig)}\n`;
-             dataSummary += `- ${humanReadableFieldName} Average: ${formatFieldValue(meanValue, currentLayerPrimaryField, layerConfig)}\n`;
---
+             if (validValues.length > 0) {
+                 // Cap values for competitive analysis (thematic_value should be 1-10 scale)
+                 const cappedValues = currentLayerPrimaryField === 'thematic_value' ? 
+                   validValues.map(v: any => v > 10 ? Math.max(1.0, Math.min(10.0, v)) : v) : 
+                   validValues;
+                 
+                 const minValue = Math.min(...cappedValues);
+                 const maxValue = Math.max(...cappedValues);
+                 const meanValue = cappedValues.reduce((a: any, b: any) => a + b, 0) / cappedValues.length;
+ 
+                           dataSummary += `- ${humanReadableFieldName} Range: ${formatFieldValue(minValue, currentLayerPrimaryField, layerConfig)} to ${formatFieldValue(maxValue, currentLayerPrimaryField, layerConfig)}\n`;
+             dataSummary += `- ${humanReadableFieldName} Average: ${formatFieldValue(meanValue, currentLayerPrimaryField, layerConfig)}\n`;
+                 console.log(`[Claude Prompt Gen] Added stats for ${currentLayerPrimaryField} to summary.`);
+             } else {
+                 dataSummary += `- No valid numeric data found for ${humanReadableFieldName}.\n`;
@@ lines 3404-3410 @@
- 
-                     if (topFeatures.length > 0) {
-                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
-                         topFeatures.forEach((tf, index) => {
-                             // Cap any scores over 10 (competitive analysis should be 1-10 scale)
-                             let valueToFormat = tf.value;
-                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
---
+ 
+                     if (topFeatures.length > 0) {
+                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
+                         topFeatures.forEach((tf: any, index: any) => {
+                             // Cap any scores over 10 (competitive analysis should be 1-10 scale)
+                             let valueToFormat = tf.value;
+                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
+                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
+                               console.log(`🔧 [Regular Processing] Capped score from ${tf.value} to ${valueToFormat} for area ${tf.description || tf.zipCode}`);
+                             } else if (tf.value > 10) {
@@ lines 3444-3450 @@
- 
-                     if (topFeatures.length > 0) {
-                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
-                         topFeatures.forEach((tf, index) => {
-                             let valueToFormat = tf.value;
-                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
-                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
---
+ 
+                     if (topFeatures.length > 0) {
+                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
+                         topFeatures.forEach((tf: any, index: any) => {
+                             let valueToFormat = tf.value;
+                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
+                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
+                             }
+                             
+                             const formattedValue = formatFieldValue(valueToFormat, currentLayerPrimaryField, layerConfig);
@@ lines 3541-3552 @@
-                const numericFields = Object.entries(firstFeature.properties)
-                  .filter(([_, value]) => typeof value === 'number' && !isNaN(value as number))
-                  .map(([key]) => key)
-                  .filter(key => !['OBJECTID', 'Shape__Area', 'Shape__Length', 'joint_score'].includes(key.toUpperCase())); // Also exclude joint_score itself
- 
-                if (numericFields.length >= 2) {
-                  // Assign only if inference hasn't already succeeded
-                  if (!varA) varA = numericFields[0];
-                  if (!varB) varB = numericFields.find(f => f !== varA) || numericFields[1]; // Ensure different fields
-                  console.log('[Joint Analysis] Inference Attempt 3 (feature properties): varA=${varA}, varB=${varB}');
-                } else {
-                  console.warn('[Joint Analysis] Fallback failed: First feature has < 2 suitable numeric properties.');
---
+                const numericFields = Object.entries(firstFeature.properties)
+                  .filter(([_, value]) => typeof value === 'number' && !isNaN(value as number))
+                  .map(([key]) => key)
+                  .filter(key: any => !['OBJECTID', 'Shape__Area', 'Shape__Length', 'joint_score'].includes(key.toUpperCase())); // Also exclude joint_score itself
+ 
+                if (numericFields.length >= 2) {
+                  // Assign only if inference hasn't already succeeded
+                  if (!varA) varA = numericFields[0];
+                  if (!varB) varB = numericFields.find(f: any => f !== varA) || numericFields[1]; // Ensure different fields
+                  console.log('[Joint Analysis] Inference Attempt 3 (feature properties): varA=${varA}, varB=${varB}');
+                } else {
+                  console.warn('[Joint Analysis] Fallback failed: First feature has < 2 suitable numeric properties.');
+                }
+              } else {
+                console.warn('[Joint Analysis] Fallback failed: Cannot access properties of the first feature.');
@@ lines 3610-3616 @@
-               details: {
-                 varA,
-                 varB,
-                 featureCount: processedLayersData.reduce((sum, layer) => sum + layer.features.length, 0)
-               }
-             }, { status: 400 });
-           }
---
+               details: {
+                 varA,
+                 varB,
+                 featureCount: processedLayersData.reduce((sum: any, layer: any) => sum + layer.features.length, 0)
+               }
+             }, { status: 400 });
+           }
+ 
+           // Calculate statistics
+           const min = Math.min(...jointScoreValues);
@@ lines 3618-3635 @@
-           // Calculate statistics
-           const min = Math.min(...jointScoreValues);
-           const max = Math.max(...jointScoreValues);
-           const mean = jointScoreValues.reduce((a, b) => a + b, 0) / jointScoreValues.length;
-           const median = jointScoreValues.sort((a, b) => a - b)[Math.floor(jointScoreValues.length / 2)];
- 
-           // Sort features by joint_score
-           jointScoreFeatures.sort((a, b) => {
-             const scoreA = a.properties?.joint_score ?? (a as any).attributes?.joint_score ?? 0;
-             const scoreB = b.properties?.joint_score ?? (b as any).attributes?.joint_score ?? 0;
-             return scoreB - scoreA;
-           });
-           
-           // Get top 5 regions with more detailed information
-           const topRegions = jointScoreFeatures.slice(0, 5).map((f, i) => {
-             const zipCode = getZIPCode(f);
-             const locationName = getLocationName(f);
-             const jointScore = f.properties?.joint_score ?? (f as any).attributes?.joint_score;
---
+           // Calculate statistics
+           const min = Math.min(...jointScoreValues);
+           const max = Math.max(...jointScoreValues);
+           const mean = jointScoreValues.reduce((a: any, b: any) => a + b, 0) / jointScoreValues.length;
+           const median = jointScoreValues.sort((a: any, b: any) => a - b)[Math.floor(jointScoreValues.length / 2)];
+ 
+           // Sort features by joint_score
+           jointScoreFeatures.sort((a: any, b: any) => {
+             const scoreA = a.properties?.joint_score ?? (a as any).attributes?.joint_score ?? 0;
+             const scoreB = b.properties?.joint_score ?? (b as any).attributes?.joint_score ?? 0;
+             return scoreB - scoreA;
+           });
+           
+           // Get top 5 regions with more detailed information
+           const topRegions = jointScoreFeatures.slice(0, 5).map((f: any, i: any) => {
+             const zipCode = getZIPCode(f);
+             const locationName = getLocationName(f);
+             const jointScore = f.properties?.joint_score ?? (f as any).attributes?.joint_score;
+             const valueA = f.properties?.[varA] ?? (f as any).attributes?.[varA];
+             const valueB = f.properties?.[varB] ?? (f as any).attributes?.[varB];
+             
@@ lines 3656-3662 @@
-           dataSummary += `  • Total Regions Analyzed: ${jointScoreValues.length}\n\n`;
-           dataSummary += `Top 5 Regions by Combined Score:\n`;
-           
-           topRegions.forEach(region => {
-             dataSummary += `${region.rank}. ${region.location} (${region.zipCode}):\n`;
-             dataSummary += `   • Combined Score: ${region.jointScore}\n`;
-             dataSummary += `   • ${varA}: ${region.valueA}\n`;
---
+           dataSummary += `  • Total Regions Analyzed: ${jointScoreValues.length}\n\n`;
+           dataSummary += `Top 5 Regions by Combined Score:\n`;
+           
+           topRegions.forEach(region: any => {
+             dataSummary += `${region.rank}. ${region.location} (${region.zipCode}):\n`;
+             dataSummary += `   • Combined Score: ${region.jointScore}\n`;
+             dataSummary += `   • ${varA}: ${region.valueA}\n`;
+             dataSummary += `   • ${varB}: ${region.valueB}\n`;
+           });
+ 
@@ lines 3695-3706 @@
-                 enhancedFieldContext = `
- ENHANCED QUERY ANALYSIS:
- - User Query: "${userQuery}"
- - Detected Fields: ${detectedFields.map(f => `${f.field} (${f.description})`).join(', ')}
- - Recommended Endpoint: ${bestEndpoint || 'general'}
- - Primary Analysis Field: ${primaryAnalysisField}
- 
- FIELD INTERPRETATION GUIDANCE:
- ${detectedFields.map(f => `- ${f.field}: ${f.description}`).join('\n')}
- `;
-                 console.log(`[Claude] Enhanced field analysis - detected ${detectedFields.length} relevant fields`);
-             }
---
+                 enhancedFieldContext = `
+ ENHANCED QUERY ANALYSIS:
+ - User Query: "${userQuery}"
+ - Detected Fields: ${detectedFields.map(f: any => `${f.field} (${f.description})`).join(', ')}
+ - Recommended Endpoint: ${bestEndpoint || 'general'}
+ - Primary Analysis Field: ${primaryAnalysisField}
+ 
+ FIELD INTERPRETATION GUIDANCE:
+ ${detectedFields.map(f: any => `- ${f.field}: ${f.description}`).join('\n')}
+ `;
+                 console.log(`[Claude] Enhanced field analysis - detected ${detectedFields.length} relevant fields`);
+             }
+         } catch (error) {
+             console.warn('[Claude] Error in enhanced field analysis:', error);
+         }
@@ lines 4328-4334 @@
-             }
-             
-             console.log('[Claude] Sending conversation with', validMessages.length, 'messages');
-             console.log('[Claude] Message roles:', validMessages.map(m => m.role).join(' -> '));
-             
-             anthropicResponse = await anthropic.messages.create({
-                 model: 'claude-3-5-sonnet-20240620',
---
+             }
+             
+             console.log('[Claude] Sending conversation with', validMessages.length, 'messages');
+             console.log('[Claude] Message roles:', validMessages.map(m: any => m.role).join(' -> '));
+             
+             anthropicResponse = await anthropic.messages.create({
+                 model: 'claude-3-5-sonnet-20240620',
+                 max_tokens: 4096,
+                 system: dynamicSystemPrompt,
+                 messages: validMessages
@@ lines 4355-4361 @@
-                 }
-             }, { status: 500 });
-         }
-         const responseContent = anthropicResponse.content?.find(block => block.type === 'text')?.text || 'No text content received from AI.';
- 
-   // Sanitize Model Attribution section to enforce conditional display and remove placeholders
-         let finalContent = responseContent;
---
+                 }
+             }, { status: 500 });
+         }
+         const responseContent = anthropicResponse.content?.find(block: any => block.type === 'text')?.text || 'No text content received from AI.';
+ 
+   // Sanitize Model Attribution section to enforce conditional display and remove placeholders
+         let finalContent = responseContent;
+         try {
+           // If we have a numeric R², replace any 'Not recorded/Not specified/Data not available' with the actual value
+           if (computedAttribution && typeof computedAttribution.r2 === 'number' && !Number.isNaN(computedAttribution.r2)) {
@@ lines 4411-4417 @@
-         // Name placeholder sanitation in AI narrative: replace "Unknown Area" with real top strategic names when possible
-         try {
-           if (/Top Strategic Markets:/i.test(finalContent) && /Unknown Area/i.test(finalContent)) {
-             const allFeatures = (processedLayersData || []).flatMap(layer => Array.isArray((layer as any)?.features) ? (layer as any).features : []);
-             const candidates = allFeatures
-               .map((feat: any) => {
-                 const props = feat?.properties || feat || {};
---
+         // Name placeholder sanitation in AI narrative: replace "Unknown Area" with real top strategic names when possible
+         try {
+           if (/Top Strategic Markets:/i.test(finalContent) && /Unknown Area/i.test(finalContent)) {
+             const allFeatures = (processedLayersData || []).flatMap(layer: any => Array.isArray((layer as any)?.features) ? (layer as any).features : []);
+             const candidates = allFeatures
+               .map((feat: any) => {
+                 const props = feat?.properties || feat || {};
+                 const score = Number(
+                   props?.strategic_analysis_score ??
+                   props?.strategic_value_score ??
@@ lines 4589-4601 @@
-   // New regex to detect cluster mentions in the format "CLUSTER X" or "Cluster X:"
-   const clusterRegex = /\b(?:CLUSTER|Cluster)\s+(\d+)(?:\s*:|:\s*|\s+)(.*?)(?:\n|$)/g;
- 
-   const zipMatches = Array.from(text.matchAll(zipRegex)).map(m => m[0]);
-   const postalCodeMatches = Array.from(text.matchAll(postalCodeRegex)).map(m => m[1]);
-   const districtMatches = Array.from(text.matchAll(districtRegex)).map(m => m[1]);
-   
-   // Extract cluster information
-   const clusterMatches = Array.from(text.matchAll(clusterRegex));
-   const clusterInfo = clusterMatches.map(match => {
-     const clusterId = match[1]; // The cluster number
-     const clusterName = match[2].trim(); // The cluster name/description
-     
---
+   // New regex to detect cluster mentions in the format "CLUSTER X" or "Cluster X:"
+   const clusterRegex = /\b(?:CLUSTER|Cluster)\s+(\d+)(?:\s*:|:\s*|\s+)(.*?)(?:\n|$)/g;
+ 
+   const zipMatches = Array.from(text.matchAll(zipRegex)).map(m: any => m[0]);
+   const postalCodeMatches = Array.from(text.matchAll(postalCodeRegex)).map(m: any => m[1]);
+   const districtMatches = Array.from(text.matchAll(districtRegex)).map(m: any => m[1]);
+   
+   // Extract cluster information
+   const clusterMatches = Array.from(text.matchAll(clusterRegex));
+   const clusterInfo = clusterMatches.map(match: any => {
+     const clusterId = match[1]; // The cluster number
+     const clusterName = match[2].trim(); // The cluster name/description
+     
+     // Try to find ZIP codes associated with this cluster
+     // Look for sections that follow the cluster definition and mention ZIP codes
+     const clusterText = text.substring(match.index);
@@ lines 4608-4614 @@
-     let zipCodes: string[] = [];
-     if (zipListMatch && zipListMatch[1]) {
-       // Extract ZIP codes from the comma-separated list
-       zipCodes = zipListMatch[1].split(/,\s*|\s+and\s+|\s+/).filter(s => /\d{5}/.test(s));
-     }
-             
-             return {
---
+     let zipCodes: string[] = [];
+     if (zipListMatch && zipListMatch[1]) {
+       // Extract ZIP codes from the comma-separated list
+       zipCodes = zipListMatch[1].split(/,\s*|\s+and\s+|\s+/).filter(s: any => /\d{5}/.test(s));
+     }
+             
+             return {
+       id: `cluster-${clusterId}`,
+       name: clusterName,
+       zipCodes: zipCodes
@@ lines 4638-4645 @@
-         sourceLayerIdForClickable = relevantLayerId;
-         const config = layerConfigs[relevantLayerId];
-         // Determine the identifier field (PRIORITIZE DESCRIPTION if present and type is string)
-         const descField = config.fields?.find(f => f.name === 'DESCRIPTION' && f.type === 'string');
-         const zipField = config.fields?.find(f => f.name.toUpperCase() === 'ZIP' || f.name.toUpperCase() === 'ZIPCODE' || f.name.toUpperCase() === 'POSTAL_CODE');
- 
-         if (descField) {
-             sourceIdentifierFieldForClickable = descField.name;
---
+         sourceLayerIdForClickable = relevantLayerId;
+         const config = layerConfigs[relevantLayerId];
+         // Determine the identifier field (PRIORITIZE DESCRIPTION if present and type is string)
+         const descField = config.fields?.find(f: any => f.name === 'DESCRIPTION' && f.type === 'string');
+         const zipField = config.fields?.find(f: any => f.name.toUpperCase() === 'ZIP' || f.name.toUpperCase() === 'ZIPCODE' || f.name.toUpperCase() === 'POSTAL_CODE');
+ 
+         if (descField) {
+             sourceIdentifierFieldForClickable = descField.name;
+         } else if (zipField) {
+             sourceIdentifierFieldForClickable = zipField.name;
+         } else {
@@ lines 4661-4679 @@
-      if (relevantLayerId && layerConfigs[relevantLayerId]) {
-         sourceLayerIdForClickable = relevantLayerId;
-         // Common postal code field or check config
-         const postalField = layerConfigs[relevantLayerId].fields?.find(f => f.name.toUpperCase() === 'CFSAUID');
-         sourceIdentifierFieldForClickable = postalField ? postalField.name : 'CFSAUID'; 
-      }
-   } 
-   // ... (rest of district logic, potentially update similarly)
- 
-   // If we found clusters and they have meaningful information, include them in the return value
-   if (clusters && clusters.length > 0 && clusters.some(c => c.zipCodes.length > 0)) {
-     console.log('[extractIdentifiersAndType] Identified clusters:', clusters);
-     // If we have more clusters than other identifiers, prioritize clusters
-     if ((featureType === undefined || clusters.length > validIdentifiers.length) && clusters.length >= 2) {
-       featureType = 'Cluster';
-       validIdentifiers = clusters.map(c => c.id);
-     }
-   }
- 
---
+      if (relevantLayerId && layerConfigs[relevantLayerId]) {
+         sourceLayerIdForClickable = relevantLayerId;
+         // Common postal code field or check config
+         const postalField = layerConfigs[relevantLayerId].fields?.find(f: any => f.name.toUpperCase() === 'CFSAUID');
+         sourceIdentifierFieldForClickable = postalField ? postalField.name : 'CFSAUID'; 
+      }
+   } 
+   // ... (rest of district logic, potentially update similarly)
+ 
+   // If we found clusters and they have meaningful information, include them in the return value
+   if (clusters && clusters.length > 0 && clusters.some(c: any => c.zipCodes.length > 0)) {
+     console.log('[extractIdentifiersAndType] Identified clusters:', clusters);
+     // If we have more clusters than other identifiers, prioritize clusters
+     if ((featureType === undefined || clusters.length > validIdentifiers.length) && clusters.length >= 2) {
+       featureType = 'Cluster';
+       validIdentifiers = clusters.map(c: any => c.id);
+     }
+   }
+ 
+   console.log('[extractIdentifiersAndType] Results:', { 
+     featureType, 
+     count: validIdentifiers.length, 
@@ lines 4709-4715 @@
-   console.log(`[generateClusterInformation] Processing features to identify clusters with primary field: ${primaryField}`);
-   
-   // Get all features from all layers
-   const allFeatures = layerResults.flatMap(layer => layer.features);
-   
-   // Skip if we don't have enough features
-   if (allFeatures.length < 10) {
---
+   console.log(`[generateClusterInformation] Processing features to identify clusters with primary field: ${primaryField}`);
+   
+   // Get all features from all layers
+   const allFeatures = layerResults.flatMap(layer: any => layer.features);
+   
+   // Skip if we don't have enough features
+   if (allFeatures.length < 10) {
+     console.log(`[generateClusterInformation] Not enough features (${allFeatures.length}) to identify meaningful clusters`);
+     return '';
+   }
@@ lines 4718-4724 @@
-   }
- 
-   // Filter for features that have the primary field
-   const validFeatures = allFeatures.filter(f => 
-     f.properties && f.properties[primaryField] !== undefined &&
-     !isNaN(Number(f.properties[primaryField]))
-   );
---
+   }
+ 
+   // Filter for features that have the primary field
+   const validFeatures = allFeatures.filter(f: any => 
+     f.properties && f.properties[primaryField] !== undefined &&
+     !isNaN(Number(f.properties[primaryField]))
+   );
+ 
+   if (validFeatures.length < 10) {
+     console.log(`[generateClusterInformation] Not enough valid features (${validFeatures.length}) with the primary field`);
@@ lines 4730-4736 @@
-   
-   try {
-     // Sort features by value, high to low
-     const sortedFeatures = [...validFeatures].sort((a, b) => {
-       const valA = Number(a.properties?.[primaryField]);
-       const valB = Number(b.properties?.[primaryField]);
-       return valB - valA;
---
+   
+   try {
+     // Sort features by value, high to low
+     const sortedFeatures = [...validFeatures].sort((a: any, b: any) => {
+       const valA = Number(a.properties?.[primaryField]);
+       const valB = Number(b.properties?.[primaryField]);
+       return valB - valA;
+     });
+     
+     // Take top 25% of features by value (the filtering done in visualization)
@@ lines 4746-4752 @@
-     // This simulates the spatial clustering that would happen in the actual visualization
-     const zipRegionClusters = new Map<string, Array<any>>();
-     
-     topFeatures.forEach(feature => {
-       // Get ZIP code
-       const zip = getZIPCode(feature);
-       // Use first 3 digits as region identifier - approximating geographic proximity
---
+     // This simulates the spatial clustering that would happen in the actual visualization
+     const zipRegionClusters = new Map<string, Array<any>>();
+     
+     topFeatures.forEach(feature: any => {
+       // Get ZIP code
+       const zip = getZIPCode(feature);
+       // Use first 3 digits as region identifier - approximating geographic proximity
+       const regionId = zip.substring(0, 3);
+       
+       if (!zipRegionClusters.has(regionId)) {
@@ lines 4764-4777 @@
-       .map(([regionId, features]) => {
-         // Calculate average value for the cluster
-         const avgValue = features.reduce(
-           (sum, f) => sum + Number(f.properties[primaryField]), 0
-         ) / features.length;
- 
-         // Get top ZIP codes for this cluster (highest values first)
-         const topZips = features
-           .sort((a, b) => Number(b.properties[primaryField]) - Number(a.properties[primaryField]))
-           .slice(0, 5)
-           .map(f => getZIPCode(f));
- 
-   // Determine a region name from the features using shared resolver
-   let regionName = resolveSharedRegionName(features, regionId, { neutralFallback: `Region ${regionId}` });
---
+       .map(([regionId, features]) => {
+         // Calculate average value for the cluster
+         const avgValue = features.reduce(
+           (sum: any, f: any) => sum + Number(f.properties[primaryField]), 0
+         ) / features.length;
+ 
+         // Get top ZIP codes for this cluster (highest values first)
+         const topZips = features
+           .sort((a: any, b: any) => Number(b.properties[primaryField]) - Number(a.properties[primaryField]))
+           .slice(0, 5)
+           .map(f: any => getZIPCode(f));
+ 
+   // Determine a region name from the features using shared resolver
+   let regionName = resolveSharedRegionName(features, regionId, { neutralFallback: `Region ${regionId}` });
+   if (!regionName) regionName = `Region ${regionId}`;
+         // Add region identifier to name if it doesn't already contain it
+         if (!regionName.includes(regionId)) {
@@ lines 4804-4817 @@
-     const displayFieldName = getHumanReadableFieldName(primaryField || 'Unknown Field');
- 
-     // Sort clusters by their average values (descending) before displaying
-     validClusters.sort((a, b) => b.avgValue - a.avgValue);
-     const limitedClusters = validClusters.slice(0, maxClusters);
-     
-     // Now generate the cluster info text with VERY explicit ranking
-     let clusterInfo = `CRITICAL: The following clusters are in EXACT RANKED ORDER from highest to lowest average value. DO NOT change this order in your response.\n\n`;
-     clusterInfo += `Identified ${limitedClusters.length} significant clusters of areas with high ${displayFieldName} values:\n\n`;
-     
-     limitedClusters.forEach((cluster, index) => {
-       // Make the rank extremely clear in multiple places
-       clusterInfo += `RANK ${index + 1} (${index === 0 ? 'HIGHEST' : index === limitedClusters.length - 1 ? 'LOWEST' : 'MIDDLE'} VALUE): ${cluster.regionName} Region\n`;
-       clusterInfo += `- ABSOLUTE RANK: #${index + 1} of ${limitedClusters.length} clusters\n`;
---
+     const displayFieldName = getHumanReadableFieldName(primaryField || 'Unknown Field');
+ 
+     // Sort clusters by their average values (descending) before displaying
+     validClusters.sort((a: any, b: any) => b.avgValue - a.avgValue);
+     const limitedClusters = validClusters.slice(0, maxClusters);
+     
+     // Now generate the cluster info text with VERY explicit ranking
+     let clusterInfo = `CRITICAL: The following clusters are in EXACT RANKED ORDER from highest to lowest average value. DO NOT change this order in your response.\n\n`;
+     clusterInfo += `Identified ${limitedClusters.length} significant clusters of areas with high ${displayFieldName} values:\n\n`;
+     
+     limitedClusters.forEach((cluster: any, index: any) => {
+       // Make the rank extremely clear in multiple places
+       clusterInfo += `RANK ${index + 1} (${index === 0 ? 'HIGHEST' : index === limitedClusters.length - 1 ? 'LOWEST' : 'MIDDLE'} VALUE): ${cluster.regionName} Region\n`;
+       clusterInfo += `- ABSOLUTE RANK: #${index + 1} of ${limitedClusters.length} clusters\n`;
+       clusterInfo += `- AVERAGE VALUE: ${cluster.avgValue.toFixed(2)} (${index === 0 ? 'HIGHEST OF ALL CLUSTERS' : ''})\n`;
+       clusterInfo += `- Member Count: ${cluster.count} areas\n`;
+               clusterInfo += `- Key ZIP codes in cluster: ${cluster.topZips.join(', ')}\n\n`;
@@ lines 5161-5167 @@
-     
-     // Check if this field is in the layer's fields array
-     if (layer.fields) {
-       const field = layer.fields.find(f => f.name === fieldName);
-       if (field) {
-         return field.label || field.alias || field.description || layer.name;
-       }
---
+     
+     // Check if this field is in the layer's fields array
+     if (layer.fields) {
+       const field = layer.fields.find(f: any => f.name === fieldName);
+       if (field) {
+         return field.label || field.alias || field.description || layer.name;
+       }
+     }
+   }
+ 
@@ lines 5172-5178 @@
-   return fieldName
-     .replace(/_/g, ' ')
-     .replace(/([A-Z])/g, ' $1')
-     .replace(/^./, str => str.toUpperCase())
-     .trim();
- }
- 
---
+   return fieldName
+     .replace(/_/g, ' ')
+     .replace(/([A-Z])/g, ' $1')
+     .replace(/^./, str: any => str.toUpperCase())
+     .trim();
+ }
+ 
+ // Get field data type and unit information for better analysis context
+ function getFieldDataType(fieldName: string, layerConfig: LayerConfig | undefined): string {
+   if (!fieldName) return 'unknown';
@@ lines 5194-5200 @@
-   }
-   
-   // Check field configuration
-   const fieldConfig = layerConfig?.fields?.find(f => f.name.toLowerCase() === lowerFieldName);
-   if (fieldConfig?.label?.includes('%')) return 'percentage';
-   if (fieldConfig?.label?.includes('$')) return 'currency';
-   
---
+   }
+   
+   // Check field configuration
+   const fieldConfig = layerConfig?.fields?.find(f: any => f.name.toLowerCase() === lowerFieldName);
+   if (fieldConfig?.label?.includes('%')) return 'percentage';
+   if (fieldConfig?.label?.includes('$')) return 'currency';
+   
+   // Pattern-based detection (enhanced for better accuracy)
+   const isIndex = lowerFieldName.includes('index') ||
+                  lowerFieldName.includes('score') ||


*** FILE: app/api/claude/generate-response/route.ts
@@ lines 36-54 @@
-   const originalZips: string[] = originalAnalysis.match(/\b\d{5}\b/g) || [];
-   
-   // Check for California ZIP codes (90xxx, 91xxx, 92xxx, 93xxx, 94xxx, 95xxx, 96xxx)
-   const californiaZips = responseZips.filter(zip => /^9[0-6]\d{3}$/.test(zip));
-   if (californiaZips.length > 0) {
-     issues.push(`California ZIP codes found: ${californiaZips.join(', ')}`);
-   }
-   
-   // Check for ZIP codes in response that aren't in original
-   const hallucinatedZips = responseZips.filter(zip => !originalZips.includes(zip));
-   if (hallucinatedZips.length > 0) {
-     issues.push(`Hallucinated ZIP codes: ${hallucinatedZips.join(', ')}`);
-   }
-   
-   // Check for suspicious score patterns (like scores ending in .2, .6, .1, .9 which might be generated)
-   const suspiciousScores = response.match(/\d+\.\d/g)?.filter(score => {
-     const decimal = parseFloat(score) % 1;
-     return Math.abs(decimal - 0.2) < 0.01 || Math.abs(decimal - 0.6) < 0.01 || 
-            Math.abs(decimal - 0.1) < 0.01 || Math.abs(decimal - 0.9) < 0.01;
---
+   const originalZips: string[] = originalAnalysis.match(/\b\d{5}\b/g) || [];
+   
+   // Check for California ZIP codes (90xxx, 91xxx, 92xxx, 93xxx, 94xxx, 95xxx, 96xxx)
+   const californiaZips = responseZips.filter(zip: any => /^9[0-6]\d{3}$/.test(zip));
+   if (californiaZips.length > 0) {
+     issues.push(`California ZIP codes found: ${californiaZips.join(', ')}`);
+   }
+   
+   // Check for ZIP codes in response that aren't in original
+   const hallucinatedZips = responseZips.filter(zip: any => !originalZips.includes(zip));
+   if (hallucinatedZips.length > 0) {
+     issues.push(`Hallucinated ZIP codes: ${hallucinatedZips.join(', ')}`);
+   }
+   
+   // Check for suspicious score patterns (like scores ending in .2, .6, .1, .9 which might be generated)
+   const suspiciousScores = response.match(/\d+\.\d/g)?.filter(score: any => {
+     const decimal = parseFloat(score) % 1;
+     return Math.abs(decimal - 0.2) < 0.01 || Math.abs(decimal - 0.6) < 0.01 || 
+            Math.abs(decimal - 0.1) < 0.01 || Math.abs(decimal - 0.9) < 0.01;
+   }) || [];
+   
+   if (suspiciousScores.length > 3) {
@@ lines 224-230 @@
-   };
-   
-   // Sort by the appropriate score field to get full range representation
-   const sorted = [...features].sort((a, b) => {
-     // Handle both flat and double-nested properties (feature.properties.properties)
-     const propsA = (a && typeof a === 'object') ? (a as any).properties || a : {};
-     const propsB = (b && typeof b === 'object') ? (b as any).properties || b : {};
---
+   };
+   
+   // Sort by the appropriate score field to get full range representation
+   const sorted = [...features].sort((a: any, b: any) => {
+     // Handle both flat and double-nested properties (feature.properties.properties)
+     const propsA = (a && typeof a === 'object') ? (a as any).properties || a : {};
+     const propsB = (b && typeof b === 'object') ? (b as any).properties || b : {};
+     const nestedA = (propsA && typeof propsA === 'object') ? (propsA as any).properties || propsA : propsA;
+     const nestedB = (propsB && typeof propsB === 'object') ? (propsB as any).properties || propsB : propsB;
+ 
@@ lines 261-268 @@
-       (b as any)?.value
-     ];
- 
-     const numA = Number(scoreCandidatesA.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
-     const numB = Number(scoreCandidatesB.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
-     return numB - numA; // Highest scores first
-   });
-   
---
+       (b as any)?.value
+     ];
+ 
+     const numA = Number(scoreCandidatesA.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
+     const numB = Number(scoreCandidatesB.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v)))) ?? 0);
+     return numB - numA; // Highest scores first
+   });
+   
+   // Use FULL dataset for accurate analysis - no sampling limits
+   topFeatures = sorted; // Use all features for comprehensive analysis
+   
@@ lines 1053-1059 @@
-     .map((f: any) => (f?.properties || f || {})[scoreField])
-     .filter((v: any) => typeof v === 'number' && !Number.isNaN(v)) as number[];
-   if (vals.length === 0) return null;
-   const sorted = [...vals].sort((a,b)=>a-b);
-   const n = sorted.length;
-   const q = (p: number) => {
-     const idx = (n - 1) * p;
---
+     .map((f: any) => (f?.properties || f || {})[scoreField])
+     .filter((v: any) => typeof v === 'number' && !Number.isNaN(v)) as number[];
+   if (vals.length === 0) return null;
+   const sorted = [...vals].sort((a: any,b: any)=>a-b);
+   const n = sorted.length;
+   const q = (p: number) => {
+     const idx = (n - 1) * p;
+     const lo = Math.floor(idx), hi = Math.ceil(idx);
+     if (lo === hi) return sorted[lo];
+     return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
@@ lines 1063-1069 @@
-   };
-   const min = sorted[0];
-   const max = sorted[n-1];
-   const avg = vals.reduce((a,b)=>a+b,0)/n;
-   return {
-     count: n,
-     min,
---
+   };
+   const min = sorted[0];
+   const max = sorted[n-1];
+   const avg = vals.reduce((a: any,b: any)=>a+b,0)/n;
+   return {
+     count: n,
+     min,
+     max,
+     avg,
+     q1: q(0.25),
@@ lines 1218-1224 @@
-                          lowerFieldName.includes('mlb') ||     // Specific sport fan percentages
-                          lowerFieldName.includes('nba') ||     // Specific sport fan percentages
-                          lowerFieldName.includes('nhl') ||     // Specific sport fan percentages
-                          layerConfig?.fields?.some(f => f?.label?.includes('%')) ||
-                          layerConfig?.metadata?.valueType === 'percentage');
-     
-     // REFINED CURRENCY DETECTION (CHECK THIRD)
---
+                          lowerFieldName.includes('mlb') ||     // Specific sport fan percentages
+                          lowerFieldName.includes('nba') ||     // Specific sport fan percentages
+                          lowerFieldName.includes('nhl') ||     // Specific sport fan percentages
+                          layerConfig?.fields?.some(f: any => f?.label?.includes('%')) ||
+                          layerConfig?.metadata?.valueType === 'percentage');
+     
+     // REFINED CURRENCY DETECTION (CHECK THIRD)
+     const isCurrency = !isIndex && !isPercentage && ( // Ensure not index or percentage
+                        lowerFieldName.includes('income') ||
+                        lowerFieldName.includes('spending') ||
@@ lines 1232-1238 @@
-                        lowerFieldName.includes('value') ||
-                        lowerFieldName.includes('budget') ||
-                        lowerFieldName.includes('$') ||
-                        layerConfig?.fields?.some(f => f?.label?.includes('$')) ||
-                        layerConfig?.metadata?.valueType === 'currency');
- 
-     // First check for NaN values
---
+                        lowerFieldName.includes('value') ||
+                        lowerFieldName.includes('budget') ||
+                        lowerFieldName.includes('$') ||
+                        layerConfig?.fields?.some(f: any => f?.label?.includes('$')) ||
+                        layerConfig?.metadata?.valueType === 'currency');
+ 
+     // First check for NaN values
+     if (isNaN(value)) {
+       return 'N/A';
+     }
@@ lines 1309-1321 @@
-     const candidates: any[] = [
-       nested?.[primaryField],
-       props?.[primaryField],
-       ...legacyFields.flatMap((f) => [nested?.[f], props?.[f]]),
-       nested?.target_value,
-       props?.target_value,
-       feature?.[primaryField],
-       feature?.value
-     ];
-     const chosen = candidates.find((v) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v))));
-     if (chosen === undefined) return undefined;
-     const num = Number(chosen);
-     return isNaN(num) ? undefined : num;
---
+     const candidates: any[] = [
+       nested?.[primaryField],
+       props?.[primaryField],
+       ...legacyFields.flatMap((f: any) => [nested?.[f], props?.[f]]),
+       nested?.target_value,
+       props?.target_value,
+       feature?.[primaryField],
+       feature?.value
+     ];
+     const chosen = candidates.find((v: any) => typeof v === 'number' || (typeof v === 'string' && v !== '' && !isNaN(Number(v))));
+     if (chosen === undefined) return undefined;
+     const num = Number(chosen);
+     return isNaN(num) ? undefined : num;
+   } catch {
+     return undefined;
+   }
@@ lines 1326-1332 @@
- 
- // **MODIFIED** Sorts a list of attribute objects by a field value
- function sortAttributesByField(attributeList: FeatureProperties[], field: string): FeatureProperties[] {
-   return [...attributeList].sort((a, b) => {
-     const valueA = Number(a[field]);
-     const valueB = Number(b[field]);
- 
---
+ 
+ // **MODIFIED** Sorts a list of attribute objects by a field value
+ function sortAttributesByField(attributeList: FeatureProperties[], field: string): FeatureProperties[] {
+   return [...attributeList].sort((a: any, b: any) => {
+     const valueA = Number(a[field]);
+     const valueB = Number(b[field]);
+ 
+     if (isNaN(valueA) && !isNaN(valueB)) return 1;
+     if (!isNaN(valueA) && isNaN(valueB)) return -1;
+     if (isNaN(valueA) && isNaN(valueB)) return 0;
@@ lines 1616-1627 @@
-     
-     // Rest of the function remains the same
-     let totalLength = 0;
-     chunks.forEach(chunk => {
-         totalLength += chunk.length;
-     });
-     const result = new Uint8Array(totalLength);
-     let offset = 0;
-     chunks.forEach(chunk => {
-         result.set(chunk, offset);
-         offset += chunk.length;
-     });
---
+     
+     // Rest of the function remains the same
+     let totalLength = 0;
+     chunks.forEach(chunk: any => {
+         totalLength += chunk.length;
+     });
+     const result = new Uint8Array(totalLength);
+     let offset = 0;
+     chunks.forEach(chunk: any => {
+         result.set(chunk, offset);
+         offset += chunk.length;
+     });
+     return Buffer.from(result); // Keep Buffer for now, will decode later
+ }
+ 
@@ lines 1793-1805 @@
-         // 🌟 NEW: Geographic Analysis Detection using new Geo-Awareness System
-         const geoEngine = GeoAwarenessEngine.getInstance();
-         const geoResult = await geoEngine.processGeoQuery(currentQuery, []);
-         const detectedCities = geoResult.matchedEntities.map(e => e.name);
-         const isCityQuery = geoResult.matchedEntities.length > 0;
-         const isCityComparison = geoResult.matchedEntities.length >= 2 && currentQuery.toLowerCase().includes('vs');
-         
-         if (isCityQuery) {
-           console.log('🏙️ [GEO ANALYSIS] Detected geographic query:', {
-             entities: geoResult.matchedEntities.map(e => ({ name: e.name, type: e.type })),
-             filterMethod: geoResult.filterStats.filterMethod,
-             isComparison: isCityComparison,
-             query: currentQuery
---
+         // 🌟 NEW: Geographic Analysis Detection using new Geo-Awareness System
+         const geoEngine = GeoAwarenessEngine.getInstance();
+         const geoResult = await geoEngine.processGeoQuery(currentQuery, []);
+         const detectedCities = geoResult.matchedEntities.map(e: any => e.name);
+         const isCityQuery = geoResult.matchedEntities.length > 0;
+         const isCityComparison = geoResult.matchedEntities.length >= 2 && currentQuery.toLowerCase().includes('vs');
+         
+         if (isCityQuery) {
+           console.log('🏙️ [GEO ANALYSIS] Detected geographic query:', {
+             entities: geoResult.matchedEntities.map(e: any => ({ name: e.name, type: e.type })),
+             filterMethod: geoResult.filterStats.filterMethod,
+             isComparison: isCityComparison,
+             query: currentQuery
+           });
+         }
+         if (metadata?.matched_fields) {
@@ lines 1845-1851 @@
-               const allAreas = [...(ls.top || []), ...(ls.bottom || [])];
-               
-               // Filter out national parks from sampling to ensure Claude gets legitimate business areas
-               const nonParkAreas = allAreas.filter(area => {
-                 const areaId = area.id || '';
-                 const areaName = area.name || '';
-                 
---
+               const allAreas = [...(ls.top || []), ...(ls.bottom || [])];
+               
+               // Filter out national parks from sampling to ensure Claude gets legitimate business areas
+               const nonParkAreas = allAreas.filter(area: any => {
+                 const areaId = area.id || '';
+                 const areaName = area.name || '';
+                 
+                 // Filter out national parks using same logic as analysisLens
+                 if (String(areaId).startsWith('000')) return false;
+                 
@@ lines 1858-1881 @@
-                   /state\s+park/i, /\bpark\b.*national/i, /\bnational\b.*\bpark\b/i,
-                   /\bnp\b/i, /\bnm\b/i, /\bnf\b/i
-                 ];
-                 return !parkPatterns.some(pattern => pattern.test(nameStr));
-               });
-               
-               console.log(`🔍 [HYBRID SAMPLING] Filtered ${allAreas.length - nonParkAreas.length} parks from ${allAreas.length} total areas`);
-               
-               if (nonParkAreas.length > 0) {
-                 const sortedByScore = nonParkAreas.sort((a, b) => (b.value || 0) - (a.value || 0));
-                 const scores = sortedByScore.map(a => a.value || 0);
-                 
-                 console.log(`🔍 [HYBRID SAMPLING] Non-park sampling from ${nonParkAreas.length} legitimate areas`);
-                 console.log(`🔍 [HYBRID SAMPLING] Top 5 non-park areas: ${sortedByScore.slice(0, 5).map(a => `${a.id}(${a.value?.toFixed(1)})`).join(', ')}`);
-                 
-                 // Calculate statistical measures
-                 const mean = scores.reduce((sum, val) => sum + val, 0) / scores.length;
-                 const median = scores.length % 2 === 0 
-                   ? (scores[Math.floor(scores.length / 2 - 1)] + scores[Math.floor(scores.length / 2)]) / 2
-                   : scores[Math.floor(scores.length / 2)];
-                 const stdDev = Math.sqrt(scores.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / scores.length);
-                 
-                 // 1. Top 15 absolute performers
-                 examples.push(...sortedByScore.slice(0, 15));
---
+                   /state\s+park/i, /\bpark\b.*national/i, /\bnational\b.*\bpark\b/i,
+                   /\bnp\b/i, /\bnm\b/i, /\bnf\b/i
+                 ];
+                 return !parkPatterns.some(pattern: any => pattern.test(nameStr));
+               });
+               
+               console.log(`🔍 [HYBRID SAMPLING] Filtered ${allAreas.length - nonParkAreas.length} parks from ${allAreas.length} total areas`);
+               
+               if (nonParkAreas.length > 0) {
+                 const sortedByScore = nonParkAreas.sort((a: any, b: any) => (b.value || 0) - (a.value || 0));
+                 const scores = sortedByScore.map(a: any => a.value || 0);
+                 
+                 console.log(`🔍 [HYBRID SAMPLING] Non-park sampling from ${nonParkAreas.length} legitimate areas`);
+                 console.log(`🔍 [HYBRID SAMPLING] Top 5 non-park areas: ${sortedByScore.slice(0, 5).map(a: any => `${a.id}(${a.value?.toFixed(1)})`).join(', ')}`);
+                 
+                 // Calculate statistical measures
+                 const mean = scores.reduce((sum: any, val: any) => sum + val, 0) / scores.length;
+                 const median = scores.length % 2 === 0 
+                   ? (scores[Math.floor(scores.length / 2 - 1)] + scores[Math.floor(scores.length / 2)]) / 2
+                   : scores[Math.floor(scores.length / 2)];
+                 const stdDev = Math.sqrt(scores.reduce((sum: any, val: any) => sum + Math.pow(val - mean, 2), 0) / scores.length);
+                 
+                 // 1. Top 15 absolute performers
+                 examples.push(...sortedByScore.slice(0, 15));
+                 
+                 // 2. Bottom 5 absolute performers
+                 examples.push(...sortedByScore.slice(-5));
@@ lines 1885-1906 @@
-                 
-                 // 3. Areas closest to median (find 3 closest)
-                 const medianCandidates = sortedByScore
-                   .map(area => ({ area, diff: Math.abs((area.value || 0) - median) }))
-                   .sort((a, b) => a.diff - b.diff)
-                   .slice(0, 3)
-                   .map(item => item.area);
-                 examples.push(...medianCandidates);
-                 
-                 // 4. Areas closest to mean (find 3 closest)
-                 const meanCandidates = sortedByScore
-                   .map(area => ({ area, diff: Math.abs((area.value || 0) - mean) }))
-                   .sort((a, b) => a.diff - b.diff)
-                   .slice(0, 3)
-                   .map(item => item.area);
-                 examples.push(...meanCandidates);
-                 
-                 // 5. Statistical outliers (>2σ from mean)
-                 const outliers = sortedByScore.filter(area => 
-                   Math.abs((area.value || 0) - mean) > (2 * stdDev)
-                 );
-                 examples.push(...outliers);
---
+                 
+                 // 3. Areas closest to median (find 3 closest)
+                 const medianCandidates = sortedByScore
+                   .map(area: any => ({ area, diff: Math.abs((area.value || 0) - median) }))
+                   .sort((a: any, b: any) => a.diff - b.diff)
+                   .slice(0, 3)
+                   .map(item: any => item.area);
+                 examples.push(...medianCandidates);
+                 
+                 // 4. Areas closest to mean (find 3 closest)
+                 const meanCandidates = sortedByScore
+                   .map(area: any => ({ area, diff: Math.abs((area.value || 0) - mean) }))
+                   .sort((a: any, b: any) => a.diff - b.diff)
+                   .slice(0, 3)
+                   .map(item: any => item.area);
+                 examples.push(...meanCandidates);
+                 
+                 // 5. Statistical outliers (>2σ from mean)
+                 const outliers = sortedByScore.filter(area: any => 
+                   Math.abs((area.value || 0) - mean) > (2 * stdDev)
+                 );
+                 examples.push(...outliers);
+                 
+                 // 6. Representative from each score decile (10 areas)
+                 for (let i = 0; i < 10; i++) {
@@ lines 1917-1923 @@
-                 
-                 // Remove duplicates while preserving order
-                 const seen = new Set();
-                 const uniqueExamples = examples.filter(ex => {
-                   const key = `${ex.id}_${ex.value}`;
-                   if (seen.has(key)) return false;
-                   seen.add(key);
---
+                 
+                 // Remove duplicates while preserving order
+                 const seen = new Set();
+                 const uniqueExamples = examples.filter(ex: any => {
+                   const key = `${ex.id}_${ex.value}`;
+                   if (seen.has(key)) return false;
+                   seen.add(key);
+                   return true;
+                 });
+                 
@@ lines 1930-1936 @@
-                 console.log(`🔍 [HYBRID SAMPLING] Layer ${idx}: Processed ${allAreas.length} total areas`);
-                 console.log(`🔍 [HYBRID SAMPLING] Statistics: mean=${mean.toFixed(2)}, median=${median.toFixed(2)}, stdDev=${stdDev.toFixed(2)}`);
-                 console.log(`🔍 [HYBRID SAMPLING] Sample composition: ${examples.length} unique areas (top 15 + bottom 5 + median 3 + mean 3 + outliers ${outliers.length} + decile reps 10)`);
-                 console.log(`🔍 [HYBRID SAMPLING] Sample IDs: ${examples.slice(0, 10).map(e => `${e.id}(${e.value?.toFixed(1)})`).join(', ')}${examples.length > 10 ? '...' : ''}`);
-               } else if (allAreas.length > 0) {
-                 // Fallback: use all areas but still filter parks
-                 console.log(`🔍 [HYBRID SAMPLING] Fallback: No non-park areas found, using unfiltered sample`);
---
+                 console.log(`🔍 [HYBRID SAMPLING] Layer ${idx}: Processed ${allAreas.length} total areas`);
+                 console.log(`🔍 [HYBRID SAMPLING] Statistics: mean=${mean.toFixed(2)}, median=${median.toFixed(2)}, stdDev=${stdDev.toFixed(2)}`);
+                 console.log(`🔍 [HYBRID SAMPLING] Sample composition: ${examples.length} unique areas (top 15 + bottom 5 + median 3 + mean 3 + outliers ${outliers.length} + decile reps 10)`);
+                 console.log(`🔍 [HYBRID SAMPLING] Sample IDs: ${examples.slice(0, 10).map(e: any => `${e.id}(${e.value?.toFixed(1)})`).join(', ')}${examples.length > 10 ? '...' : ''}`);
+               } else if (allAreas.length > 0) {
+                 // Fallback: use all areas but still filter parks
+                 console.log(`🔍 [HYBRID SAMPLING] Fallback: No non-park areas found, using unfiltered sample`);
+                 if (Array.isArray(ls.top)) examples.push(...ls.top.slice(0, 5));
+                 if (Array.isArray(ls.bottom)) examples.push(...ls.bottom.slice(0, 3));
+               } else {
@@ lines 1941-1947 @@
-                 console.log(`🔍 [HYBRID SAMPLING] No areas available for sampling`);
-               }
- 
-               const features = examples.map((e, i) => {
-                 // Find corresponding sample data to get additional fields
-                 // Try multiple matching strategies: exact ID match, exact name match, or positional fallback
-                 const sample = ls.samples?.find((s: any) => 
---
+                 console.log(`🔍 [HYBRID SAMPLING] No areas available for sampling`);
+               }
+ 
+               const features = examples.map((e: any, i: any) => {
+                 // Find corresponding sample data to get additional fields
+                 // Try multiple matching strategies: exact ID match, exact name match, or positional fallback
+                 const sample = ls.samples?.find((s: any) => 
+                   s.id === e.id || 
+                   s.name === e.name || 
+                   s.id === String(e.id) || 
@@ lines 2025-2031 @@
-                 // Chat sends featureData as [{layerId, features: [...]}] format
-                 // Extract features from the layer objects for contextual chat
-                 if (featureData[0]?.features) {
-                     processedLayersData = featureData.map(layer => ({
-                         layerId: layer.layerId || 'contextual_chat',
-                         layerName: layer.layerName || 'Chat Context',
-                         layerType: layer.layerType || 'polygon',
---
+                 // Chat sends featureData as [{layerId, features: [...]}] format
+                 // Extract features from the layer objects for contextual chat
+                 if (featureData[0]?.features) {
+                     processedLayersData = featureData.map(layer: any => ({
+                         layerId: layer.layerId || 'contextual_chat',
+                         layerName: layer.layerName || 'Chat Context',
+                         layerType: layer.layerType || 'polygon',
+                         layer: null as any,
+                         features: layer.features || [],
+                         extent: null
@@ lines 2156-2162 @@
-           }
- 
-           // Convert OptimizedLayerData to ProcessedLayerResult (existing logic)
-           processedLayersData = featureDataFromBlob.features.map(layer => {
-             // PATCH: Flatten FeatureCollection if present
-             let featuresArray = layer.features;
-             if (Array.isArray(featuresArray) && featuresArray.length === 1 && featuresArray[0]?.type === 'FeatureCollection' && Array.isArray(featuresArray[0].features)) {
---
+           }
+ 
+           // Convert OptimizedLayerData to ProcessedLayerResult (existing logic)
+           processedLayersData = featureDataFromBlob.features.map(layer: any => {
+             // PATCH: Flatten FeatureCollection if present
+             let featuresArray = layer.features;
+             if (Array.isArray(featuresArray) && featuresArray.length === 1 && featuresArray[0]?.type === 'FeatureCollection' && Array.isArray(featuresArray[0].features)) {
+               featuresArray = featuresArray[0].features;
+             }
+ 
@@ lines 2214-2220 @@
-         // Log layer structure for debugging if needed
-         if (process.env.NODE_ENV === 'development' && processedLayersData.length > 0) {
-           console.log(`[Claude] Processing ${processedLayersData.length} layers`);
-           processedLayersData.forEach((layer, idx) => {
-             console.log(`[Claude] Layer ${idx}: ${layer.layerId} (${layer.features?.length || 0} features)`);
-           });
-         }
---
+         // Log layer structure for debugging if needed
+         if (process.env.NODE_ENV === 'development' && processedLayersData.length > 0) {
+           console.log(`[Claude] Processing ${processedLayersData.length} layers`);
+           processedLayersData.forEach((layer: any, idx: any) => {
+             console.log(`[Claude] Layer ${idx}: ${layer.layerId} (${layer.features?.length || 0} features)`);
+           });
+         }
+ 
+         // --- Data Processing and Statistics Calculation ---
+         if (!processedLayersData || !Array.isArray(processedLayersData) || processedLayersData.length === 0) {
@@ lines 2226-2232 @@
- 
-         console.log('[Claude] Mapping featureData.features to processedLayersData...'); // Log before map
-         // Convert OptimizedLayerData to ProcessedLayerResult (reassign instead of redeclare)
-         processedLayersData = processedLayersData.map(layer => {
-             // PATCH: Flatten FeatureCollection if present
-             let featuresArray = layer.features;
-             // Type-safe check for FeatureCollection wrapper
---
+ 
+         console.log('[Claude] Mapping featureData.features to processedLayersData...'); // Log before map
+         // Convert OptimizedLayerData to ProcessedLayerResult (reassign instead of redeclare)
+         processedLayersData = processedLayersData.map(layer: any => {
+             // PATCH: Flatten FeatureCollection if present
+             let featuresArray = layer.features;
+             // Type-safe check for FeatureCollection wrapper
+             if (
+               Array.isArray(featuresArray) &&
+               featuresArray.length === 1 &&
@@ lines 2301-2307 @@
-                 layerName: layer.layerName || layer.layerId,
-                 layerType: layer.layerType || 'unknown',
-                 layer: layerConfig,
-                 features: featuresArray.map(feature => {
-                   // If already a LocalGeospatialFeature, use as-is
-                   if (feature && typeof feature === 'object' && 'type' in feature && 'properties' in feature) {
-                     return feature as LocalGeospatialFeature;
---
+                 layerName: layer.layerName || layer.layerId,
+                 layerType: layer.layerType || 'unknown',
+                 layer: layerConfig,
+                 features: featuresArray.map(feature: any => {
+                   // If already a LocalGeospatialFeature, use as-is
+                   if (feature && typeof feature === 'object' && 'type' in feature && 'properties' in feature) {
+                     return feature as LocalGeospatialFeature;
+                   }
+                   // Extract properties correctly to avoid double nesting
+                   let props: any = {};
@@ lines 2346-2352 @@
-         processedLayersData = processedLayersDataForAI;
- 
-         // If all layers have zero features after filtering, return an explanatory response
-         const totalFeaturesAfterFiltering = processedLayersData.reduce((sum, l) => sum + ((l && l.features && l.features.length) || 0), 0);
-         if (totalFeaturesAfterFiltering === 0) {
-           if (isContextualChat) {
-             console.log('[Claude] Contextual chat with no features after filtering - proceeding');
---
+         processedLayersData = processedLayersDataForAI;
+ 
+         // If all layers have zero features after filtering, return an explanatory response
+         const totalFeaturesAfterFiltering = processedLayersData.reduce((sum: any, l: any) => sum + ((l && l.features && l.features.length) || 0), 0);
+         if (totalFeaturesAfterFiltering === 0) {
+           if (isContextualChat) {
+             console.log('[Claude] Contextual chat with no features after filtering - proceeding');
+           } else {
+             console.warn('[Claude] No features remain after spatial filtering. Aborting LLM call to avoid hallucinated output.');
+             return NextResponse.json({
@@ lines 2461-2468 @@
-                       primaryAnalysisField = relevantFields[0];
-                   } else {
-                       // Further Fallback: first numeric field found that isn't OBJECTID, or just OBJECTID
-                       const availableNumericFields = Object.keys(firstFeatureProps).filter(key => typeof firstFeatureProps[key] === 'number');
-                       primaryAnalysisField = availableNumericFields.find(f => f.toUpperCase() !== 'OBJECTID') || availableNumericFields[0];
-                   }
-               }
-           }
---
+                       primaryAnalysisField = relevantFields[0];
+                   } else {
+                       // Further Fallback: first numeric field found that isn't OBJECTID, or just OBJECTID
+                       const availableNumericFields = Object.keys(firstFeatureProps).filter(key: any => typeof firstFeatureProps[key] === 'number');
+                       primaryAnalysisField = availableNumericFields.find(f: any => f.toUpperCase() !== 'OBJECTID') || availableNumericFields[0];
+                   }
+               }
+           }
+     
+ 
+         if (process.env.NODE_ENV === 'development') {
@@ lines 2474-2481 @@
- 
-           // --- Check if Relevant Data Found ---
-           let relevantDataFound = false;
-         if (primaryAnalysisField && processedLayersData.some(layer =>
-                layer.features && layer.features.some(feature => feature.properties?.[primaryAnalysisField!] !== undefined)))
-           {
-               relevantDataFound = true;
-               console.log(`[Claude Prompt Gen] Using primary analysis field: ${primaryAnalysisField}`);
---
+ 
+           // --- Check if Relevant Data Found ---
+           let relevantDataFound = false;
+         if (primaryAnalysisField && processedLayersData.some(layer: any =>
+                layer.features && layer.features.some(feature: any => feature.properties?.[primaryAnalysisField!] !== undefined)))
+           {
+               relevantDataFound = true;
+               console.log(`[Claude Prompt Gen] Using primary analysis field: ${primaryAnalysisField}`);
+           } else {
+            console.warn(`[Claude Prompt Gen] Could not determine a relevant primary numeric field for layer ${primaryLayerResult.layerId} based on query: \"${messages?.[messages.length - 1]?.content || metadata?.query || 'Analyze data'}\".`);
+           }
@@ lines 2509-2515 @@
-             const allWantedFields: string[] = Array.from(new Set((metadata?.matched_fields as string[]) || []));
-             if (allWantedFields.length > 0 && processedLayersData.length > 1) {
-               const unionLayer = unionByGeoId(
-                 processedLayersData.map(l => ({ layerId: l.layerId, features: l.features })),
-                 allWantedFields,
-                 'ID'
-               );
---
+             const allWantedFields: string[] = Array.from(new Set((metadata?.matched_fields as string[]) || []));
+             if (allWantedFields.length > 0 && processedLayersData.length > 1) {
+               const unionLayer = unionByGeoId(
+                 processedLayersData.map(l: any => ({ layerId: l.layerId, features: l.features })),
+                 allWantedFields,
+                 'ID'
+               );
+               processedLayersData.unshift({
+                 layerId: unionLayer.layerId,
+                 layerName: unionLayer.name,
@@ lines 2673-2679 @@
-               
-               const strategicValues = features
-                 .map(extractStrategicScore)
-                 .filter(v => typeof v === 'number' && !isNaN(v));
-               
-               // Get comprehensive statistics from originalSummary for context
-               const fullDatasetStats = originalSummary?.statistics;
---
+               
+               const strategicValues = features
+                 .map(extractStrategicScore)
+                 .filter(v: any => typeof v === 'number' && !isNaN(v));
+               
+               // Get comprehensive statistics from originalSummary for context
+               const fullDatasetStats = originalSummary?.statistics;
+               if (fullDatasetStats) {
+                 console.log(`📊 [Strategic Analysis Debug] Full dataset stats: ${fullDatasetStats.total} records, range ${fullDatasetStats.min}-${fullDatasetStats.max}`);
+               }
@@ lines 2685-2699 @@
-               console.log(`🔍 [Strategic Analysis Debug] Sample values:`, strategicValues.slice(0, 5));
-               
-               if (strategicValues.length > 0) {
-                 const sortedValues = strategicValues.sort((a, b) => a - b);
-                 const count = sortedValues.length;
-                 const min = sortedValues[0];
-                 const max = sortedValues[count - 1];
-                 const median = count % 2 === 0 ? 
-                   (sortedValues[count / 2 - 1] + sortedValues[count / 2]) / 2 : 
-                   sortedValues[Math.floor(count / 2)];
-                 const mean = strategicValues.reduce((a, b) => a + b, 0) / count;
-                 const variance = sortedValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
-                 const stdDev = Math.sqrt(variance);
-                 
-                 dataSummary += `\n=== STRATEGIC ANALYSIS STATISTICS (CRITICAL FOR ANALYSIS) ===\n`;
---
+               console.log(`🔍 [Strategic Analysis Debug] Sample values:`, strategicValues.slice(0, 5));
+               
+               if (strategicValues.length > 0) {
+                 const sortedValues = strategicValues.sort((a: any, b: any) => a - b);
+                 const count = sortedValues.length;
+                 const min = sortedValues[0];
+                 const max = sortedValues[count - 1];
+                 const median = count % 2 === 0 ? 
+                   (sortedValues[count / 2 - 1] + sortedValues[count / 2]) / 2 : 
+                   sortedValues[Math.floor(count / 2)];
+                 const mean = strategicValues.reduce((a: any, b: any) => a + b, 0) / count;
+                 const variance = sortedValues.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / count;
+                 const stdDev = Math.sqrt(variance);
+                 
+                 dataSummary += `\n=== STRATEGIC ANALYSIS STATISTICS (CRITICAL FOR ANALYSIS) ===\n`;
+                 dataSummary += `🚨 MANDATORY: Use these statistics for your analysis, NOT just the sample examples\n`;
+                 
+                 // Use full dataset statistics if available, otherwise calculate from sample
@@ lines 2718-2736 @@
-                 
-                 // Provide sample strategic markets from client summary with context about full dataset
-                 const featuresWithScores = features
-                   .map(f => ({
-                     feature: f,
-                     score: extractStrategicScore(f),
-                     areaName: f.properties?.area_name || f.properties?.DESCRIPTION || f.properties?.id || 'Unknown'
-                   }))
-                   .filter(item => !isNaN(item.score))
-                   .sort((a, b) => b.score - a.score);
-                 
-                 const topStrategicMarkets = featuresWithScores.slice(0, 10); // Representative sample for analysis
-                 
-                 if (topStrategicMarkets.length > 0) {
-                   dataSummary += `=== REPRESENTATIVE STRATEGIC MARKETS (sampled from ${fullDatasetStats?.total || 'full'} dataset) ===\n`;
-                   topStrategicMarkets.forEach((market, index) => {
-                     const props = market.feature.properties || market.feature;
-                     dataSummary += `${index + 1}. ${market.areaName}:\n`;
-                     dataSummary += `   🎯 Strategic Score: ${market.score.toFixed(2)}\n`;
---
+                 
+                 // Provide sample strategic markets from client summary with context about full dataset
+                 const featuresWithScores = features
+                   .map(f: any => ({
+                     feature: f,
+                     score: extractStrategicScore(f),
+                     areaName: f.properties?.area_name || f.properties?.DESCRIPTION || f.properties?.id || 'Unknown'
+                   }))
+                   .filter(item: any => !isNaN(item.score))
+                   .sort((a: any, b: any) => b.score - a.score);
+                 
+                 const topStrategicMarkets = featuresWithScores.slice(0, 10); // Representative sample for analysis
+                 
+                 if (topStrategicMarkets.length > 0) {
+                   dataSummary += `=== REPRESENTATIVE STRATEGIC MARKETS (sampled from ${fullDatasetStats?.total || 'full'} dataset) ===\n`;
+                   topStrategicMarkets.forEach((market: any, index: any) => {
+                     const props = market.feature.properties || market.feature;
+                     dataSummary += `${index + 1}. ${market.areaName}:\n`;
+                     dataSummary += `   🎯 Strategic Score: ${market.score.toFixed(2)}\n`;
+                     
+                     // Add key strategic context fields
+                     if (props.market_gap !== undefined) {
@@ lines 2803-2815 @@
-               // Use SAME method as calculateBasicStats from statsCalculator
-               const brandDiffValues = features
-                 .map(extractScore)
-                 .filter(v => typeof v === 'number' && !isNaN(v));
-               
-               console.log(`🔍 [AI Analysis Debug] Extracted ${brandDiffValues.length} brand difference values using statsCalculator method`);
-               console.log(`🔍 [AI Analysis Debug] Sample values:`, brandDiffValues.slice(0, 5));
-               
-               if (brandDiffValues.length > 0) {
-                 const sortedValues = brandDiffValues.sort((a, b) => a - b);
-                 const count = sortedValues.length;
-                 console.log(`🔍 [AI Analysis Debug] AI Analysis Range: ${sortedValues[0].toFixed(1)}% to ${sortedValues[count - 1].toFixed(1)}% (${count} markets)`);
-                 console.log(`🔍 [AI Analysis Debug] Expected: -16.7% to 0.0% (984 markets)`);
---
+               // Use SAME method as calculateBasicStats from statsCalculator
+               const brandDiffValues = features
+                 .map(extractScore)
+                 .filter(v: any => typeof v === 'number' && !isNaN(v));
+               
+               console.log(`🔍 [AI Analysis Debug] Extracted ${brandDiffValues.length} brand difference values using statsCalculator method`);
+               console.log(`🔍 [AI Analysis Debug] Sample values:`, brandDiffValues.slice(0, 5));
+               
+               if (brandDiffValues.length > 0) {
+                 const sortedValues = brandDiffValues.sort((a: any, b: any) => a - b);
+                 const count = sortedValues.length;
+                 console.log(`🔍 [AI Analysis Debug] AI Analysis Range: ${sortedValues[0].toFixed(1)}% to ${sortedValues[count - 1].toFixed(1)}% (${count} markets)`);
+                 console.log(`🔍 [AI Analysis Debug] Expected: -16.7% to 0.0% (984 markets)`);
+                 if (count !== 984 || sortedValues[0] > -16.7) {
+                   console.error(`⚠️ [AI Analysis Debug] DATA MISMATCH DETECTED!`);
+                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
@@ lines 2818-2828 @@
-                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
-                   console.error(`🔍 [AI Analysis Debug] First feature sample:`, features[0]);
-                 }
-                 const mean = sortedValues.reduce((a, b) => a + b, 0) / count;
-                 const median = count % 2 === 0 
-                   ? (sortedValues[Math.floor(count / 2) - 1] + sortedValues[Math.floor(count / 2)]) / 2
-                   : sortedValues[Math.floor(count / 2)];
-                 const variance = sortedValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
-                 const stdDev = Math.sqrt(variance);
-                 
-                 dataSummary += `\n=== BRAND DIFFERENCE STATISTICS (CRITICAL FOR RANGE) ===\n`;
---
+                   console.error(`🔍 [AI Analysis Debug] First 10 feature keys:`, Object.keys(features[0] || {}));
+                   console.error(`🔍 [AI Analysis Debug] First feature sample:`, features[0]);
+                 }
+                 const mean = sortedValues.reduce((a: any, b: any) => a + b, 0) / count;
+                 const median = count % 2 === 0 
+                   ? (sortedValues[Math.floor(count / 2) - 1] + sortedValues[Math.floor(count / 2)]) / 2
+                   : sortedValues[Math.floor(count / 2)];
+                 const variance = sortedValues.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / count;
+                 const stdDev = Math.sqrt(variance);
+                 
+                 dataSummary += `\n=== BRAND DIFFERENCE STATISTICS (CRITICAL FOR RANGE) ===\n`;
+                 dataSummary += `🚨 MANDATORY: Use these statistics for your analysis range, NOT individual examples\n`;
+                 dataSummary += `• Markets analyzed: ${count}\n`;
+                 dataSummary += `• Average difference: ${mean.toFixed(2)}%\n`;
@@ lines 3034-3053 @@
-             if (features.length > 0) {
-                 const firstFeature = features[0];
-                 const allProperties = firstFeature.properties || firstFeature;
-                 const availableFields = Object.keys(allProperties).filter(key => 
-                     typeof allProperties[key] === 'number' && !isNaN(allProperties[key])
-                 );
-                 
-                 // Debug: Check for Nike/Adidas fields specifically
-                 const nikeField = availableFields.find(f => f.toLowerCase().includes('mp30034a_b'));
-                 const adidasField = availableFields.find(f => f.toLowerCase().includes('mp30029a_b'));
-                 console.log(`[DEBUG Nike/Adidas] Layer ${layerName}: Nike field found: ${nikeField}, Adidas field found: ${adidasField}`);
-                 if (nikeField) console.log(`[DEBUG Nike] Sample value: ${allProperties[nikeField]}`);
-                 if (adidasField) console.log(`[DEBUG Adidas] Sample value: ${allProperties[adidasField]}`);
-                 
-                 if (availableFields.length > 0) {
-                     dataSummary += `- Available Data Fields:\n`;
-                     availableFields.forEach(fieldName => {
-                         const humanReadableName = getHumanReadableFieldName(fieldName);
-                         const sampleValue = allProperties[fieldName];
-                         // Determine field type and unit for better context
---
+             if (features.length > 0) {
+                 const firstFeature = features[0];
+                 const allProperties = firstFeature.properties || firstFeature;
+                 const availableFields = Object.keys(allProperties).filter(key: any => 
+                     typeof allProperties[key] === 'number' && !isNaN(allProperties[key])
+                 );
+                 
+                 // Debug: Check for Nike/Adidas fields specifically
+                 const nikeField = availableFields.find(f: any => f.toLowerCase().includes('mp30034a_b'));
+                 const adidasField = availableFields.find(f: any => f.toLowerCase().includes('mp30029a_b'));
+                 console.log(`[DEBUG Nike/Adidas] Layer ${layerName}: Nike field found: ${nikeField}, Adidas field found: ${adidasField}`);
+                 if (nikeField) console.log(`[DEBUG Nike] Sample value: ${allProperties[nikeField]}`);
+                 if (adidasField) console.log(`[DEBUG Adidas] Sample value: ${allProperties[adidasField]}`);
+                 
+                 if (availableFields.length > 0) {
+                     dataSummary += `- Available Data Fields:\n`;
+                     availableFields.forEach(fieldName: any => {
+                         const humanReadableName = getHumanReadableFieldName(fieldName);
+                         const sampleValue = allProperties[fieldName];
+                         // Determine field type and unit for better context
+                         const fieldType = getFieldDataType(fieldName, layerConfig);
+                         const formattedSampleValue = formatFieldValue(sampleValue, fieldName, layerConfig);
+                         
@@ lines 3083-3089 @@
-                       const finalValue = value1 !== undefined ? value1 : value2;
-                       return Number(finalValue);
-                     })
-                     .filter(v => !isNaN(v)); // Filter out NaN values
-                 console.log(`[Claude Prompt Gen] Layer ${layerName}: Found ${validValues.length} valid numeric values for ${currentLayerPrimaryField}.`);
-             } catch (e) {
-                 console.error(`[Claude Prompt Gen] Error extracting/converting values for ${currentLayerPrimaryField} in layer ${layerName}:`, e);
---
+                       const finalValue = value1 !== undefined ? value1 : value2;
+                       return Number(finalValue);
+                     })
+                     .filter(v: any => !isNaN(v)); // Filter out NaN values
+                 console.log(`[Claude Prompt Gen] Layer ${layerName}: Found ${validValues.length} valid numeric values for ${currentLayerPrimaryField}.`);
+             } catch (e) {
+                 console.error(`[Claude Prompt Gen] Error extracting/converting values for ${currentLayerPrimaryField} in layer ${layerName}:`, e);
+                 validValues = [];
+             }
+ 
@@ lines 3093-3104 @@
-             if (validValues.length > 0) {
-                 // Cap values for competitive analysis (thematic_value should be 1-10 scale)
-                 const cappedValues = currentLayerPrimaryField === 'thematic_value' ? 
-                   validValues.map(v => v > 10 ? Math.max(1.0, Math.min(10.0, v)) : v) : 
-                   validValues;
-                 
-                 const minValue = Math.min(...cappedValues);
-                 const maxValue = Math.max(...cappedValues);
-                 const meanValue = cappedValues.reduce((a, b) => a + b, 0) / cappedValues.length;
- 
-                           dataSummary += `- ${humanReadableFieldName} Range: ${formatFieldValue(minValue, currentLayerPrimaryField, layerConfig)} to ${formatFieldValue(maxValue, currentLayerPrimaryField, layerConfig)}\n`;
-             dataSummary += `- ${humanReadableFieldName} Average: ${formatFieldValue(meanValue, currentLayerPrimaryField, layerConfig)}\n`;
---
+             if (validValues.length > 0) {
+                 // Cap values for competitive analysis (thematic_value should be 1-10 scale)
+                 const cappedValues = currentLayerPrimaryField === 'thematic_value' ? 
+                   validValues.map(v: any => v > 10 ? Math.max(1.0, Math.min(10.0, v)) : v) : 
+                   validValues;
+                 
+                 const minValue = Math.min(...cappedValues);
+                 const maxValue = Math.max(...cappedValues);
+                 const meanValue = cappedValues.reduce((a: any, b: any) => a + b, 0) / cappedValues.length;
+ 
+                           dataSummary += `- ${humanReadableFieldName} Range: ${formatFieldValue(minValue, currentLayerPrimaryField, layerConfig)} to ${formatFieldValue(maxValue, currentLayerPrimaryField, layerConfig)}\n`;
+             dataSummary += `- ${humanReadableFieldName} Average: ${formatFieldValue(meanValue, currentLayerPrimaryField, layerConfig)}\n`;
+                 console.log(`[Claude Prompt Gen] Added stats for ${currentLayerPrimaryField} to summary.`);
+             } else {
+                 dataSummary += `- No valid numeric data found for ${humanReadableFieldName}.\n`;
@@ lines 3186-3192 @@
- 
-                     if (topFeatures.length > 0) {
-                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
-                         topFeatures.forEach((tf, index) => {
-                             // Cap any scores over 10 (competitive analysis should be 1-10 scale)
-                             let valueToFormat = tf.value;
-                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
---
+ 
+                     if (topFeatures.length > 0) {
+                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
+                         topFeatures.forEach((tf: any, index: any) => {
+                             // Cap any scores over 10 (competitive analysis should be 1-10 scale)
+                             let valueToFormat = tf.value;
+                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
+                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
+                               console.log(`🔧 [Regular Processing] Capped score from ${tf.value} to ${valueToFormat} for area ${tf.description || tf.zipCode}`);
+                             } else if (tf.value > 10) {
@@ lines 3226-3232 @@
- 
-                     if (topFeatures.length > 0) {
-                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
-                         topFeatures.forEach((tf, index) => {
-                             let valueToFormat = tf.value;
-                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
-                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
---
+ 
+                     if (topFeatures.length > 0) {
+                         dataSummary += `- Top Areas by ${humanReadableFieldName}:\n`;
+                         topFeatures.forEach((tf: any, index: any) => {
+                             let valueToFormat = tf.value;
+                             if (currentLayerPrimaryField === 'thematic_value' && tf.value > 10) {
+                               valueToFormat = Math.max(1.0, Math.min(10.0, tf.value));
+                             }
+                             
+                             const formattedValue = formatFieldValue(valueToFormat, currentLayerPrimaryField, layerConfig);
@@ lines 3323-3334 @@
-                const numericFields = Object.entries(firstFeature.properties)
-                  .filter(([_, value]) => typeof value === 'number' && !isNaN(value as number))
-                  .map(([key]) => key)
-                  .filter(key => !['OBJECTID', 'Shape__Area', 'Shape__Length', 'joint_score'].includes(key.toUpperCase())); // Also exclude joint_score itself
- 
-                if (numericFields.length >= 2) {
-                  // Assign only if inference hasn't already succeeded
-                  if (!varA) varA = numericFields[0];
-                  if (!varB) varB = numericFields.find(f => f !== varA) || numericFields[1]; // Ensure different fields
-                  console.log('[Joint Analysis] Inference Attempt 3 (feature properties): varA=${varA}, varB=${varB}');
-                } else {
-                  console.warn('[Joint Analysis] Fallback failed: First feature has < 2 suitable numeric properties.');
---
+                const numericFields = Object.entries(firstFeature.properties)
+                  .filter(([_, value]) => typeof value === 'number' && !isNaN(value as number))
+                  .map(([key]) => key)
+                  .filter(key: any => !['OBJECTID', 'Shape__Area', 'Shape__Length', 'joint_score'].includes(key.toUpperCase())); // Also exclude joint_score itself
+ 
+                if (numericFields.length >= 2) {
+                  // Assign only if inference hasn't already succeeded
+                  if (!varA) varA = numericFields[0];
+                  if (!varB) varB = numericFields.find(f: any => f !== varA) || numericFields[1]; // Ensure different fields
+                  console.log('[Joint Analysis] Inference Attempt 3 (feature properties): varA=${varA}, varB=${varB}');
+                } else {
+                  console.warn('[Joint Analysis] Fallback failed: First feature has < 2 suitable numeric properties.');
+                }
+              } else {
+                console.warn('[Joint Analysis] Fallback failed: Cannot access properties of the first feature.');
@@ lines 3392-3398 @@
-               details: {
-                 varA,
-                 varB,
-                 featureCount: processedLayersData.reduce((sum, layer) => sum + layer.features.length, 0)
-               }
-             }, { status: 400 });
-           }
---
+               details: {
+                 varA,
+                 varB,
+                 featureCount: processedLayersData.reduce((sum: any, layer: any) => sum + layer.features.length, 0)
+               }
+             }, { status: 400 });
+           }
+ 
+           // Calculate statistics
+           const min = Math.min(...jointScoreValues);
@@ lines 3400-3417 @@
-           // Calculate statistics
-           const min = Math.min(...jointScoreValues);
-           const max = Math.max(...jointScoreValues);
-           const mean = jointScoreValues.reduce((a, b) => a + b, 0) / jointScoreValues.length;
-           const median = jointScoreValues.sort((a, b) => a - b)[Math.floor(jointScoreValues.length / 2)];
- 
-           // Sort features by joint_score
-           jointScoreFeatures.sort((a, b) => {
-             const scoreA = a.properties?.joint_score ?? (a as any).attributes?.joint_score ?? 0;
-             const scoreB = b.properties?.joint_score ?? (b as any).attributes?.joint_score ?? 0;
-             return scoreB - scoreA;
-           });
-           
-           // Get top 5 regions with more detailed information
-           const topRegions = jointScoreFeatures.slice(0, 5).map((f, i) => {
-             const zipCode = getZIPCode(f);
-             const locationName = getLocationName(f);
-             const jointScore = f.properties?.joint_score ?? (f as any).attributes?.joint_score;
---
+           // Calculate statistics
+           const min = Math.min(...jointScoreValues);
+           const max = Math.max(...jointScoreValues);
+           const mean = jointScoreValues.reduce((a: any, b: any) => a + b, 0) / jointScoreValues.length;
+           const median = jointScoreValues.sort((a: any, b: any) => a - b)[Math.floor(jointScoreValues.length / 2)];
+ 
+           // Sort features by joint_score
+           jointScoreFeatures.sort((a: any, b: any) => {
+             const scoreA = a.properties?.joint_score ?? (a as any).attributes?.joint_score ?? 0;
+             const scoreB = b.properties?.joint_score ?? (b as any).attributes?.joint_score ?? 0;
+             return scoreB - scoreA;
+           });
+           
+           // Get top 5 regions with more detailed information
+           const topRegions = jointScoreFeatures.slice(0, 5).map((f: any, i: any) => {
+             const zipCode = getZIPCode(f);
+             const locationName = getLocationName(f);
+             const jointScore = f.properties?.joint_score ?? (f as any).attributes?.joint_score;
+             const valueA = f.properties?.[varA] ?? (f as any).attributes?.[varA];
+             const valueB = f.properties?.[varB] ?? (f as any).attributes?.[varB];
+             
@@ lines 3438-3444 @@
-           dataSummary += `  • Total Regions Analyzed: ${jointScoreValues.length}\n\n`;
-           dataSummary += `Top 5 Regions by Combined Score:\n`;
-           
-           topRegions.forEach(region => {
-             dataSummary += `${region.rank}. ${region.location} (${region.zipCode}):\n`;
-             dataSummary += `   • Combined Score: ${region.jointScore}\n`;
-             dataSummary += `   • ${varA}: ${region.valueA}\n`;
---
+           dataSummary += `  • Total Regions Analyzed: ${jointScoreValues.length}\n\n`;
+           dataSummary += `Top 5 Regions by Combined Score:\n`;
+           
+           topRegions.forEach(region: any => {
+             dataSummary += `${region.rank}. ${region.location} (${region.zipCode}):\n`;
+             dataSummary += `   • Combined Score: ${region.jointScore}\n`;
+             dataSummary += `   • ${varA}: ${region.valueA}\n`;
+             dataSummary += `   • ${varB}: ${region.valueB}\n`;
+           });
+ 
@@ lines 3477-3488 @@
-                 enhancedFieldContext = `
- ENHANCED QUERY ANALYSIS:
- - User Query: "${userQuery}"
- - Detected Fields: ${detectedFields.map(f => `${f.field} (${f.description})`).join(', ')}
- - Recommended Endpoint: ${bestEndpoint || 'general'}
- - Primary Analysis Field: ${primaryAnalysisField}
- 
- FIELD INTERPRETATION GUIDANCE:
- ${detectedFields.map(f => `- ${f.field}: ${f.description}`).join('\n')}
- `;
-                 console.log(`[Claude] Enhanced field analysis - detected ${detectedFields.length} relevant fields`);
-             }
---
+                 enhancedFieldContext = `
+ ENHANCED QUERY ANALYSIS:
+ - User Query: "${userQuery}"
+ - Detected Fields: ${detectedFields.map(f: any => `${f.field} (${f.description})`).join(', ')}
+ - Recommended Endpoint: ${bestEndpoint || 'general'}
+ - Primary Analysis Field: ${primaryAnalysisField}
+ 
+ FIELD INTERPRETATION GUIDANCE:
+ ${detectedFields.map(f: any => `- ${f.field}: ${f.description}`).join('\n')}
+ `;
+                 console.log(`[Claude] Enhanced field analysis - detected ${detectedFields.length} relevant fields`);
+             }
+         } catch (error) {
+             console.warn('[Claude] Error in enhanced field analysis:', error);
+         }
@@ lines 4068-4074 @@
-             }
-             
-             console.log('[Claude] Sending conversation with', validMessages.length, 'messages');
-             console.log('[Claude] Message roles:', validMessages.map(m => m.role).join(' -> '));
-             
-             anthropicResponse = await anthropic.messages.create({
-                 model: 'claude-3-5-sonnet-20240620',
---
+             }
+             
+             console.log('[Claude] Sending conversation with', validMessages.length, 'messages');
+             console.log('[Claude] Message roles:', validMessages.map(m: any => m.role).join(' -> '));
+             
+             anthropicResponse = await anthropic.messages.create({
+                 model: 'claude-3-5-sonnet-20240620',
+                 max_tokens: 4096,
+                 system: dynamicSystemPrompt,
+                 messages: validMessages
@@ lines 4095-4101 @@
-                 }
-             }, { status: 500 });
-         }
-         const responseContent = anthropicResponse.content?.find(block => block.type === 'text')?.text || 'No text content received from AI.';
- 
-   // Sanitize Model Attribution section to enforce conditional display and remove placeholders
-         let finalContent = responseContent;
---
+                 }
+             }, { status: 500 });
+         }
+         const responseContent = anthropicResponse.content?.find(block: any => block.type === 'text')?.text || 'No text content received from AI.';
+ 
+   // Sanitize Model Attribution section to enforce conditional display and remove placeholders
+         let finalContent = responseContent;
+         try {
+           // If we have a numeric R², replace any 'Not recorded/Not specified/Data not available' with the actual value
+           if (computedAttribution && typeof computedAttribution.r2 === 'number' && !Number.isNaN(computedAttribution.r2)) {
@@ lines 4128-4134 @@
-         // Name placeholder sanitation in AI narrative: replace "Unknown Area" with real top strategic names when possible
-         try {
-           if (/Top Strategic Markets:/i.test(finalContent) && /Unknown Area/i.test(finalContent)) {
-             const allFeatures = (processedLayersData || []).flatMap(layer => Array.isArray((layer as any)?.features) ? (layer as any).features : []);
-             const candidates = allFeatures
-               .map((feat: any) => {
-                 const props = feat?.properties || feat || {};
---
+         // Name placeholder sanitation in AI narrative: replace "Unknown Area" with real top strategic names when possible
+         try {
+           if (/Top Strategic Markets:/i.test(finalContent) && /Unknown Area/i.test(finalContent)) {
+             const allFeatures = (processedLayersData || []).flatMap(layer: any => Array.isArray((layer as any)?.features) ? (layer as any).features : []);
+             const candidates = allFeatures
+               .map((feat: any) => {
+                 const props = feat?.properties || feat || {};
+                 const score = Number(
+                   props?.strategic_analysis_score ??
+                   props?.strategic_value_score ??
@@ lines 4315-4327 @@
-   // New regex to detect cluster mentions in the format "CLUSTER X" or "Cluster X:"
-   const clusterRegex = /\b(?:CLUSTER|Cluster)\s+(\d+)(?:\s*:|:\s*|\s+)(.*?)(?:\n|$)/g;
- 
-   const zipMatches = Array.from(text.matchAll(zipRegex)).map(m => m[0]);
-   const postalCodeMatches = Array.from(text.matchAll(postalCodeRegex)).map(m => m[1]);
-   const districtMatches = Array.from(text.matchAll(districtRegex)).map(m => m[1]);
-   
-   // Extract cluster information
-   const clusterMatches = Array.from(text.matchAll(clusterRegex));
-   const clusterInfo = clusterMatches.map(match => {
-     const clusterId = match[1]; // The cluster number
-     const clusterName = match[2].trim(); // The cluster name/description
-     
---
+   // New regex to detect cluster mentions in the format "CLUSTER X" or "Cluster X:"
+   const clusterRegex = /\b(?:CLUSTER|Cluster)\s+(\d+)(?:\s*:|:\s*|\s+)(.*?)(?:\n|$)/g;
+ 
+   const zipMatches = Array.from(text.matchAll(zipRegex)).map(m: any => m[0]);
+   const postalCodeMatches = Array.from(text.matchAll(postalCodeRegex)).map(m: any => m[1]);
+   const districtMatches = Array.from(text.matchAll(districtRegex)).map(m: any => m[1]);
+   
+   // Extract cluster information
+   const clusterMatches = Array.from(text.matchAll(clusterRegex));
+   const clusterInfo = clusterMatches.map(match: any => {
+     const clusterId = match[1]; // The cluster number
+     const clusterName = match[2].trim(); // The cluster name/description
+     
+     // Try to find ZIP codes associated with this cluster
+     // Look for sections that follow the cluster definition and mention ZIP codes
+     const clusterText = text.substring(match.index);
@@ lines 4334-4340 @@
-     let zipCodes: string[] = [];
-     if (zipListMatch && zipListMatch[1]) {
-       // Extract ZIP codes from the comma-separated list
-       zipCodes = zipListMatch[1].split(/,\s*|\s+and\s+|\s+/).filter(s => /\d{5}/.test(s));
-     }
-             
-             return {
---
+     let zipCodes: string[] = [];
+     if (zipListMatch && zipListMatch[1]) {
+       // Extract ZIP codes from the comma-separated list
+       zipCodes = zipListMatch[1].split(/,\s*|\s+and\s+|\s+/).filter(s: any => /\d{5}/.test(s));
+     }
+             
+             return {
+       id: `cluster-${clusterId}`,
+       name: clusterName,
+       zipCodes: zipCodes
@@ lines 4364-4371 @@
-         sourceLayerIdForClickable = relevantLayerId;
-         const config = layerConfigs[relevantLayerId];
-         // Determine the identifier field (PRIORITIZE DESCRIPTION if present and type is string)
-         const descField = config.fields?.find(f => f.name === 'DESCRIPTION' && f.type === 'string');
-         const zipField = config.fields?.find(f => f.name.toUpperCase() === 'ZIP' || f.name.toUpperCase() === 'ZIPCODE' || f.name.toUpperCase() === 'POSTAL_CODE');
- 
-         if (descField) {
-             sourceIdentifierFieldForClickable = descField.name;
---
+         sourceLayerIdForClickable = relevantLayerId;
+         const config = layerConfigs[relevantLayerId];
+         // Determine the identifier field (PRIORITIZE DESCRIPTION if present and type is string)
+         const descField = config.fields?.find(f: any => f.name === 'DESCRIPTION' && f.type === 'string');
+         const zipField = config.fields?.find(f: any => f.name.toUpperCase() === 'ZIP' || f.name.toUpperCase() === 'ZIPCODE' || f.name.toUpperCase() === 'POSTAL_CODE');
+ 
+         if (descField) {
+             sourceIdentifierFieldForClickable = descField.name;
+         } else if (zipField) {
+             sourceIdentifierFieldForClickable = zipField.name;
+         } else {
@@ lines 4387-4405 @@
-      if (relevantLayerId && layerConfigs[relevantLayerId]) {
-         sourceLayerIdForClickable = relevantLayerId;
-         // Common postal code field or check config
-         const postalField = layerConfigs[relevantLayerId].fields?.find(f => f.name.toUpperCase() === 'CFSAUID');
-         sourceIdentifierFieldForClickable = postalField ? postalField.name : 'CFSAUID'; 
-      }
-   } 
-   // ... (rest of district logic, potentially update similarly)
- 
-   // If we found clusters and they have meaningful information, include them in the return value
-   if (clusters && clusters.length > 0 && clusters.some(c => c.zipCodes.length > 0)) {
-     console.log('[extractIdentifiersAndType] Identified clusters:', clusters);
-     // If we have more clusters than other identifiers, prioritize clusters
-     if ((featureType === undefined || clusters.length > validIdentifiers.length) && clusters.length >= 2) {
-       featureType = 'Cluster';
-       validIdentifiers = clusters.map(c => c.id);
-     }
-   }
- 
---
+      if (relevantLayerId && layerConfigs[relevantLayerId]) {
+         sourceLayerIdForClickable = relevantLayerId;
+         // Common postal code field or check config
+         const postalField = layerConfigs[relevantLayerId].fields?.find(f: any => f.name.toUpperCase() === 'CFSAUID');
+         sourceIdentifierFieldForClickable = postalField ? postalField.name : 'CFSAUID'; 
+      }
+   } 
+   // ... (rest of district logic, potentially update similarly)
+ 
+   // If we found clusters and they have meaningful information, include them in the return value
+   if (clusters && clusters.length > 0 && clusters.some(c: any => c.zipCodes.length > 0)) {
+     console.log('[extractIdentifiersAndType] Identified clusters:', clusters);
+     // If we have more clusters than other identifiers, prioritize clusters
+     if ((featureType === undefined || clusters.length > validIdentifiers.length) && clusters.length >= 2) {
+       featureType = 'Cluster';
+       validIdentifiers = clusters.map(c: any => c.id);
+     }
+   }
+ 
+   console.log('[extractIdentifiersAndType] Results:', { 
+     featureType, 
+     count: validIdentifiers.length, 
@@ lines 4435-4441 @@
-   console.log(`[generateClusterInformation] Processing features to identify clusters with primary field: ${primaryField}`);
-   
-   // Get all features from all layers
-   const allFeatures = layerResults.flatMap(layer => layer.features);
-   
-   // Skip if we don't have enough features
-   if (allFeatures.length < 10) {
---
+   console.log(`[generateClusterInformation] Processing features to identify clusters with primary field: ${primaryField}`);
+   
+   // Get all features from all layers
+   const allFeatures = layerResults.flatMap(layer: any => layer.features);
+   
+   // Skip if we don't have enough features
+   if (allFeatures.length < 10) {
+     console.log(`[generateClusterInformation] Not enough features (${allFeatures.length}) to identify meaningful clusters`);
+     return '';
+   }
@@ lines 4444-4450 @@
-   }
- 
-   // Filter for features that have the primary field
-   const validFeatures = allFeatures.filter(f => 
-     f.properties && f.properties[primaryField] !== undefined &&
-     !isNaN(Number(f.properties[primaryField]))
-   );
---
+   }
+ 
+   // Filter for features that have the primary field
+   const validFeatures = allFeatures.filter(f: any => 
+     f.properties && f.properties[primaryField] !== undefined &&
+     !isNaN(Number(f.properties[primaryField]))
+   );
+ 
+   if (validFeatures.length < 10) {
+     console.log(`[generateClusterInformation] Not enough valid features (${validFeatures.length}) with the primary field`);
@@ lines 4456-4462 @@
-   
-   try {
-     // Sort features by value, high to low
-     const sortedFeatures = [...validFeatures].sort((a, b) => {
-       const valA = Number(a.properties?.[primaryField]);
-       const valB = Number(b.properties?.[primaryField]);
-       return valB - valA;
---
+   
+   try {
+     // Sort features by value, high to low
+     const sortedFeatures = [...validFeatures].sort((a: any, b: any) => {
+       const valA = Number(a.properties?.[primaryField]);
+       const valB = Number(b.properties?.[primaryField]);
+       return valB - valA;
+     });
+     
+     // Take top 25% of features by value (the filtering done in visualization)
@@ lines 4472-4478 @@
-     // This simulates the spatial clustering that would happen in the actual visualization
-     const zipRegionClusters = new Map<string, Array<any>>();
-     
-     topFeatures.forEach(feature => {
-       // Get ZIP code
-       const zip = getZIPCode(feature);
-       // Use first 3 digits as region identifier - approximating geographic proximity
---
+     // This simulates the spatial clustering that would happen in the actual visualization
+     const zipRegionClusters = new Map<string, Array<any>>();
+     
+     topFeatures.forEach(feature: any => {
+       // Get ZIP code
+       const zip = getZIPCode(feature);
+       // Use first 3 digits as region identifier - approximating geographic proximity
+       const regionId = zip.substring(0, 3);
+       
+       if (!zipRegionClusters.has(regionId)) {
@@ lines 4490-4503 @@
-       .map(([regionId, features]) => {
-         // Calculate average value for the cluster
-         const avgValue = features.reduce(
-           (sum, f) => sum + Number(f.properties[primaryField]), 0
-         ) / features.length;
- 
-         // Get top ZIP codes for this cluster (highest values first)
-         const topZips = features
-           .sort((a, b) => Number(b.properties[primaryField]) - Number(a.properties[primaryField]))
-           .slice(0, 5)
-           .map(f => getZIPCode(f));
- 
-   // Determine a region name from the features using shared resolver
-   let regionName = resolveSharedRegionName(features, regionId, { neutralFallback: `Region ${regionId}` });
---
+       .map(([regionId, features]) => {
+         // Calculate average value for the cluster
+         const avgValue = features.reduce(
+           (sum: any, f: any) => sum + Number(f.properties[primaryField]), 0
+         ) / features.length;
+ 
+         // Get top ZIP codes for this cluster (highest values first)
+         const topZips = features
+           .sort((a: any, b: any) => Number(b.properties[primaryField]) - Number(a.properties[primaryField]))
+           .slice(0, 5)
+           .map(f: any => getZIPCode(f));
+ 
+   // Determine a region name from the features using shared resolver
+   let regionName = resolveSharedRegionName(features, regionId, { neutralFallback: `Region ${regionId}` });
+   if (!regionName) regionName = `Region ${regionId}`;
+         // Add region identifier to name if it doesn't already contain it
+         if (!regionName.includes(regionId)) {
@@ lines 4530-4543 @@
-     const displayFieldName = getHumanReadableFieldName(primaryField || 'Unknown Field');
- 
-     // Sort clusters by their average values (descending) before displaying
-     validClusters.sort((a, b) => b.avgValue - a.avgValue);
-     const limitedClusters = validClusters.slice(0, maxClusters);
-     
-     // Now generate the cluster info text with VERY explicit ranking
-     let clusterInfo = `CRITICAL: The following clusters are in EXACT RANKED ORDER from highest to lowest average value. DO NOT change this order in your response.\n\n`;
-     clusterInfo += `Identified ${limitedClusters.length} significant clusters of areas with high ${displayFieldName} values:\n\n`;
-     
-     limitedClusters.forEach((cluster, index) => {
-       // Make the rank extremely clear in multiple places
-       clusterInfo += `RANK ${index + 1} (${index === 0 ? 'HIGHEST' : index === limitedClusters.length - 1 ? 'LOWEST' : 'MIDDLE'} VALUE): ${cluster.regionName} Region\n`;
-       clusterInfo += `- ABSOLUTE RANK: #${index + 1} of ${limitedClusters.length} clusters\n`;
---
+     const displayFieldName = getHumanReadableFieldName(primaryField || 'Unknown Field');
+ 
+     // Sort clusters by their average values (descending) before displaying
+     validClusters.sort((a: any, b: any) => b.avgValue - a.avgValue);
+     const limitedClusters = validClusters.slice(0, maxClusters);
+     
+     // Now generate the cluster info text with VERY explicit ranking
+     let clusterInfo = `CRITICAL: The following clusters are in EXACT RANKED ORDER from highest to lowest average value. DO NOT change this order in your response.\n\n`;
+     clusterInfo += `Identified ${limitedClusters.length} significant clusters of areas with high ${displayFieldName} values:\n\n`;
+     
+     limitedClusters.forEach((cluster: any, index: any) => {
+       // Make the rank extremely clear in multiple places
+       clusterInfo += `RANK ${index + 1} (${index === 0 ? 'HIGHEST' : index === limitedClusters.length - 1 ? 'LOWEST' : 'MIDDLE'} VALUE): ${cluster.regionName} Region\n`;
+       clusterInfo += `- ABSOLUTE RANK: #${index + 1} of ${limitedClusters.length} clusters\n`;
+       clusterInfo += `- AVERAGE VALUE: ${cluster.avgValue.toFixed(2)} (${index === 0 ? 'HIGHEST OF ALL CLUSTERS' : ''})\n`;
+       clusterInfo += `- Member Count: ${cluster.count} areas\n`;
+               clusterInfo += `- Key ZIP codes in cluster: ${cluster.topZips.join(', ')}\n\n`;
@@ lines 4887-4893 @@
-     
-     // Check if this field is in the layer's fields array
-     if (layer.fields) {
-       const field = layer.fields.find(f => f.name === fieldName);
-       if (field) {
-         return field.label || field.alias || field.description || layer.name;
-       }
---
+     
+     // Check if this field is in the layer's fields array
+     if (layer.fields) {
+       const field = layer.fields.find(f: any => f.name === fieldName);
+       if (field) {
+         return field.label || field.alias || field.description || layer.name;
+       }
+     }
+   }
+ 
@@ lines 4898-4904 @@
-   return fieldName
-     .replace(/_/g, ' ')
-     .replace(/([A-Z])/g, ' $1')
-     .replace(/^./, str => str.toUpperCase())
-     .trim();
- }
- 
---
+   return fieldName
+     .replace(/_/g, ' ')
+     .replace(/([A-Z])/g, ' $1')
+     .replace(/^./, str: any => str.toUpperCase())
+     .trim();
+ }
+ 
+ // Get field data type and unit information for better analysis context
+ function getFieldDataType(fieldName: string, layerConfig: LayerConfig | undefined): string {
+   if (!fieldName) return 'unknown';
@@ lines 4920-4926 @@
-   }
-   
-   // Check field configuration
-   const fieldConfig = layerConfig?.fields?.find(f => f.name.toLowerCase() === lowerFieldName);
-   if (fieldConfig?.label?.includes('%')) return 'percentage';
-   if (fieldConfig?.label?.includes('$')) return 'currency';
-   
---
+   }
+   
+   // Check field configuration
+   const fieldConfig = layerConfig?.fields?.find(f: any => f.name.toLowerCase() === lowerFieldName);
+   if (fieldConfig?.label?.includes('%')) return 'percentage';
+   if (fieldConfig?.label?.includes('$')) return 'currency';
+   
+   // Pattern-based detection (enhanced for better accuracy)
+   const isIndex = lowerFieldName.includes('index') ||
+                  lowerFieldName.includes('score') ||


*** FILE: utils/dynamic-visualization-factory.ts
@@ lines 329-335 @@
-   private readonly visualizationPrompts: AIVisualizationPrompt[] = [
-     {
-       type: 'point-layer',
-       prompt: (context) => `Analyze point data visualization needs.
-         Consider:
-         - Point density: ${context.spatialPatterns?.density || 'unknown'}
-         - Clustering level: ${context.spatialPatterns?.clustering || 'unknown'}
---
+   private readonly visualizationPrompts: AIVisualizationPrompt[] = [
+     {
+       type: 'point-layer',
+       prompt: (context: any) => `Analyze point data visualization needs.
+         Consider:
+         - Point density: ${context.spatialPatterns?.density || 'unknown'}
+         - Clustering level: ${context.spatialPatterns?.clustering || 'unknown'}
+         - Distribution pattern: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Individual point locations, discrete events, or facilities
+         Avoid if: Data represents areas or continuous phenomena`,
@@ lines 340-346 @@
-     },
-     {
-       type: 'single-layer',
-       prompt: (context) => `Analyze single layer polygon visualization needs.
-         Consider:
-         - Data distribution: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
-         - Feature count: ${context.spatialPatterns?.density || 'unknown'}
---
+     },
+     {
+       type: 'single-layer',
+       prompt: (context: any) => `Analyze single layer polygon visualization needs.
+         Consider:
+         - Data distribution: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
+         - Feature count: ${context.spatialPatterns?.density || 'unknown'}
+         Best for: Area-based data, administrative boundaries, zones
+         Avoid if: Data represents points or networks`,
+       context: {}
@@ lines 350-366 @@
-     },
-     {
-       type: 'correlation',
-       prompt: (context) => `Analyze correlation visualization needs.
-         Consider:
-         - Statistical correlations: ${context.relationships?.statistical.map(r => `${r.layer1}-${r.layer2}: ${r.correlation}`).join(', ') || 'none'}
-         - Variable relationships: ${context.attributePatterns?.correlations.map(c => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
-         Best for: Comparing two or more variables, finding relationships
-         Avoid if: Single variable analysis or spatial patterns are more important`,
-       context: {}
-     },
-     {
-       type: 'hotspot',
-       prompt: (context) => `Analyze hotspot visualization needs.
-         Consider:
-         - Clustering intensity: ${context.spatialPatterns?.clustering || 'unknown'}
-         - Point density variations: ${context.spatialPatterns?.density || 'unknown'}
---
+     },
+     {
+       type: 'correlation',
+       prompt: (context: any) => `Analyze correlation visualization needs.
+         Consider:
+         - Statistical correlations: ${context.relationships?.statistical.map(r: any => `${r.layer1}-${r.layer2}: ${r.correlation}`).join(', ') || 'none'}
+         - Variable relationships: ${context.attributePatterns?.correlations.map(c: any => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
+         Best for: Comparing two or more variables, finding relationships
+         Avoid if: Single variable analysis or spatial patterns are more important`,
+       context: {}
+     },
+     {
+       type: 'hotspot',
+       prompt: (context: any) => `Analyze hotspot visualization needs.
+         Consider:
+         - Clustering intensity: ${context.spatialPatterns?.clustering || 'unknown'}
+         - Point density variations: ${context.spatialPatterns?.density || 'unknown'}
+         Best for: Identifying areas of high concentration or activity
+         Avoid if: Data is uniformly distributed or categorical`,
+       context: {}
@@ lines 370-378 @@
-     },
-     {
-       type: 'bivariate',
-       prompt: (context) => `Analyze bivariate visualization needs.
-         Consider:
-         - Variable correlations: ${context.attributePatterns?.correlations.map(c => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
-         - Distribution types: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
-         Best for: Showing relationship between two variables simultaneously
-         Avoid if: More than two variables or single variable is sufficient`,
---
+     },
+     {
+       type: 'bivariate',
+       prompt: (context: any) => `Analyze bivariate visualization needs.
+         Consider:
+         - Variable correlations: ${context.attributePatterns?.correlations.map(c: any => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
+         - Distribution types: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
+         Best for: Showing relationship between two variables simultaneously
+         Avoid if: More than two variables or single variable is sufficient`,
+       context: {}
+     },
+     {
@@ lines 380-396 @@
-     },
-     {
-       type: 'multivariate',
-       prompt: (context) => `Analyze multivariate visualization needs.
-         Consider:
-         - Number of variables: ${Object.keys(context.attributePatterns?.distributions || {}).length}
-         - Variable relationships: ${context.attributePatterns?.correlations.map(c => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
-         Best for: Complex relationships between multiple variables
-         Avoid if: Simple relationships or too many variables (>5)`,
-       context: {}
-     },
-     {
-       type: 'proportional-symbol',
-       prompt: (context) => `Analyze proportional symbol visualization needs.
-         Consider:
-         - Value range: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
-         - Spatial distribution: ${context.spatialPatterns?.distribution || 'unknown'}
---
+     },
+     {
+       type: 'multivariate',
+       prompt: (context: any) => `Analyze multivariate visualization needs.
+         Consider:
+         - Number of variables: ${Object.keys(context.attributePatterns?.distributions || {}).length}
+         - Variable relationships: ${context.attributePatterns?.correlations.map(c: any => `${c.field1}-${c.field2}: ${c.strength}`).join(', ') || 'none'}
+         Best for: Complex relationships between multiple variables
+         Avoid if: Simple relationships or too many variables (>5)`,
+       context: {}
+     },
+     {
+       type: 'proportional-symbol',
+       prompt: (context: any) => `Analyze proportional symbol visualization needs.
+         Consider:
+         - Value range: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
+         - Spatial distribution: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing quantities at specific locations, magnitude differences
+         Avoid if: Data represents areas or continuous surfaces`,
+       context: {}
@@ lines 400-406 @@
-     },
-     {
-       type: 'choropleth',
-       prompt: (context) => `Analyze choropleth visualization needs.
-         Consider:
-         - Data normalization: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
-         - Area unit consistency: ${context.spatialPatterns?.distribution || 'unknown'}
---
+     },
+     {
+       type: 'choropleth',
+       prompt: (context: any) => `Analyze choropleth visualization needs.
+         Consider:
+         - Data normalization: ${Object.entries(context.attributePatterns?.distributions || {}).map(([field, dist]) => `${field}: ${dist.type}`).join(', ') || 'none'}
+         - Area unit consistency: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing normalized data across areas, rates, densities
+         Avoid if: Data is not normalized or areas vary greatly in size`,
+       context: {}
@@ lines 410-416 @@
-     },
-     {
-       type: 'hexbin',
-       prompt: (context) => `Analyze hexbin visualization needs.
-         Consider:
-         - Point density: ${context.spatialPatterns?.density || 'unknown'}
-         - Clustering patterns: ${context.spatialPatterns?.clustering || 'unknown'}
---
+     },
+     {
+       type: 'hexbin',
+       prompt: (context: any) => `Analyze hexbin visualization needs.
+         Consider:
+         - Point density: ${context.spatialPatterns?.density || 'unknown'}
+         - Clustering patterns: ${context.spatialPatterns?.clustering || 'unknown'}
+         Best for: Aggregating point data into regular hexagonal bins
+         Avoid if: Exact point locations are important or data is already aggregated`,
+       context: {}
@@ lines 420-426 @@
-     },
-     {
-       type: 'spider',
-       prompt: (context) => `Analyze spider/flow visualization needs.
-         Consider:
-         - Connection density: ${context.relationships?.spatial.length || 0}
-         - Node distribution: ${context.spatialPatterns?.distribution || 'unknown'}
---
+     },
+     {
+       type: 'spider',
+       prompt: (context: any) => `Analyze spider/flow visualization needs.
+         Consider:
+         - Connection density: ${context.relationships?.spatial.length || 0}
+         - Node distribution: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing connections between locations, networks, flows
+         Avoid if: No meaningful connections between features`,
+       context: {}
@@ lines 430-436 @@
-     },
-     {
-       type: 'time-series',
-       prompt: (context) => `Analyze time-series visualization needs.
-         Consider:
-         - Temporal patterns: ${context.temporalPatterns?.frequency || 'unknown'}
-         - Value changes: ${context.temporalPatterns?.trend || 'unknown'}
---
+     },
+     {
+       type: 'time-series',
+       prompt: (context: any) => `Analyze time-series visualization needs.
+         Consider:
+         - Temporal patterns: ${context.temporalPatterns?.frequency || 'unknown'}
+         - Value changes: ${context.temporalPatterns?.trend || 'unknown'}
+         Best for: Showing change over time, temporal patterns
+         Avoid if: No temporal component or single time point`,
+       context: {}
@@ lines 440-446 @@
-     },
-     {
-       type: 'density',
-       prompt: (context) => `Analyze density visualization needs.
-         Consider:
-         - Point concentration: ${context.spatialPatterns?.density || 'unknown'}
-         - Distribution type: ${context.spatialPatterns?.distribution || 'unknown'}
---
+     },
+     {
+       type: 'density',
+       prompt: (context: any) => `Analyze density visualization needs.
+         Consider:
+         - Point concentration: ${context.spatialPatterns?.density || 'unknown'}
+         - Distribution type: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing continuous density surfaces from point data
+         Avoid if: Discrete locations are important or data is already continuous`,
+       context: {}
@@ lines 450-456 @@
-     },
-     {
-       type: 'cluster',
-       prompt: (context) => `Analyze cluster visualization needs.
-         Consider:
-         - Clustering strength: ${context.spatialPatterns?.clustering || 'unknown'}
-         - Group patterns: ${context.attributePatterns?.distributions || 'unknown'}
---
+     },
+     {
+       type: 'cluster',
+       prompt: (context: any) => `Analyze cluster visualization needs.
+         Consider:
+         - Clustering strength: ${context.spatialPatterns?.clustering || 'unknown'}
+         - Group patterns: ${context.attributePatterns?.distributions || 'unknown'}
+         Best for: Identifying and showing groups of similar features
+         Avoid if: Continuous surfaces or individual points are more important`,
+       context: {}
@@ lines 460-468 @@
-     },
-     {
-       type: 'proximity',
-       prompt: (context) => `Analyze proximity visualization needs.
-         Consider:
-         - Distance relationships: ${context.relationships?.spatial.map(r => r.type).join(', ') || 'none'}
-         - Feature distribution: ${context.spatialPatterns?.distribution || 'unknown'}
-         Best for: Showing distance-based relationships, service areas
-         Avoid if: Distance is not a key factor`,
---
+     },
+     {
+       type: 'proximity',
+       prompt: (context: any) => `Analyze proximity visualization needs.
+         Consider:
+         - Distance relationships: ${context.relationships?.spatial.map(r: any => r.type).join(', ') || 'none'}
+         - Feature distribution: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing distance-based relationships, service areas
+         Avoid if: Distance is not a key factor`,
+       context: {}
+     },
+     {
@@ lines 470-476 @@
-     },
-     {
-       type: 'buffer',
-       prompt: (context) => `Analyze buffer visualization needs.
-         Consider:
-         - Feature type: ${context.featureType || 'unknown'}
-         - Spatial distribution: ${context.spatialPatterns?.distribution || 'unknown'}
---
+     },
+     {
+       type: 'buffer',
+       prompt: (context: any) => `Analyze buffer visualization needs.
+         Consider:
+         - Feature type: ${context.featureType || 'unknown'}
+         - Spatial distribution: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing areas of influence, impact zones
+         Avoid if: Exact boundaries or distances are not relevant`,
+       context: {}
@@ lines 480-488 @@
-     },
-     {
-       type: 'network',
-       prompt: (context) => `Analyze network visualization needs.
-         Consider:
-         - Connection patterns: ${context.relationships?.spatial.map(r => r.type).join(', ') || 'none'}
-         - Node distribution: ${context.spatialPatterns?.distribution || 'unknown'}
-         Best for: Showing connected systems, transportation networks
-         Avoid if: No network structure exists in data`,
---
+     },
+     {
+       type: 'network',
+       prompt: (context: any) => `Analyze network visualization needs.
+         Consider:
+         - Connection patterns: ${context.relationships?.spatial.map(r: any => r.type).join(', ') || 'none'}
+         - Node distribution: ${context.spatialPatterns?.distribution || 'unknown'}
+         Best for: Showing connected systems, transportation networks
+         Avoid if: No network structure exists in data`,
+       context: {}
+     },
+     {
@@ lines 490-498 @@
-     },
-     {
-       type: 'composite',
-       prompt: (context) => `Analyze composite visualization needs.
-         Consider:
-         - Layer relationships: ${context.relationships?.spatial.map(r => r.type).join(', ') || 'none'}
-         - Data complexity: ${Object.keys(context.attributePatterns?.distributions || {}).length} variables
-         Best for: Combining multiple visualization types for complex data
-         Avoid if: Single visualization type is sufficient`,
---
+     },
+     {
+       type: 'composite',
+       prompt: (context: any) => `Analyze composite visualization needs.
+         Consider:
+         - Layer relationships: ${context.relationships?.spatial.map(r: any => r.type).join(', ') || 'none'}
+         - Data complexity: ${Object.keys(context.attributePatterns?.distributions || {}).length} variables
+         Best for: Combining multiple visualization types for complex data
+         Avoid if: Single visualization type is sufficient`,
+       context: {}
+     }
+   ];
@@ lines 518-524 @@
-     return {
-       spatialPatterns,
-       attributePatterns: {
-         correlations: attributePatterns.correlations.map(c => ({
-           field1: c.field1,
-           field2: c.field2,
-           strength: c.strength,
---
+     return {
+       spatialPatterns,
+       attributePatterns: {
+         correlations: attributePatterns.correlations.map(c: any => ({
+           field1: c.field1,
+           field2: c.field2,
+           strength: c.strength,
+           method: 'pearson' as const,
+           significance: 0.95,
+           spatialStats: c.spatialStats
@@ lines 534-543 @@
-   private async analyzeSpatialPatterns(features: any[]) {
-     console.log('Analyzing spatial patterns');
-     // Calculate spatial statistics
-     const points = features.map(f => {
-       const centroid = this.getFeatureCentroid(f);
-       return centroid || null;
-     }).filter((point): point is [number, number] => point !== null);
- 
-     if (!points.length) return { clustering: 0, distribution: 'unknown', density: 0 };
- 
---
+   private async analyzeSpatialPatterns(features: any[]) {
+     console.log('Analyzing spatial patterns');
+     // Calculate spatial statistics
+     const points = features.map(f: any => {
+       const centroid = this.getFeatureCentroid(f);
+       return centroid || null;
+     }).filter((point: any): point is [number, number] => point !== null);
+ 
+     if (!points.length) return { clustering: 0, distribution: 'unknown', density: 0 };
+ 
+     // Calculate clustering using nearest neighbor analysis
+     const clustering = await this.calculateClustering(points);
+     
@@ lines 563-570 @@
-   private async analyzeAttributePatterns(features: any[], rendererField: string) {
-     console.log('Analyzing attribute patterns');
-     const values = features
-       .map(f => f.properties?.[rendererField] || f.attributes?.[rendererField])
-       .filter((v): v is number => typeof v === 'number' && !isNaN(v));
- 
-     if (!values.length) return { correlations: [], distribution: { type: 'unknown', parameters: {} } };
- 
---
+   private async analyzeAttributePatterns(features: any[], rendererField: string) {
+     console.log('Analyzing attribute patterns');
+     const values = features
+       .map(f: any => f.properties?.[rendererField] || f.attributes?.[rendererField])
+       .filter((v: any): v is number => typeof v === 'number' && !isNaN(v));
+ 
+     if (!values.length) return { correlations: [], distribution: { type: 'unknown', parameters: {} } };
+ 
+     // Calculate distribution type
+     const distribution = this.determineValueDistribution(values);
+ 
@@ lines 580-586 @@
-     });
- 
-     return {
-       correlations: correlations.map(c => ({
-         field1: c.field1,
-         field2: c.field2,
-         strength: c.strength,
---
+     });
+ 
+     return {
+       correlations: correlations.map(c: any => ({
+         field1: c.field1,
+         field2: c.field2,
+         strength: c.strength,
+         method: 'pearson' as const,
+         significance: 0.95,
+         spatialStats: c.spatialStats
@@ lines 623-636 @@
- 
-     // Get all numeric fields
-     const numericFields = Object.keys(features[0].attributes || features[0].properties || {})
-       .filter(key => {
-         const value = features[0].attributes?.[key] || features[0].properties?.[key];
-         return typeof value === 'number' && !isNaN(value);
-       });
- 
-     // Create a temporary feature layer for correlation analysis
-     const tempLayer = new FeatureLayer({
-       source: features.map(f => new Graphic({
-         attributes: f.attributes || f.properties,
-         geometry: f.geometry
-       }))
---
+ 
+     // Get all numeric fields
+     const numericFields = Object.keys(features[0].attributes || features[0].properties || {})
+       .filter(key: any => {
+         const value = features[0].attributes?.[key] || features[0].properties?.[key];
+         return typeof value === 'number' && !isNaN(value);
+       });
+ 
+     // Create a temporary feature layer for correlation analysis
+     const tempLayer = new FeatureLayer({
+       source: features.map(f: any => new Graphic({
+         attributes: f.attributes || f.properties,
+         geometry: f.geometry
+       }))
+     });
+ 
+     // Calculate correlations with other fields
@@ lines 726-732 @@
-     const midY = (bounds.minY + bounds.maxY) / 2;
- 
-     const quadrants = [0, 0, 0, 0];
-     points.forEach(point => {
-       if (point[0] < midX && point[1] < midY) quadrants[0]++;
-       else if (point[0] >= midX && point[1] < midY) quadrants[1]++;
-       else if (point[0] < midX && point[1] >= midY) quadrants[2]++;
---
+     const midY = (bounds.minY + bounds.maxY) / 2;
+ 
+     const quadrants = [0, 0, 0, 0];
+     points.forEach(point: any => {
+       if (point[0] < midX && point[1] < midY) quadrants[0]++;
+       else if (point[0] >= midX && point[1] < midY) quadrants[1]++;
+       else if (point[0] < midX && point[1] >= midY) quadrants[2]++;
+       else quadrants[3]++;
+     });
+ 
@@ lines 735-741 @@
- 
-     // Calculate chi-square statistic for uniform distribution
-     const expected = points.length / 4;
-     const chiSquare = quadrants.reduce((sum, count) => 
-       sum + Math.pow(count - expected, 2) / expected, 0);
- 
-     // Determine distribution type based on chi-square value
---
+ 
+     // Calculate chi-square statistic for uniform distribution
+     const expected = points.length / 4;
+     const chiSquare = quadrants.reduce((sum: any, count: any) => 
+       sum + Math.pow(count - expected, 2) / expected, 0);
+ 
+     // Determine distribution type based on chi-square value
+     if (chiSquare < 3) return 'uniform';
+     if (chiSquare < 7) return 'random';
+     return 'clustered';
@@ lines 748-758 @@
-     if (values.length < 10) return { type: 'unknown', parameters: {} };
- 
-     // Calculate basic statistics
-     const mean = values.reduce((a, b) => a + b, 0) / values.length;
-     const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
-     const stdDev = Math.sqrt(variance);
-     const skewness = values.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 3), 0) / values.length;
-     const kurtosis = values.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 4), 0) / values.length - 3;
- 
-     // Determine distribution type based on statistical properties
-     if (Math.abs(skewness) < 0.5 && Math.abs(kurtosis) < 1) {
---
+     if (values.length < 10) return { type: 'unknown', parameters: {} };
+ 
+     // Calculate basic statistics
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+     const variance = values.reduce((a: any, b: any) => a + Math.pow(b - mean, 2), 0) / values.length;
+     const stdDev = Math.sqrt(variance);
+     const skewness = values.reduce((a: any, b: any) => a + Math.pow((b - mean) / stdDev, 3), 0) / values.length;
+     const kurtosis = values.reduce((a: any, b: any) => a + Math.pow((b - mean) / stdDev, 4), 0) / values.length - 3;
+ 
+     // Determine distribution type based on statistical properties
+     if (Math.abs(skewness) < 0.5 && Math.abs(kurtosis) < 1) {
+       return {
+         type: 'normal',
+         parameters: { mean, stdDev }
@@ lines 823-834 @@
-   private async analyzeSpatialRelationship(layer1: LayerResult, layer2: LayerResult): Promise<SpatialRelationship> {
-     // Calculate centroids for both layers
-     const centroids1 = layer1.features
-       .map(f => this.getFeatureCentroid(f))
-       .filter((point): point is [number, number] => point !== null);
-     
-     const centroids2 = layer2.features
-       .map(f => this.getFeatureCentroid(f))
-       .filter((point): point is [number, number] => point !== null);
- 
-     if (!centroids1.length || !centroids2.length) {
-       return {
---
+   private async analyzeSpatialRelationship(layer1: LayerResult, layer2: LayerResult): Promise<SpatialRelationship> {
+     // Calculate centroids for both layers
+     const centroids1 = layer1.features
+       .map(f: any => this.getFeatureCentroid(f))
+       .filter((point: any): point is [number, number] => point !== null);
+     
+     const centroids2 = layer2.features
+       .map(f: any => this.getFeatureCentroid(f))
+       .filter((point: any): point is [number, number] => point !== null);
+ 
+     if (!centroids1.length || !centroids2.length) {
+       return {
+         layer1: layer1.layer.id,
+         layer2: layer2.layer.id,
+         type: 'unknown',
@@ lines 940-946 @@
-   }
- 
-   private getLayerBounds(points: [number, number][]): Bounds {
-     return points.reduce((acc, point) => ({
-       minX: Math.min(acc.minX, point[0]),
-       maxX: Math.max(acc.maxX, point[0]),
-       minY: Math.min(acc.minY, point[1]),
---
+   }
+ 
+   private getLayerBounds(points: [number, number][]): Bounds {
+     return points.reduce((acc: any, point: any) => ({
+       minX: Math.min(acc.minX, point[0]),
+       maxX: Math.max(acc.maxX, point[0]),
+       minY: Math.min(acc.minY, point[1]),
+       maxY: Math.max(acc.maxY, point[1])
+     }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
+   }
@@ lines 979-985 @@
-     };
-   }> {
-     // Find the appropriate prompt for the layer type
-     const prompt = this.visualizationPrompts.find(p => p.type === layerType);
-     if (!prompt) {
-       throw new Error(`No AI prompt found for layer type: ${layerType}`);
-     }
---
+     };
+   }> {
+     // Find the appropriate prompt for the layer type
+     const prompt = this.visualizationPrompts.find(p: any => p.type === layerType);
+     if (!prompt) {
+       throw new Error(`No AI prompt found for layer type: ${layerType}`);
+     }
+ 
+     // Update the prompt context with current analysis
+     const context = {
@@ lines 988-994 @@
-     const context = {
-       spatialPatterns: analysis.layerCharacteristics.spatialPatterns,
-       attributePatterns: {
-         correlations: analysis.layerCharacteristics.attributePatterns.correlations.map(c => ({
-           ...c,
-           method: 'pearson' as const,
-           significance: 0.05
---
+     const context = {
+       spatialPatterns: analysis.layerCharacteristics.spatialPatterns,
+       attributePatterns: {
+         correlations: analysis.layerCharacteristics.attributePatterns.correlations.map(c: any => ({
+           ...c,
+           method: 'pearson' as const,
+           significance: 0.05
+         })),
+         distributions: analysis.layerCharacteristics.attributePatterns.distributions
+       },
@@ lines 1054-1077 @@
- 
-   private async analyzeHotspots(features: any[], field: string): Promise<{ threshold: number; clusters: any[] }> {
-     // Calculate intensity values
-     const values = features.map(f => f.properties?.[field] || f.attributes?.[field])
-       .filter((v): v is number => typeof v === 'number' && !isNaN(v));
- 
-     if (!values.length) {
-       return { threshold: 0, clusters: [] };
-     }
- 
-     // Calculate statistics
-     const mean = values.reduce((a, b) => a + b, 0) / values.length;
-     const stdDev = Math.sqrt(
-       values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length
-     );
- 
-     // Set threshold at mean + 1 standard deviation
-     const threshold = mean + stdDev;
- 
-     // Identify clusters
-     const clusters = features.filter(f => {
-       const value = f.properties?.[field] || f.attributes?.[field];
-       return typeof value === 'number' && value > threshold;
-     });
---
+ 
+   private async analyzeHotspots(features: any[], field: string): Promise<{ threshold: number; clusters: any[] }> {
+     // Calculate intensity values
+     const values = features.map(f: any => f.properties?.[field] || f.attributes?.[field])
+       .filter((v: any): v is number => typeof v === 'number' && !isNaN(v));
+ 
+     if (!values.length) {
+       return { threshold: 0, clusters: [] };
+     }
+ 
+     // Calculate statistics
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+     const stdDev = Math.sqrt(
+       values.reduce((a: any, b: any) => a + Math.pow(b - mean, 2), 0) / values.length
+     );
+ 
+     // Set threshold at mean + 1 standard deviation
+     const threshold = mean + stdDev;
+ 
+     // Identify clusters
+     const clusters = features.filter(f: any => {
+       const value = f.properties?.[field] || f.attributes?.[field];
+       return typeof value === 'number' && value > threshold;
+     });
+ 
+     return { threshold, clusters };
+   }
@@ lines 1083-1092 @@
-     correlation: number;
-     categories: string[];
-   }> {
-     const pairs = features.map(f => ({
-       val1: f.properties?.[field1] || f.attributes?.[field1],
-       val2: f.properties?.[field2] || f.attributes?.[field2]
-     })).filter(p => 
-       typeof p.val1 === 'number' && !isNaN(p.val1) &&
-       typeof p.val2 === 'number' && !isNaN(p.val2)
-     );
---
+     correlation: number;
+     categories: string[];
+   }> {
+     const pairs = features.map(f: any => ({
+       val1: f.properties?.[field1] || f.attributes?.[field1],
+       val2: f.properties?.[field2] || f.attributes?.[field2]
+     })).filter(p: any => 
+       typeof p.val1 === 'number' && !isNaN(p.val1) &&
+       typeof p.val2 === 'number' && !isNaN(p.val2)
+     );
+ 
+     if (!pairs.length) {
+       return { correlation: 0, categories: [] };
@@ lines 1097-1104 @@
- 
-     // Calculate correlation
-     const correlation = this.calculatePearsonCorrelation(
-       pairs.map(p => p.val1),
-       pairs.map(p => p.val2)
-     );
- 
-     // Create categories based on quartiles
---
+ 
+     // Calculate correlation
+     const correlation = this.calculatePearsonCorrelation(
+       pairs.map(p: any => p.val1),
+       pairs.map(p: any => p.val2)
+     );
+ 
+     // Create categories based on quartiles
+     const categories = ['Low-Low', 'Low-High', 'High-Low', 'High-High'];
+ 
+     return { correlation, categories };
@@ lines 1113-1120 @@
-     field1Label: string;
-     field2Label: string;
-   } {
-     const field1Values = features.map(f => f.attributes[field1]).filter(v => v !== null);
-     const field2Values = features.map(f => f.attributes[field2]).filter(v => v !== null);
- 
-     const field1Breaks = this.calculateQuartileBreaks(field1Values);
-     const field2Breaks = this.calculateQuartileBreaks(field2Values);
---
+     field1Label: string;
+     field2Label: string;
+   } {
+     const field1Values = features.map(f: any => f.attributes[field1]).filter(v: any => v !== null);
+     const field2Values = features.map(f: any => f.attributes[field2]).filter(v: any => v !== null);
+ 
+     const field1Breaks = this.calculateQuartileBreaks(field1Values);
+     const field2Breaks = this.calculateQuartileBreaks(field2Values);
+ 
+     // Get field metadata
+     const field1Meta = this.getFieldMetadata(field1) as LayerField;
@@ lines 1145-1151 @@
-       return undefined;
-     }
- 
-     const metadata = layer.fields.find(f => f.name === field);
-     
-     console.log('Field metadata lookup:', {
-       layerId,
---
+       return undefined;
+     }
+ 
+     const metadata = layer.fields.find(f: any => f.name === field);
+     
+     console.log('Field metadata lookup:', {
+       layerId,
+       fieldName: field,
+       found: !!metadata,
+       metadata
@@ lines 1158-1164 @@
-   }
- 
-   private calculateQuartileBreaks(values: number[]): number[] {
-     const sorted = [...values].sort((a, b) => a - b);
-     const q1Index = Math.floor(sorted.length * 0.33);
-     const q2Index = Math.floor(sorted.length * 0.67);
-     return [sorted[q1Index], sorted[q2Index]];
---
+   }
+ 
+   private calculateQuartileBreaks(values: number[]): number[] {
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const q1Index = Math.floor(sorted.length * 0.33);
+     const q2Index = Math.floor(sorted.length * 0.67);
+     return [sorted[q1Index], sorted[q2Index]];
+   }
+ 
+   private getLayerById(layerId: string): Layer | undefined {
@@ lines 1191-1200 @@
- 
-     // Check for sufficient variation in each field
-     return numericFields
-       .filter(field => {
-         const values = features
-           .map(f => f.attributes[field.name])
-           .filter(v => v !== null && !isNaN(v));
-         
-         const uniqueValues = new Set(values);
-         const hasVariation = uniqueValues.size > 5;
---
+ 
+     // Check for sufficient variation in each field
+     return numericFields
+       .filter(field: any => {
+         const values = features
+           .map(f: any => f.attributes[field.name])
+           .filter(v: any => v !== null && !isNaN(v));
+         
+         const uniqueValues = new Set(values);
+         const hasVariation = uniqueValues.size > 5;
+ 
+         console.log(`Field variation check: ${field.name}`, {
+           uniqueValues: uniqueValues.size,
@@ lines 1210-1217 @@
-   }
- 
-   private analyzeMultivariateBreaks(features: ArcGISGraphic[], fields: LayerField[]): number[][] {
-     return fields.map(field => {
-       const values = features.map((f: __esri.Graphic) => f.attributes[field.name]).filter(v => v !== null);
-       return this.calculateQuartileBreaks(values);
-     });
-   }
---
+   }
+ 
+   private analyzeMultivariateBreaks(features: ArcGISGraphic[], fields: LayerField[]): number[][] {
+     return fields.map(field: any => {
+       const values = features.map((f: __esri.Graphic) => f.attributes[field.name]).filter(v: any => v !== null);
+       return this.calculateQuartileBreaks(values);
+     });
+   }
+ 
+   private findValueField(feature: any, layerConfig: LayerConfig): string {
+     console.log('=== Finding Value Field ===', {
@@ lines 1281-1287 @@
-     }
- 
-         // Look for numeric fields in layer configuration, excluding electoral fields
-         const configuredFields = layerConfig.fields.filter(field => 
-             ['double', 'integer', 'single', 'small-integer'].includes(field.type) &&
-             !['FEDNAME', 'PARTY_1', 'NAME_1', 'VOTES_1'].includes(field.name)
-         );
---
+     }
+ 
+         // Look for numeric fields in layer configuration, excluding electoral fields
+         const configuredFields = layerConfig.fields.filter(field: any => 
+             ['double', 'integer', 'single', 'small-integer'].includes(field.type) &&
+             !['FEDNAME', 'PARTY_1', 'NAME_1', 'VOTES_1'].includes(field.name)
+         );
+ 
+         if (configuredFields.length > 0) {
+             console.log('[DEBUG Field Detection] Using first configured numeric field:', configuredFields[0].name);
@@ lines 1292-1298 @@
-         }
- 
-     // If no suitable fields found in configuration, provide detailed error
-     const availableFields = layerConfig.fields.map(f => `${f.name} (${f.type})`).join(', ');
-     throw new Error(`No suitable numeric fields found in layer configuration for layer: ${layer.layer.id}. Available fields: ${availableFields}`);
-   }
-   
---
+         }
+ 
+     // If no suitable fields found in configuration, provide detailed error
+     const availableFields = layerConfig.fields.map(f: any => `${f.name} (${f.type})`).join(', ');
+     throw new Error(`No suitable numeric fields found in layer configuration for layer: ${layer.layer.id}. Available fields: ${availableFields}`);
+   }
+   
+   /**
+    * Finds the first available numeric field in attributes, excluding a specified field.
+    */
@@ lines 1408-1414 @@
-     // --- END LOGGING ---
- 
-     // --- CONVERT LocalGeospatialFeature to Graphic --- 
-     const graphicsForViz: ArcGISGraphic[] = allFeatures.map((feature, index) => {
-         let geometry: __esri.Geometry | null = null;
-         let attributes: { [key: string]: any } = {}; 
- 
---
+     // --- END LOGGING ---
+ 
+     // --- CONVERT LocalGeospatialFeature to Graphic --- 
+     const graphicsForViz: ArcGISGraphic[] = allFeatures.map((feature: any, index: any) => {
+         let geometry: __esri.Geometry | null = null;
+         let attributes: { [key: string]: any } = {}; 
+ 
+         try {
+             // --- Use _originalEsriGeometry from properties --- 
+             const originalGeometry = feature.properties?._originalEsriGeometry;
@@ lines 1452-1458 @@
-             console.error(`[Factory DEBUG] Error converting feature ${index} to Graphic:`, error);
-             return null;
-         }
-     }).filter((g): g is ArcGISGraphic => g !== null);
- 
-     if (graphicsForViz.length === 0) {
-         throw new Error('[Data Error] Failed to convert any features to Graphics for visualization.');
---
+             console.error(`[Factory DEBUG] Error converting feature ${index} to Graphic:`, error);
+             return null;
+         }
+     }).filter((g: any): g is ArcGISGraphic => g !== null);
+ 
+     if (graphicsForViz.length === 0) {
+         throw new Error('[Data Error] Failed to convert any features to Graphics for visualization.');
+     }
+     console.log(`[Factory DEBUG] Converted ${graphicsForViz.length} features to Graphics. Sample attributes:`, graphicsForViz[0]?.attributes);
+     // --- END CONVERSION --- 
@@ lines 1470-1477 @@
-         
-         // Transform graphics to match CorrelationData interface
-         const transformedFeatures = graphicsForViz
-             .filter(graphic => graphic.geometry != null) // Filter out features with no geometry
-             .map((graphic, index) => {
-                 const primaryValue = graphic.attributes[`${layer1Id}_thematic_value`];
-                 const comparisonValue = graphic.attributes[`${layer2Id}_thematic_value`];
-                 
---
+         
+         // Transform graphics to match CorrelationData interface
+         const transformedFeatures = graphicsForViz
+             .filter(graphic: any => graphic.geometry != null) // Filter out features with no geometry
+             .map((graphic: any, index: any) => {
+                 const primaryValue = graphic.attributes[`${layer1Id}_thematic_value`];
+                 const comparisonValue = graphic.attributes[`${layer2Id}_thematic_value`];
+                 
+                 // Get the geometry and ensure it's of a supported type
+                 const geometry = graphic.geometry!; // Safe to use ! because of filter above
+                 const geomType = geometry.type.toLowerCase() as ArcGISGeometryType;
@@ lines 1519-1525 @@
-                     geometry: typedGeometry
-                 };
-             })
-             .filter((feature): feature is NonNullable<typeof feature> => feature !== null);
-         
-         const { layer, extent: vizExtent } = await correlationViz.create({
-           features: transformedFeatures as unknown as { 
---
+                     geometry: typedGeometry
+                 };
+             })
+             .filter((feature: any): feature is NonNullable<typeof feature> => feature !== null);
+         
+         const { layer, extent: vizExtent } = await correlationViz.create({
+           features: transformedFeatures as unknown as { 
+             attributes: { [key: string]: any; OBJECTID: number; primary_value: number; comparison_value: number; correlation_strength: number; }; 
+             geometry?: GeometryType 
+           }[],
@@ lines 1582-1588 @@
-     }
-     
-     const configuredFields = layerConfig.fields;
-     const configuredFieldNames = new Set(configuredFields?.map(f => f.name) ?? []);
- 
-     // --- Determine Primary Field for Ranking ---
-     let primaryField: string | null = null;
---
+     }
+     
+     const configuredFields = layerConfig.fields;
+     const configuredFieldNames = new Set(configuredFields?.map(f: any => f.name) ?? []);
+ 
+     // --- Determine Primary Field for Ranking ---
+     let primaryField: string | null = null;
+     const primaryFieldOption = options.primaryField; // Check if field provided in options
+ 
+     // 1. Try field from options
@@ lines 1614-1620 @@
- 
-     // 3. Try first configured numeric field (if still no field determined)
-     if (!primaryField && configuredFields && configuredFields.length > 0) {
-         const firstNumericConfigured = configuredFields.find(field =>
-             // Check if the field type indicates it's numeric
-             ['double', 'integer', 'single', 'small-integer', 'oid'].includes(field.type) // Include 'oid' as potentially numeric
-         );
---
+ 
+     // 3. Try first configured numeric field (if still no field determined)
+     if (!primaryField && configuredFields && configuredFields.length > 0) {
+         const firstNumericConfigured = configuredFields.find(field: any =>
+             // Check if the field type indicates it's numeric
+             ['double', 'integer', 'single', 'small-integer', 'oid'].includes(field.type) // Include 'oid' as potentially numeric
+         );
+         if (firstNumericConfigured) {
+              primaryField = firstNumericConfigured.name;
+              console.log(`[TopN Viz] Using first configured numeric field: "${primaryField}"`);
@@ lines 1650-1656 @@
-     // --- End Primary Field Determination ---
- 
-     // Get features from the layer and normalize their structure
-     let validFeatures = layers[0].features.map((feature, index) => {
-         try {
-             // Skip features without geometry
-             if (!feature.geometry) {
---
+     // --- End Primary Field Determination ---
+ 
+     // Get features from the layer and normalize their structure
+     let validFeatures = layers[0].features.map((feature: any, index: any) => {
+         try {
+             // Skip features without geometry
+             if (!feature.geometry) {
+                 console.log('Skipping feature without geometry:', feature);
+                 return null;
+             }
@@ lines 1717-1723 @@
-             console.warn(`[TopN Viz] Error processing feature ${index}:`, error);
-             return null; // Skip features that cause processing errors
-         }
-     }).filter((f): f is ArcGISGraphic => f !== null); // Filter out nulls and ensure correct type
- 
-     if (validFeatures.length === 0) {
-         console.error("[TopN Viz] No valid features remained after processing. Cannot create TopN visualization.");
---
+             console.warn(`[TopN Viz] Error processing feature ${index}:`, error);
+             return null; // Skip features that cause processing errors
+         }
+     }).filter((f: any): f is ArcGISGraphic => f !== null); // Filter out nulls and ensure correct type
+ 
+     if (validFeatures.length === 0) {
+         console.error("[TopN Viz] No valid features remained after processing. Cannot create TopN visualization.");
+         // Depending on desired behavior, you might throw an error or return an empty result
+          throw new Error(`No valid features found for TopN analysis on layer "${layerConfig.name}" with field "${primaryField}".`);
+         // return { layer: null, extent: null }; // Alternative: return empty
@@ lines 1729-1735 @@
-     console.log('[TopN Viz] Valid features before sorting:', {
-         count: validFeatures.length,
-         field: primaryField,
-         sampleValues: validFeatures.slice(0, 5).map(f => ({
-             value: f.attributes[primaryField!],
-             description: f.attributes?.DESCRIPTION,
-             hasGeometry: !!f.geometry,
---
+     console.log('[TopN Viz] Valid features before sorting:', {
+         count: validFeatures.length,
+         field: primaryField,
+         sampleValues: validFeatures.slice(0, 5).map(f: any => ({
+             value: f.attributes[primaryField!],
+             description: f.attributes?.DESCRIPTION,
+             hasGeometry: !!f.geometry,
+         }))
+     });
+ 
@@ lines 1737-1743 @@
-     });
- 
-     // Sort features by value in descending order
-     validFeatures = validFeatures.sort((a, b) => {
-         // Use non-null assertion as we've filtered for valid numbers
-         const valueA = Number(a.attributes[primaryField!]);
-         const valueB = Number(b.attributes[primaryField!]);
---
+     });
+ 
+     // Sort features by value in descending order
+     validFeatures = validFeatures.sort((a: any, b: any) => {
+         // Use non-null assertion as we've filtered for valid numbers
+         const valueA = Number(a.attributes[primaryField!]);
+         const valueB = Number(b.attributes[primaryField!]);
+         return valueB - valueA; // Descending order
+     });
+ 
@@ lines 1750-1763 @@
-     console.log('[TopN Viz] Top N features after filtering and sorting:', {
-         count: topNFeatures.length,
-         field: primaryField,
-         sampleValues: topNFeatures.map(f => ({
-             value: f.attributes[primaryField!],
-             description: f.attributes?.DESCRIPTION,
-         }))
-     });
- 
-     // Add rank attribute
-     topNFeatures.forEach((feature, index) => {
-        feature.attributes['rank'] = index + 1;
-     });
- 
---
+     console.log('[TopN Viz] Top N features after filtering and sorting:', {
+         count: topNFeatures.length,
+         field: primaryField,
+         sampleValues: topNFeatures.map(f: any => ({
+             value: f.attributes[primaryField!],
+             description: f.attributes?.DESCRIPTION,
+         }))
+     });
+ 
+     // Add rank attribute
+     topNFeatures.forEach((feature: any, index: any) => {
+        feature.attributes['rank'] = index + 1;
+     });
+ 
+     // Create visualization data
+     const visualizationData: TopNData = {
+         features: topNFeatures,
@@ lines 1795-1801 @@
-   ): Promise<VisualizationResult> { // Use VisualizationResult type
-     // <<< ADD LOGGING: Entry point and inputs >>>
-     console.log('[DYN_FACTORY][createSingleLayer] Entry point');
-     console.log('[DYN_FACTORY][createSingleLayer] Input LayerResults:', layers.map(l => ({ layerId: l.layerId, features: l.features?.length })));
-     console.log('[DYN_FACTORY][createSingleLayer] Input Options:', options);
- 
-     // --- 1. Validate Input --- 
---
+   ): Promise<VisualizationResult> { // Use VisualizationResult type
+     // <<< ADD LOGGING: Entry point and inputs >>>
+     console.log('[DYN_FACTORY][createSingleLayer] Entry point');
+     console.log('[DYN_FACTORY][createSingleLayer] Input LayerResults:', layers.map(l: any => ({ layerId: l.layerId, features: l.features?.length })));
+     console.log('[DYN_FACTORY][createSingleLayer] Input Options:', options);
+ 
+     // --- 1. Validate Input --- 
+     if (!layers || layers.length === 0 || !layers[0].features || layers[0].features.length === 0) {
+       console.error('[DYN_FACTORY][createSingleLayer] Validation failed: No layers or features provided.');
+       return { layer: null, extent: null }; // Return empty result if no features
@@ lines 1921-1927 @@
-     // const layer = layers[0]; // Already defined above
- 
-     // Convert features to the expected format
-     const features = layer.features.map(feature => ({
-       geometry: feature.geometry,
-       properties: feature.properties,
-       attributes: feature.properties
---
+     // const layer = layers[0]; // Already defined above
+ 
+     // Convert features to the expected format
+     const features = layer.features.map(feature: any => ({
+       geometry: feature.geometry,
+       properties: feature.properties,
+       attributes: feature.properties
+     }));
+ 
+     // Create visualization data
@@ lines 2004-2014 @@
-     }
- 
-     const n = x.length;
-     const sumX = x.reduce((a, b) => a + b, 0);
-     const sumY = y.reduce((a, b) => a + b, 0);
-     const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
-     const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
-     const sumY2 = y.reduce((sum, val) => sum + val * val, 0);
- 
-     const numerator = n * sumXY - sumX * sumY;
-     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
---
+     }
+ 
+     const n = x.length;
+     const sumX = x.reduce((a: any, b: any) => a + b, 0);
+     const sumY = y.reduce((a: any, b: any) => a + b, 0);
+     const sumXY = x.reduce((sum: any, val: any, i: any) => sum + val * y[i], 0);
+     const sumX2 = x.reduce((sum: any, val: any) => sum + val * val, 0);
+     const sumY2 = y.reduce((sum: any, val: any) => sum + val * val, 0);
+ 
+     const numerator = n * sumXY - sumX * sumY;
+     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
+ 
+     return denominator === 0 ? 0 : numerator / denominator;
+   }
@@ lines 2048-2054 @@
-     
-     // If no direct matches found, look for fields containing the party name
-     const availableFields = Object.keys(feature.attributes);
-     const partyFields = availableFields.filter(field => 
-       field.toLowerCase().includes(partyName.toLowerCase()) &&
-       typeof feature.attributes[field] === 'number'
-     );
---
+     
+     // If no direct matches found, look for fields containing the party name
+     const availableFields = Object.keys(feature.attributes);
+     const partyFields = availableFields.filter(field: any => 
+       field.toLowerCase().includes(partyName.toLowerCase()) &&
+       typeof feature.attributes[field] === 'number'
+     );
+     
+     if (partyFields.length > 0) {
+       console.log(`[DynamicVisualizationFactory] Found field containing party name: ${partyFields[0]}`);
@@ lines 2065-2071 @@
-     }
-     
-     // If no suitable field found, provide detailed error message
-     const fieldList = availableFields.map(field => 
-       `${field} (${typeof feature.attributes[field]})`
-     ).join(', ');
- 
---
+     }
+     
+     // If no suitable field found, provide detailed error message
+     const fieldList = availableFields.map(field: any => 
+       `${field} (${typeof feature.attributes[field]})`
+     ).join(', ');
+ 
+     throw new Error(
+       `Could not find a suitable field for party "${partyName}". ` +
+       `Tried the following patterns: ${directMatches.join(', ')}. ` +
@@ lines 2170-2176 @@
-     'against'
-   ];
-   
-   return correlationKeywords.some(keyword => 
-     query.toLowerCase().includes(keyword)
-   );
- };
---
+     'against'
+   ];
+   
+   return correlationKeywords.some(keyword: any => 
+     query.toLowerCase().includes(keyword)
+   );
+ };
+ 
+ const is3DVisualizationQuery = (query: string): boolean => {
+   const threeDKeywords = [
@@ lines 2186-2192 @@
-     'skyline'
-   ];
-   
-   return threeDKeywords.some(keyword => 
-     query.toLowerCase().includes(keyword)
-   );
- };
---
+     'skyline'
+   ];
+   
+   return threeDKeywords.some(keyword: any => 
+     query.toLowerCase().includes(keyword)
+   );
+ };
+ 
+ // --- ADD LOCAL validateExtent HELPER --- 
+ const validateExtent = (extent: Extent | null | undefined): extent is Extent => {
@@ lines 2197-2207 @@
-     const requiredProps: (keyof Extent)[] = [
-         'xmin', 'ymin', 'xmax', 'ymax', 'spatialReference'
-     ];
-     const hasRequiredProps = requiredProps.every(prop => Object.prototype.hasOwnProperty.call(extent, prop)); // Fixed no-prototype-builtins
-     if (!hasRequiredProps) return false;
- 
-     const numericProps: (keyof Extent)[] = ['xmin', 'ymin', 'xmax', 'ymax'];
-     const areNumeric = numericProps.every(prop => typeof extent[prop] === 'number' && isFinite(extent[prop] as number));
-     if (!areNumeric) return false;
- 
-     if (extent.xmin >= extent.xmax || extent.ymin >= extent.ymax) return false;
---
+     const requiredProps: (keyof Extent)[] = [
+         'xmin', 'ymin', 'xmax', 'ymax', 'spatialReference'
+     ];
+     const hasRequiredProps = requiredProps.every(prop: any => Object.prototype.hasOwnProperty.call(extent, prop)); // Fixed no-prototype-builtins
+     if (!hasRequiredProps) return false;
+ 
+     const numericProps: (keyof Extent)[] = ['xmin', 'ymin', 'xmax', 'ymax'];
+     const areNumeric = numericProps.every(prop: any => typeof extent[prop] === 'number' && isFinite(extent[prop] as number));
+     if (!areNumeric) return false;
+ 
+     if (extent.xmin >= extent.xmax || extent.ymin >= extent.ymax) return false;
+ 
+     return extent.spatialReference != null;
+ };


*** FILE: lib/data-exploration-handler.ts
@@ lines 54-60 @@
-     this.dataPoints.clear();
-     
-     // Update internal data store
-     points.forEach(point => this.dataPoints.set(point.id, point));
-     
-     // Generate new summary
-     this.generateSummary();
---
+     this.dataPoints.clear();
+     
+     // Update internal data store
+     points.forEach(point: any => this.dataPoints.set(point.id, point));
+     
+     // Generate new summary
+     this.generateSummary();
+     
+     // Update chat state with new context
+     chatStateManager.updateDataContext(sessionId, {
@@ lines 98-104 @@
-     const suggestions: string[] = [];
-     
-     // Suggest filters based on patterns
-     this.patterns.forEach(pattern => {
-       switch (pattern.type) {
-         case 'cluster':
-           suggestions.push(`Filter to show ${pattern.description}`);
---
+     const suggestions: string[] = [];
+     
+     // Suggest filters based on patterns
+     this.patterns.forEach(pattern: any => {
+       switch (pattern.type) {
+         case 'cluster':
+           suggestions.push(`Filter to show ${pattern.description}`);
+           break;
+         case 'trend':
+           suggestions.push(`Focus on ${pattern.description}`);
@@ lines 174-180 @@
-    */
-   private detectClusters(points: DataPoint[]): DataPattern[] {
-     const patterns: DataPattern[] = [];
-     const pointsWithCoords = points.filter(p => p.coordinates);
-     
-     if (pointsWithCoords.length < 3) return patterns;
-     
---
+    */
+   private detectClusters(points: DataPoint[]): DataPattern[] {
+     const patterns: DataPattern[] = [];
+     const pointsWithCoords = points.filter(p: any => p.coordinates);
+     
+     if (pointsWithCoords.length < 3) return patterns;
+     
+     // Increased distance threshold for clustering
+     const CLUSTER_DISTANCE_THRESHOLD = 0.05; // Increased from 0.01
+     
@@ lines 207-213 @@
-     }
-     
-     // Convert clusters to patterns
-     clusters.forEach(cluster => {
-       const center = this.calculateClusterCenter(cluster);
-       const description = `centered at (${center[0].toFixed(4)}, ${center[1].toFixed(4)})`;
-       
---
+     }
+     
+     // Convert clusters to patterns
+     clusters.forEach(cluster: any => {
+       const center = this.calculateClusterCenter(cluster);
+       const description = `centered at (${center[0].toFixed(4)}, ${center[1].toFixed(4)})`;
+       
+       patterns.push({
+         type: 'cluster',
+         description,
@@ lines 215-221 @@
-         type: 'cluster',
-         description,
-         confidence: Math.min(0.7 + (cluster.length * 0.05), 0.95),
-         dataPoints: cluster.map(p => p.id),
-         metrics: {
-           size: cluster.length,
-           density: cluster.length / this.calculateClusterArea(cluster)
---
+         type: 'cluster',
+         description,
+         confidence: Math.min(0.7 + (cluster.length * 0.05), 0.95),
+         dataPoints: cluster.map(p: any => p.id),
+         metrics: {
+           size: cluster.length,
+           density: cluster.length / this.calculateClusterArea(cluster)
+         }
+       });
+     });
@@ lines 235-243 @@
-   }
- 
-   private calculateClusterCenter(cluster: DataPoint[]): [number, number] {
-     const coords = cluster.map(p => p.coordinates!);
-     const sumLat = coords.reduce((sum, [lat]) => sum + lat, 0);
-     const sumLon = coords.reduce((sum, [, lon]) => sum + lon, 0);
-     
-     return [
-       sumLat / coords.length,
---
+   }
+ 
+   private calculateClusterCenter(cluster: DataPoint[]): [number, number] {
+     const coords = cluster.map(p: any => p.coordinates!);
+     const sumLat = coords.reduce((sum: any, [lat]) => sum + lat, 0);
+     const sumLon = coords.reduce((sum: any, [, lon]) => sum + lon, 0);
+     
+     return [
+       sumLat / coords.length,
+       sumLon / coords.length
+     ];
+   }
@@ lines 246-252 @@
-   }
- 
-   private calculateClusterArea(cluster: DataPoint[]): number {
-     const coords = cluster.map(p => p.coordinates!);
-     const lats = coords.map(([lat]) => lat);
-     const lons = coords.map(([, lon]) => lon);
-     
---
+   }
+ 
+   private calculateClusterArea(cluster: DataPoint[]): number {
+     const coords = cluster.map(p: any => p.coordinates!);
+     const lats = coords.map(([lat]) => lat);
+     const lons = coords.map(([, lon]) => lon);
+     
+     const width = Math.max(...lons) - Math.min(...lons);
+     const height = Math.max(...lats) - Math.min(...lats);
+     
@@ lines 271-287 @@
-    */
-   private detectTrends(points: DataPoint[]): DataPattern[] {
-     const patterns: DataPattern[] = [];
-     const pointsWithTime = points.filter(p => p.timestamp);
-     if (pointsWithTime.length < 3) return patterns;
-     
-     // Sort points by timestamp
-     const sortedPoints = [...pointsWithTime].sort((a, b) => 
-         a.timestamp!.getTime() - b.timestamp!.getTime()
-     );
-     
-     // Group points by attribute
-     const attributeGroups = new Map<string, DataPoint[]>();
-     sortedPoints.forEach(point => {
-         Object.entries(point.attributes).forEach(([key, value]) => {
-             if (typeof value === 'number') {
-                 if (!attributeGroups.has(key)) {
---
+    */
+   private detectTrends(points: DataPoint[]): DataPattern[] {
+     const patterns: DataPattern[] = [];
+     const pointsWithTime = points.filter(p: any => p.timestamp);
+     if (pointsWithTime.length < 3) return patterns;
+     
+     // Sort points by timestamp
+     const sortedPoints = [...pointsWithTime].sort((a: any, b: any) => 
+         a.timestamp!.getTime() - b.timestamp!.getTime()
+     );
+     
+     // Group points by attribute
+     const attributeGroups = new Map<string, DataPoint[]>();
+     sortedPoints.forEach(point: any => {
+         Object.entries(point.attributes).forEach(([key, value]) => {
+             if (typeof value === 'number') {
+                 if (!attributeGroups.has(key)) {
+                     attributeGroups.set(key, []);
+                 }
+                 attributeGroups.get(key)!.push(point);
@@ lines 293-301 @@
-     });
-     
-     // Analyze trends with relaxed thresholds
-     attributeGroups.forEach((groupPoints, attribute) => {
-         const values = groupPoints.map(p => p.attributes[attribute] as number);
-         const timestamps = groupPoints.map(p => p.timestamp!.getTime());
-         const { slope, rSquared } = this.calculateLinearRegression(timestamps, values);
-         
-         // Relaxed thresholds for trend detection
---
+     });
+     
+     // Analyze trends with relaxed thresholds
+     attributeGroups.forEach((groupPoints: any, attribute: any) => {
+         const values = groupPoints.map(p: any => p.attributes[attribute] as number);
+         const timestamps = groupPoints.map(p: any => p.timestamp!.getTime());
+         const { slope, rSquared } = this.calculateLinearRegression(timestamps, values);
+         
+         // Relaxed thresholds for trend detection
+         if (Math.abs(slope) > 0.000001 && rSquared > 0.05) {
+             const trend = slope > 0 ? 'increasing' : 'decreasing';
+             const startValue = values[0];
@@ lines 309-315 @@
-                 type: 'trend',
-                 description: `${attribute} shows a ${trend} trend (${change.toFixed(1)}% change)`,
-                 confidence: Math.min(0.7 + (rSquared * 0.3), 0.95),
-                 dataPoints: groupPoints.map(p => p.id),
-                 metrics: {
-                     slope,
-                     rSquared,
---
+                 type: 'trend',
+                 description: `${attribute} shows a ${trend} trend (${change.toFixed(1)}% change)`,
+                 confidence: Math.min(0.7 + (rSquared * 0.3), 0.95),
+                 dataPoints: groupPoints.map(p: any => p.id),
+                 metrics: {
+                     slope,
+                     rSquared,
+                     changePercent: change
+                 }
+             });
@@ lines 324-341 @@
- 
-   private calculateLinearRegression(x: number[], y: number[]): { slope: number; rSquared: number } {
-     const n = x.length;
-     const sumX = x.reduce((a, b) => a + b, 0);
-     const sumY = y.reduce((a, b) => a + b, 0);
-     const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
-     const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
-     
-     const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
-     const intercept = (sumY - slope * sumX) / n;
-     
-     // Calculate R-squared
-     const yMean = sumY / n;
-     const ssTotal = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
-     const ssResidual = y.reduce((sum, yi, i) => {
-       const predicted = slope * x[i] + intercept;
-       return sum + Math.pow(yi - predicted, 2);
-     }, 0);
---
+ 
+   private calculateLinearRegression(x: number[], y: number[]): { slope: number; rSquared: number } {
+     const n = x.length;
+     const sumX = x.reduce((a: any, b: any) => a + b, 0);
+     const sumY = y.reduce((a: any, b: any) => a + b, 0);
+     const sumXY = x.reduce((sum: any, xi: any, i: any) => sum + xi * y[i], 0);
+     const sumXX = x.reduce((sum: any, xi: any) => sum + xi * xi, 0);
+     
+     const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
+     const intercept = (sumY - slope * sumX) / n;
+     
+     // Calculate R-squared
+     const yMean = sumY / n;
+     const ssTotal = y.reduce((sum: any, yi: any) => sum + Math.pow(yi - yMean, 2), 0);
+     const ssResidual = y.reduce((sum: any, yi: any, i: any) => {
+       const predicted = slope * x[i] + intercept;
+       return sum + Math.pow(yi - predicted, 2);
+     }, 0);
+     
+     const rSquared = 1 - (ssResidual / ssTotal);
+     
@@ lines 350-356 @@
-     
-     // Group points by attribute
-     const attributeGroups = new Map<string, DataPoint[]>();
-     points.forEach(point => {
-       Object.entries(point.attributes).forEach(([key, value]) => {
-         if (typeof value === 'number') {
-           if (!attributeGroups.has(key)) {
---
+     
+     // Group points by attribute
+     const attributeGroups = new Map<string, DataPoint[]>();
+     points.forEach(point: any => {
+       Object.entries(point.attributes).forEach(([key, value]) => {
+         if (typeof value === 'number') {
+           if (!attributeGroups.has(key)) {
+             attributeGroups.set(key, []);
+           }
+           attributeGroups.get(key)!.push(point);
@@ lines 362-381 @@
-     });
- 
-     // Detect outliers for each numeric attribute
-     attributeGroups.forEach((groupPoints, attribute) => {
-       const values = groupPoints.map(p => p.attributes[attribute] as number);
-       const { mean, stdDev } = this.calculateMeanAndStdDev(values);
-       
-       // Points more than 1.5 standard deviations from the mean are considered outliers
-       const threshold = 1.5; // Lowered threshold for outlier detection
-       const outliers = groupPoints.filter(point => {
-         const value = point.attributes[attribute] as number;
-         const zScore = Math.abs((value - mean) / stdDev);
-         return zScore > threshold;
-       });
-       
-       if (outliers.length > 0) {
-         const outlierValues = outliers.map(p => p.attributes[attribute] as number);
-         const minOutlier = Math.min(...outlierValues);
-         const maxOutlier = Math.max(...outlierValues);
-         
---
+     });
+ 
+     // Detect outliers for each numeric attribute
+     attributeGroups.forEach((groupPoints: any, attribute: any) => {
+       const values = groupPoints.map(p: any => p.attributes[attribute] as number);
+       const { mean, stdDev } = this.calculateMeanAndStdDev(values);
+       
+       // Points more than 1.5 standard deviations from the mean are considered outliers
+       const threshold = 1.5; // Lowered threshold for outlier detection
+       const outliers = groupPoints.filter(point: any => {
+         const value = point.attributes[attribute] as number;
+         const zScore = Math.abs((value - mean) / stdDev);
+         return zScore > threshold;
+       });
+       
+       if (outliers.length > 0) {
+         const outlierValues = outliers.map(p: any => p.attributes[attribute] as number);
+         const minOutlier = Math.min(...outlierValues);
+         const maxOutlier = Math.max(...outlierValues);
+         
+         patterns.push({
+           type: 'outlier',
+           description: `${outliers.length} outliers in ${attribute} (range: ${minOutlier.toFixed(1)} to ${maxOutlier.toFixed(1)})`,
@@ lines 383-389 @@
-           type: 'outlier',
-           description: `${outliers.length} outliers in ${attribute} (range: ${minOutlier.toFixed(1)} to ${maxOutlier.toFixed(1)})`,
-           confidence: Math.min(0.7 + (outliers.length * 0.05), 0.95),
-           dataPoints: outliers.map(p => p.id),
-           metrics: {
-             mean,
-             stdDev,
---
+           type: 'outlier',
+           description: `${outliers.length} outliers in ${attribute} (range: ${minOutlier.toFixed(1)} to ${maxOutlier.toFixed(1)})`,
+           confidence: Math.min(0.7 + (outliers.length * 0.05), 0.95),
+           dataPoints: outliers.map(p: any => p.id),
+           metrics: {
+             mean,
+             stdDev,
+             minOutlier,
+             maxOutlier,
+             outlierCount: outliers.length
@@ lines 400-407 @@
- 
-   private calculateMeanAndStdDev(values: number[]): { mean: number; stdDev: number } {
-     const n = values.length;
-     const mean = values.reduce((a, b) => a + b, 0) / n;
-     const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
-     const stdDev = Math.sqrt(variance);
-     
-     return { mean, stdDev };
---
+ 
+   private calculateMeanAndStdDev(values: number[]): { mean: number; stdDev: number } {
+     const n = values.length;
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / n;
+     const variance = values.reduce((sum: any, val: any) => sum + Math.pow(val - mean, 2), 0) / n;
+     const stdDev = Math.sqrt(variance);
+     
+     return { mean, stdDev };
+   }
+ 
+   private generateInsightsMessage(patterns: DataPattern[]): string {
@@ lines 412-418 @@
-       return "I don't see any significant patterns in the data yet.";
-     }
- 
-     const insights = patterns.map(pattern => {
-       switch (pattern.type) {
-         case 'cluster':
-           return `I found a cluster of ${pattern.dataPoints.length} points ${pattern.description}`;
---
+       return "I don't see any significant patterns in the data yet.";
+     }
+ 
+     const insights = patterns.map(pattern: any => {
+       switch (pattern.type) {
+         case 'cluster':
+           return `I found a cluster of ${pattern.dataPoints.length} points ${pattern.description}`;
+         case 'trend':
+           return `There's a trend showing ${pattern.description}`;
+         case 'outlier':
@@ lines 434-445 @@
-     const points = Array.from(this.dataPoints.values());
-     
-     // If we have temporal data, suggest trends
-     if (points.some(p => p.timestamp)) {
-       return VisualizationType.TRENDS;
-     }
-     
-     // If we have spatial data, suggest scatter
-     if (points.some(p => p.coordinates)) {
-       return VisualizationType.SCATTER;
-     }
-     
---
+     const points = Array.from(this.dataPoints.values());
+     
+     // If we have temporal data, suggest trends
+     if (points.some(p: any => p.timestamp)) {
+       return VisualizationType.TRENDS;
+     }
+     
+     // If we have spatial data, suggest scatter
+     if (points.some(p: any => p.coordinates)) {
+       return VisualizationType.SCATTER;
+     }
+     
+     // Default to scatter
+     return VisualizationType.SCATTER;
+   }
@@ lines 456-462 @@
- 
-   private extractCategories(points: DataPoint[]): string[] {
-     const categories = new Set<string>();
-     points.forEach(point => {
-       Object.entries(point.attributes).forEach(([key, value]) => {
-         if (typeof value === 'string') {
-           categories.add(value);
---
+ 
+   private extractCategories(points: DataPoint[]): string[] {
+     const categories = new Set<string>();
+     points.forEach(point: any => {
+       Object.entries(point.attributes).forEach(([key, value]) => {
+         if (typeof value === 'string') {
+           categories.add(value);
+         }
+       });
+     });
@@ lines 468-493 @@
- 
-   private calculateTimeRange(points: DataPoint[]): [Date, Date] | undefined {
-     const timestamps = points
-       .map(p => p.timestamp)
-       .filter((t): t is Date => t !== undefined);
-     
-     if (timestamps.length === 0) return undefined;
-     
-     return [
-       new Date(Math.min(...timestamps.map(t => t.getTime()))),
-       new Date(Math.max(...timestamps.map(t => t.getTime())))
-     ];
-   }
- 
-   private calculateSpatialBounds(points: DataPoint[]): [number, number, number, number] | undefined {
-     const coordinates = points
-       .map(p => p.coordinates)
-       .filter((c): c is [number, number] => c !== undefined);
-     
-     if (coordinates.length === 0) return undefined;
-     
-     const lats = coordinates.map(c => c[0]);
-     const lons = coordinates.map(c => c[1]);
-     
-     return [
-       Math.min(...lats),
---
+ 
+   private calculateTimeRange(points: DataPoint[]): [Date, Date] | undefined {
+     const timestamps = points
+       .map(p: any => p.timestamp)
+       .filter((t: any): t is Date => t !== undefined);
+     
+     if (timestamps.length === 0) return undefined;
+     
+     return [
+       new Date(Math.min(...timestamps.map(t: any => t.getTime()))),
+       new Date(Math.max(...timestamps.map(t: any => t.getTime())))
+     ];
+   }
+ 
+   private calculateSpatialBounds(points: DataPoint[]): [number, number, number, number] | undefined {
+     const coordinates = points
+       .map(p: any => p.coordinates)
+       .filter((c: any): c is [number, number] => c !== undefined);
+     
+     if (coordinates.length === 0) return undefined;
+     
+     const lats = coordinates.map(c: any => c[0]);
+     const lons = coordinates.map(c: any => c[1]);
+     
+     return [
+       Math.min(...lats),
+       Math.min(...lons),
+       Math.max(...lats),
+       Math.max(...lons)
@@ lines 502-508 @@
-     
-     // Get all numeric attributes
-     const numericAttributes = new Set<string>();
-     points.forEach(point => {
-       Object.entries(point.attributes).forEach(([key, value]) => {
-         if (typeof value === 'number') {
-           numericAttributes.add(key);
---
+     
+     // Get all numeric attributes
+     const numericAttributes = new Set<string>();
+     points.forEach(point: any => {
+       Object.entries(point.attributes).forEach(([key, value]) => {
+         if (typeof value === 'number') {
+           numericAttributes.add(key);
+         }
+       });
+     });
@@ lines 511-529 @@
-     });
-     
-     // Calculate statistics for each numeric attribute
-     numericAttributes.forEach(attr => {
-       const values = points
-         .map(p => p.attributes[attr])
-         .filter((v): v is number => typeof v === 'number');
-       
-       if (values.length > 0) {
-         const sorted = [...values].sort((a, b) => a - b);
-         const q1 = this.calculateQuantile(sorted, 0.25);
-         const q3 = this.calculateQuantile(sorted, 0.75);
-         const iqr = q3 - q1;
-         
-         stats[attr] = {
-           mean: values.reduce((a, b) => a + b, 0) / values.length,
-           median: this.calculateMedian(values),
-           min: Math.min(...values),
-           max: Math.max(...values),
---
+     });
+     
+     // Calculate statistics for each numeric attribute
+     numericAttributes.forEach(attr: any => {
+       const values = points
+         .map(p: any => p.attributes[attr])
+         .filter((v: any): v is number => typeof v === 'number');
+       
+       if (values.length > 0) {
+         const sorted = [...values].sort((a: any, b: any) => a - b);
+         const q1 = this.calculateQuantile(sorted, 0.25);
+         const q3 = this.calculateQuantile(sorted, 0.75);
+         const iqr = q3 - q1;
+         
+         stats[attr] = {
+           mean: values.reduce((a: any, b: any) => a + b, 0) / values.length,
+           median: this.calculateMedian(values),
+           min: Math.min(...values),
+           max: Math.max(...values),
+           stdDev: this.calculateStdDev(values),
+           q1,
+           q3,
@@ lines 583-590 @@
-     if (values.length <= 1) {
-       return 0; // Standard deviation is 0 for a single point or empty array
-     }
-     const mean = values.reduce((a, b) => a + b, 0) / values.length;
-     const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1); // Use n-1 for sample standard deviation
-     return Math.sqrt(variance);
-   }
- 
---
+     if (values.length <= 1) {
+       return 0; // Standard deviation is 0 for a single point or empty array
+     }
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+     const variance = values.reduce((sum: any, val: any) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1); // Use n-1 for sample standard deviation
+     return Math.sqrt(variance);
+   }
+ 
+   /**
+    * Calculates the skewness of a dataset using the Fisher-Pearson coefficient.
+    * Positive skewness indicates a distribution with a longer right tail,
@@ lines 603-617 @@
-   private calculateSkewness(values: number[]): number {
-     if (values.length < 3) return 0;
-     
-     const mean = values.reduce((a, b) => a + b, 0) / values.length;
-     const stdDev = this.calculateStdDev(values);
-     const n = values.length;
-     
-     // Calculate cubed deviations
-     const cubedDeviations = values.map(x => Math.pow((x - mean) / stdDev, 3));
-     
-     // Calculate skewness using Fisher-Pearson coefficient
-     const skewness = (cubedDeviations.reduce((a, b) => a + b, 0) / n) * 
-                     Math.sqrt(n * (n - 1)) / (n - 2);
-     
-     return skewness; // Keep original sign
---
+   private calculateSkewness(values: number[]): number {
+     if (values.length < 3) return 0;
+     
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+     const stdDev = this.calculateStdDev(values);
+     const n = values.length;
+     
+     // Calculate cubed deviations
+     const cubedDeviations = values.map(x: any => Math.pow((x - mean) / stdDev, 3));
+     
+     // Calculate skewness using Fisher-Pearson coefficient
+     const skewness = (cubedDeviations.reduce((a: any, b: any) => a + b, 0) / n) * 
+                     Math.sqrt(n * (n - 1)) / (n - 2);
+     
+     return skewness; // Keep original sign
+   }
+ 
+   private calculateKurtosis(values: number[]): number {
@@ lines 620-630 @@
-   private calculateKurtosis(values: number[]): number {
-     if (values.length < 4) return 0;
-     
-     const mean = values.reduce((a, b) => a + b, 0) / values.length;
-     const stdDev = this.calculateStdDev(values);
-     const n = values.length;
-     
-     const fourthMoment = values.reduce((sum, x) => sum + Math.pow((x - mean) / stdDev, 4), 0) / n;
-     return fourthMoment - 3; // Excess kurtosis
-   }
- 
---
+   private calculateKurtosis(values: number[]): number {
+     if (values.length < 4) return 0;
+     
+     const mean = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+     const stdDev = this.calculateStdDev(values);
+     const n = values.length;
+     
+     const fourthMoment = values.reduce((sum: any, x: any) => sum + Math.pow((x - mean) / stdDev, 4), 0) / n;
+     return fourthMoment - 3; // Excess kurtosis
+   }
+ 
+   private calculateDistribution(values: number[]): Record<string, number> {
+     const min = Math.min(...values);
+     const max = Math.max(...values);
@@ lines 640-646 @@
-       const binStart = min + i * binSize;
-       const binEnd = i === binCount - 1 ? max + 0.0001 : binStart + binSize; // Include the last value
-       const binLabel = `${binStart.toFixed(1)}-${binEnd.toFixed(1)}`;
-       distribution[binLabel] = values.filter(v => v >= binStart && v < binEnd).length;
-     }
-     
-     return distribution;
---
+       const binStart = min + i * binSize;
+       const binEnd = i === binCount - 1 ? max + 0.0001 : binStart + binSize; // Include the last value
+       const binLabel = `${binStart.toFixed(1)}-${binEnd.toFixed(1)}`;
+       distribution[binLabel] = values.filter(v: any => v >= binStart && v < binEnd).length;
+     }
+     
+     return distribution;
+   }
+ 
+   /**
@@ lines 668-675 @@
-         correlations[attr1] = {};
-         for (let j = i + 1; j < attributes.length; j++) {
-             const attr2 = attributes[j];
-             const values1 = points.map(p => p.attributes[attr1] as number);
-             const values2 = points.map(p => p.attributes[attr2] as number);
-             const correlation = this.calculatePearsonCorrelation(values1, values2);
-             if (Math.abs(correlation) > CORRELATION_THRESHOLD && Math.abs(correlation) < 0.9999) {
-                 correlations[attr1][attr2] = correlation;
---
+         correlations[attr1] = {};
+         for (let j = i + 1; j < attributes.length; j++) {
+             const attr2 = attributes[j];
+             const values1 = points.map(p: any => p.attributes[attr1] as number);
+             const values2 = points.map(p: any => p.attributes[attr2] as number);
+             const correlation = this.calculatePearsonCorrelation(values1, values2);
+             if (Math.abs(correlation) > CORRELATION_THRESHOLD && Math.abs(correlation) < 0.9999) {
+                 correlations[attr1][attr2] = correlation;
+             }
+         }
+         if (Object.keys(correlations[attr1]).length === 0) {
@@ lines 684-694 @@
- 
-   private calculatePearsonCorrelation(x: number[], y: number[]): number {
-     const n = x.length;
-     const sumX = x.reduce((a, b) => a + b, 0);
-     const sumY = y.reduce((a, b) => a + b, 0);
-     const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
-     const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
-     const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
-     
-     const numerator = n * sumXY - sumX * sumY;
-     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
---
+ 
+   private calculatePearsonCorrelation(x: number[], y: number[]): number {
+     const n = x.length;
+     const sumX = x.reduce((a: any, b: any) => a + b, 0);
+     const sumY = y.reduce((a: any, b: any) => a + b, 0);
+     const sumXY = x.reduce((sum: any, xi: any, i: any) => sum + xi * y[i], 0);
+     const sumX2 = x.reduce((sum: any, xi: any) => sum + xi * xi, 0);
+     const sumY2 = y.reduce((sum: any, yi: any) => sum + yi * yi, 0);
+     
+     const numerator = n * sumXY - sumX * sumY;
+     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
+     
+     return denominator === 0 ? 0 : numerator / denominator;
+   }
@@ lines 697-703 @@
-   }
- 
-   private calculateMedian(values: number[]): number {
-     const sorted = [...values].sort((a, b) => a - b);
-     const middle = Math.floor(sorted.length / 2);
-     
-     if (sorted.length % 2 === 0) {
---
+   }
+ 
+   private calculateMedian(values: number[]): number {
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const middle = Math.floor(sorted.length / 2);
+     
+     if (sorted.length % 2 === 0) {
+       return (sorted[middle - 1] + sorted[middle]) / 2;
+     }
+     


*** FILE: lib/analysis/strategies/processors/CompetitiveDataProcessor.ts
@@ lines 128-134 @@
-   // ============================================================================
- 
-   private processCompetitiveRecords(rawRecords: unknown[], primaryField: string): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       const rec = record as Record<string, unknown>;
-       const area_id = (rec as any).ID || (rec as any).area_id || (rec as any).id || (rec as any).GEOID || `area_${index}`;
-       const area_name = resolveAreaName(rec, { mode: 'zipCity', neutralFallback: `Area ${area_id || index + 1}` });
---
+   // ============================================================================
+ 
+   private processCompetitiveRecords(rawRecords: unknown[], primaryField: string): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       const rec = record as Record<string, unknown>;
+       const area_id = (rec as any).ID || (rec as any).area_id || (rec as any).id || (rec as any).GEOID || `area_${index}`;
+       const area_name = resolveAreaName(rec, { mode: 'zipCity', neutralFallback: `Area ${area_id || index + 1}` });
+ 
+       // Extract competitive metrics
+       const competitiveScore = this.extractCompetitiveScore(rec, primaryField);
@@ lines 190-197 @@
-       outRec.competitive_analysis_score = competitiveScore;
- 
-       return outRec;
-     }).sort((a, b) => b.value - a.value) // Sort by competitive score
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
-   private extractCompetitiveScore(record: any, primaryField: string): number {
---
+       outRec.competitive_analysis_score = competitiveScore;
+ 
+       return outRec;
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by competitive score
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+   private extractCompetitiveScore(record: any, primaryField: string): number {
+   // Priority: use provided primary field first
+   const score = Number((record as any)[primaryField] || (record as any).competitive_score || (record as any).competitive_analysis_score || (record as any).competitive_advantage_score);
+     
@@ lines 270-276 @@
-   private extractMarketShare(record: any): number {
-     // Use dynamic brand detection to get target brand share
-   const brandFields = (typeof this.brandResolver?.detectBrandFields === 'function') ? this.brandResolver.detectBrandFields(record) : [];
-     const targetBrand = brandFields.find(bf => bf.isTarget);
-     // Coerce to number and normalize
-     const targetBrandValue = Number((targetBrand && targetBrand.value) ?? 0);
-     if (targetBrandValue > 0) {
---
+   private extractMarketShare(record: any): number {
+     // Use dynamic brand detection to get target brand share
+   const brandFields = (typeof this.brandResolver?.detectBrandFields === 'function') ? this.brandResolver.detectBrandFields(record) : [];
+     const targetBrand = brandFields.find(bf: any => bf.isTarget);
+     // Coerce to number and normalize
+     const targetBrandValue = Number((targetBrand && targetBrand.value) ?? 0);
+     if (targetBrandValue > 0) {
+       // Convert to 0-1 range for market share representation
+       return targetBrandValue > 1 ? targetBrandValue / 100 : targetBrandValue;
+     }
@@ lines 334-347 @@
-   private getTopContributingFields(record: any): Record<string, number> {
-     const contributingFields: Array<{field: string, value: number, importance: number}> = [];
-   const fieldDefinitions = getTopFieldDefinitions('competitive_analysis');
-     fieldDefinitions.forEach(fieldDef => {
-       const sourceKey = Array.isArray(fieldDef.source) ? fieldDef.source[0] : fieldDef.source;
-       const value = Number(record[sourceKey]);
-       if (!isNaN(value) && value > 0) {
-         contributingFields.push({ field: fieldDef.field, value: Math.round(value * 100) / 100, importance: fieldDef.importance });
-       }
-     });
-     return contributingFields.sort((a, b) => b.importance - a.importance).slice(0,5).reduce((acc, item) => { acc[item.field] = item.value; return acc; }, {} as Record<string, number>);
-   }
- 
-   private determineCompetitivePosition(score: number): string {
---
+   private getTopContributingFields(record: any): Record<string, number> {
+     const contributingFields: Array<{field: string, value: number, importance: number}> = [];
+   const fieldDefinitions = getTopFieldDefinitions('competitive_analysis');
+     fieldDefinitions.forEach(fieldDef: any => {
+       const sourceKey = Array.isArray(fieldDef.source) ? fieldDef.source[0] : fieldDef.source;
+       const value = Number(record[sourceKey]);
+       if (!isNaN(value) && value > 0) {
+         contributingFields.push({ field: fieldDef.field, value: Math.round(value * 100) / 100, importance: fieldDef.importance });
+       }
+     });
+     return contributingFields.sort((a: any, b: any) => b.importance - a.importance).slice(0,5).reduce((acc: any, item: any) => { acc[item.field] = item.value; return acc; }, {} as Record<string, number>);
+   }
+ 
+   private determineCompetitivePosition(score: number): string {
+     if (score >= 85) return 'dominant_advantage';
+     if (score >= 70) return 'strong_advantage';
+     if (score >= 55) return 'competitive_advantage';
@@ lines 364-373 @@
-   }
- 
-   private calculateCompetitiveStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const scores = records.map(r => Number(r.value)).filter(v => !isNaN(v));
-     const marketShares = records
-       .map(r => Number((r.properties as any)?.target_brand_share) || 0)
-       .filter(v => !isNaN(v));
-     
-     if (scores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateCompetitiveStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const scores = records.map(r: any => Number(r.value)).filter(v: any => !isNaN(v));
+     const marketShares = records
+       .map(r: any => Number((r.properties as any)?.target_brand_share) || 0)
+       .filter(v: any => !isNaN(v));
+     
+     if (scores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         marketConcentration: 0, competitiveIntensity: 0, avgMarketShare: 0,
+         quintiles: { competitive: [], marketShare: [] } // Add quintile information
@@ lines 377-395 @@
-       };
-     }
-     
-     const sorted = [...scores].sort((a, b) => a - b);
-     // Normalize shares to 0-1 range for statistics
-     const normalizedShares = marketShares.map(s => (s > 1 ? s / 100 : s));
-     const sortedShares = [...normalizedShares].sort((a, b) => a - b);
-     const total = scores.length;
-     const sum = scores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Calculate quintiles (20%, 40%, 60%, 80%, 100%) for competitive scores
---
+       };
+     }
+     
+     const sorted = [...scores].sort((a: any, b: any) => a - b);
+     // Normalize shares to 0-1 range for statistics
+     const normalizedShares = marketShares.map(s: any => (s > 1 ? s / 100 : s));
+     const sortedShares = [...normalizedShares].sort((a: any, b: any) => a - b);
+     const total = scores.length;
+     const sum = scores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Calculate quintiles (20%, 40%, 60%, 80%, 100%) for competitive scores
+   const competitiveQuintiles = this.calculateQuintiles(sorted);
+   const marketShareQuintiles = this.calculateQuintiles(sortedShares);
+     
@@ lines 397-403 @@
-   const marketShareQuintiles = this.calculateQuintiles(sortedShares);
-     
-     // Competitive-specific metrics
-   const avgMarketShare = normalizedShares.reduce((a, b) => a + b, 0) / (normalizedShares.length || 1);
-   const marketConcentration = this.calculateMarketConcentration(normalizedShares);
-     const competitiveIntensity = this.calculateCompetitiveIntensity(scores);
-     
---
+   const marketShareQuintiles = this.calculateQuintiles(sortedShares);
+     
+     // Competitive-specific metrics
+   const avgMarketShare = normalizedShares.reduce((a: any, b: any) => a + b, 0) / (normalizedShares.length || 1);
+   const marketConcentration = this.calculateMarketConcentration(normalizedShares);
+     const competitiveIntensity = this.calculateCompetitiveIntensity(scores);
+     
+     console.log('[CompetitiveDataProcessor] Competitive quintiles calculated:', competitiveQuintiles);
+     console.log('[CompetitiveDataProcessor] Market share quintiles calculated:', marketShareQuintiles);
+     
@@ lines 429-435 @@
- 
-   private calculateMarketConcentration(marketShares: number[]): number {
-     // Calculate Herfindahl-Hirschman Index (HHI) as a measure of market concentration
-     const hhi = marketShares.reduce((sum, share) => sum + Math.pow(share, 2), 0);
-     return Math.min(1, hhi); // Normalize to 0-1 range
-   }
- 
---
+ 
+   private calculateMarketConcentration(marketShares: number[]): number {
+     // Calculate Herfindahl-Hirschman Index (HHI) as a measure of market concentration
+     const hhi = marketShares.reduce((sum: any, share: any) => sum + Math.pow(share, 2), 0);
+     return Math.min(1, hhi); // Normalize to 0-1 range
+   }
+ 
+   private calculateCompetitiveIntensity(scores: number[]): number {
+     // Measure how spread out the competitive scores are (higher spread = more intense competition)
+     if (scores.length <= 1) return 0;
@@ lines 437-444 @@
-     // Measure how spread out the competitive scores are (higher spread = more intense competition)
-     if (scores.length <= 1) return 0;
-     
-     const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / scores.length;
-     const coefficientOfVariation = Math.sqrt(variance) / mean;
-     
-     return Math.min(1, coefficientOfVariation); // Normalize to 0-1 range
---
+     // Measure how spread out the competitive scores are (higher spread = more intense competition)
+     if (scores.length <= 1) return 0;
+     
+     const mean = scores.reduce((a: any, b: any) => a + b, 0) / scores.length;
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / scores.length;
+     const coefficientOfVariation = Math.sqrt(variance) / mean;
+     
+     return Math.min(1, coefficientOfVariation); // Normalize to 0-1 range
+   }
+ 
+   private analyzeCompetitiveLandscape(records: GeographicDataPoint[]): any {
@@ lines 448-454 @@
-     // Group by competitive categories
-     const categoryMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const category = (record as any).category!;
-       if (!categoryMap.has(category)) {
-         categoryMap.set(category, []);
---
+     // Group by competitive categories
+     const categoryMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const category = (record as any).category!;
+       if (!categoryMap.has(category)) {
+         categoryMap.set(category, []);
+       }
+       categoryMap.get(category)!.push(record);
+     });
@@ lines 458-465 @@
-     
-     // Analyze each category
-     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
-   const avgScore = categoryRecords.reduce((sum, r) => sum + Number(r.value || 0), 0) / categoryRecords.length;
-   const avgMarketShare = categoryRecords.reduce((sum, r) => sum + (Number((r.properties as any)?.market_share) || 0), 0) / categoryRecords.length;
-       
-       return {
-         category,
---
+     
+     // Analyze each category
+     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
+   const avgScore = categoryRecords.reduce((sum: any, r: any) => sum + Number(r.value || 0), 0) / categoryRecords.length;
+   const avgMarketShare = categoryRecords.reduce((sum: any, r: any) => sum + (Number((r.properties as any)?.market_share) || 0), 0) / categoryRecords.length;
+       
+       return {
+         category,
+         size: categoryRecords.length,
+         percentage: (categoryRecords.length / records.length) * 100,
+         avgCompetitiveScore: avgScore,
@@ lines 468-476 @@
-         avgCompetitiveScore: avgScore,
-         avgMarketShare,
-         topAreas: categoryRecords
-           .sort((a, b) => b.value - a.value)
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             score: r.value,
-     marketShare: (r.properties as any)?.market_share
---
+         avgCompetitiveScore: avgScore,
+         avgMarketShare,
+         topAreas: categoryRecords
+           .sort((a: any, b: any) => b.value - a.value)
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             score: r.value,
+     marketShare: (r.properties as any)?.market_share
+           }))
+       };
+     });
@@ lines 480-503 @@
-     
-     // Identify market leaders and opportunities
-     const marketLeaders = records
-       .filter(r => r.category === 'dominant')
-       .sort((a, b) => b.value - a.value)
-       .slice(0, 5);
-     
-     const growthOpportunities = records
-       .filter(r => r.category === 'challenged' && (Number((r.properties as any)?.market_share) || 0) < 0.3)
-       .sort((a, b) => ((Number((b.properties as any)?.brand_awareness) || 0) - (Number((a.properties as any)?.brand_awareness) || 0)))
-       .slice(0, 5);
-     
-     return {
-       categories: categoryAnalysis,
-       marketLeaders: marketLeaders.map(r => ({
-         area: r.area_name,
-         score: r.value,
-         marketShare: (r.properties as any)?.market_share,
-         position: (r.properties as any)?.competitive_position
-       })),
-       growthOpportunities: growthOpportunities.map(r => ({
-         area: r.area_name,
-         currentShare: (r.properties as any)?.market_share,
-         brandAwareness: (r.properties as any)?.brand_awareness,
---
+     
+     // Identify market leaders and opportunities
+     const marketLeaders = records
+       .filter(r: any => r.category === 'dominant')
+       .sort((a: any, b: any) => b.value - a.value)
+       .slice(0, 5);
+     
+     const growthOpportunities = records
+       .filter(r: any => r.category === 'challenged' && (Number((r.properties as any)?.market_share) || 0) < 0.3)
+       .sort((a: any, b: any) => ((Number((b.properties as any)?.brand_awareness) || 0) - (Number((a.properties as any)?.brand_awareness) || 0)))
+       .slice(0, 5);
+     
+     return {
+       categories: categoryAnalysis,
+       marketLeaders: marketLeaders.map(r: any => ({
+         area: r.area_name,
+         score: r.value,
+         marketShare: (r.properties as any)?.market_share,
+         position: (r.properties as any)?.competitive_position
+       })),
+       growthOpportunities: growthOpportunities.map(r: any => ({
+         area: r.area_name,
+         currentShare: (r.properties as any)?.market_share,
+         brandAwareness: (r.properties as any)?.brand_awareness,
+         opportunity: 'high'
+       })),
+       competitiveBalance: this.assessCompetitiveBalance(categoryAnalysis)
@@ lines 508-515 @@
-   }
- 
-   private assessCompetitiveBalance(categoryAnalysis: any[]): string {
-     const dominantPercentage = categoryAnalysis.find(c => c.category === 'dominant')?.percentage || 0;
-     const competitivePercentage = categoryAnalysis.find(c => c.category === 'competitive')?.percentage || 0;
-     
-     if (dominantPercentage > 60) return 'market_monopolized';
-     if (dominantPercentage + competitivePercentage > 80) return 'oligopolistic';
---
+   }
+ 
+   private assessCompetitiveBalance(categoryAnalysis: any[]): string {
+     const dominantPercentage = categoryAnalysis.find(c: any => c.category === 'dominant')?.percentage || 0;
+     const competitivePercentage = categoryAnalysis.find(c: any => c.category === 'competitive')?.percentage || 0;
+     
+     if (dominantPercentage > 60) return 'market_monopolized';
+     if (dominantPercentage + competitivePercentage > 80) return 'oligopolistic';
+     if (competitivePercentage > 50) return 'highly_competitive';
+     return 'fragmented_market';
+   }
@@ lines 518-524 @@
-   }
- 
-   private processCompetitiveFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map((it) => {
-       const item = it as any;
-       const featureName = String((item as any).feature ?? (item as any).name ?? 'unknown');
-       const importance = Number((item as any).importance ?? (item as any).value ?? 0);
---
+   }
+ 
+   private processCompetitiveFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map((it: any) => {
+       const item = it as any;
+       const featureName = String((item as any).feature ?? (item as any).name ?? 'unknown');
+       const importance = Number((item as any).importance ?? (item as any).value ?? 0);
+       return {
+         feature: featureName,
+         importance,
@@ lines 528-534 @@
-         description: this.getCompetitiveFeatureDescription(featureName),
-         competitiveImpact: this.assessCompetitiveImpact(importance)
-       };
-     }).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getCompetitiveFeatureDescription(featureName: string): string {
---
+         description: this.getCompetitiveFeatureDescription(featureName),
+         competitiveImpact: this.assessCompetitiveImpact(importance)
+       };
+     }).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getCompetitiveFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'price': 'Price competitiveness factor',
+       'quality': 'Product/service quality impact',
@@ lines 575-584 @@
-     
-     // Enhanced summary with expansion opportunity focus
-     const topExpansionTargets = records.slice(0, 10); // Top 10 expansion opportunities
-     const avgScore = records.reduce((sum, r) => sum + Number(r.value || 0), 0) / recordCount;
-     
-     // Check data quality
-     const nonZeroRecords = records.filter(r => Number(r.value) > 0);
-     
-     // Get brand names from the first record or defaults
-     const firstProps = (records[0]?.properties || {}) as any;
---
+     
+     // Enhanced summary with expansion opportunity focus
+     const topExpansionTargets = records.slice(0, 10); // Top 10 expansion opportunities
+     const avgScore = records.reduce((sum: any, r: any) => sum + Number(r.value || 0), 0) / recordCount;
+     
+     // Check data quality
+     const nonZeroRecords = records.filter(r: any => Number(r.value) > 0);
+     
+     // Get brand names from the first record or defaults
+     const firstProps = (records[0]?.properties || {}) as any;
+   const targetBrandName = firstProps?.target_brand_name || (this.brandResolver.getTargetBrandName?.() ?? '');
+     const competitorBrandName = firstProps?.primary_competitor_name || 'Primary Competitor';
+     
@@ lines 603-634 @@
-   summary += `Market average competitive advantage: ${avgScore.toFixed(1)} (range: ${rangeLow != null ? Number(rangeLow).toFixed(1) : '0'}-${rangeHigh != null ? Number(rangeHigh).toFixed(1) : '0'}). `;
-     
-     // Calculate competitive landscape baselines using dynamic brand detection
-     const avgTargetShare = records.reduce((sum, r) => {
-       const targetShare = Number((r.properties as any)?.target_brand_share) || 0;
-       return sum + targetShare;
-     }, 0) / recordCount;
-     
-     const avgCompetitorShare = records.reduce((sum, r) => {
-       const competitorShare = Number((r.properties as any)?.primary_competitor_share) || 0;
-       return sum + competitorShare;
-     }, 0) / recordCount;
-     
-     const avgMarketGap = 100 - avgTargetShare - avgCompetitorShare;
-     const avgWealthIndex = records.reduce((sum, r) => sum + (Number((r.properties as any)?.value_WLTHINDXCY) || 100), 0) / recordCount;
-     const avgIncome = records.reduce((sum, r) => {
-       const wealth = Number((r.properties as any)?.value_WLTHINDXCY) || 100;
-       const income = Number((r.properties as any)?.value_AVGHINC_CY) || (wealth * 500);
-       return sum + income;
-     }, 0) / recordCount;
-     const avgPopulation = records.reduce((sum, r) => sum + (Number((r.properties as any)?.value_TOTPOP_CY) || 0), 0) / recordCount;
-     
-     summary += `Competitive baseline: ${targetBrandName} ${avgTargetShare.toFixed(1)}%, ${competitorBrandName} ${avgCompetitorShare.toFixed(1)}%, untapped market ${avgMarketGap.toFixed(1)}%. `;
-     summary += `Market demographics: wealth index ${avgWealthIndex.toFixed(0)}, $${(avgIncome/1000).toFixed(0)}K estimated income, ${(avgPopulation/1000).toFixed(0)}K average population. `;
-     
-     // Expansion opportunity distribution
-     const highExpansion = records.filter(r => r.value >= 70).length;
-     const moderateExpansion = records.filter(r => r.value >= 50).length;
-     const developingExpansion = records.filter(r => r.value >= 30).length;
-     
-     summary += `Expansion distribution: ${highExpansion} high-opportunity markets (${(highExpansion/recordCount*100).toFixed(1)}%), ${moderateExpansion} moderate+ (${(moderateExpansion/recordCount*100).toFixed(1)}%), ${developingExpansion} developing+ (${(developingExpansion/recordCount*100).toFixed(1)}%).
- 
---
+   summary += `Market average competitive advantage: ${avgScore.toFixed(1)} (range: ${rangeLow != null ? Number(rangeLow).toFixed(1) : '0'}-${rangeHigh != null ? Number(rangeHigh).toFixed(1) : '0'}). `;
+     
+     // Calculate competitive landscape baselines using dynamic brand detection
+     const avgTargetShare = records.reduce((sum: any, r: any) => {
+       const targetShare = Number((r.properties as any)?.target_brand_share) || 0;
+       return sum + targetShare;
+     }, 0) / recordCount;
+     
+     const avgCompetitorShare = records.reduce((sum: any, r: any) => {
+       const competitorShare = Number((r.properties as any)?.primary_competitor_share) || 0;
+       return sum + competitorShare;
+     }, 0) / recordCount;
+     
+     const avgMarketGap = 100 - avgTargetShare - avgCompetitorShare;
+     const avgWealthIndex = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any)?.value_WLTHINDXCY) || 100), 0) / recordCount;
+     const avgIncome = records.reduce((sum: any, r: any) => {
+       const wealth = Number((r.properties as any)?.value_WLTHINDXCY) || 100;
+       const income = Number((r.properties as any)?.value_AVGHINC_CY) || (wealth * 500);
+       return sum + income;
+     }, 0) / recordCount;
+     const avgPopulation = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any)?.value_TOTPOP_CY) || 0), 0) / recordCount;
+     
+     summary += `Competitive baseline: ${targetBrandName} ${avgTargetShare.toFixed(1)}%, ${competitorBrandName} ${avgCompetitorShare.toFixed(1)}%, untapped market ${avgMarketGap.toFixed(1)}%. `;
+     summary += `Market demographics: wealth index ${avgWealthIndex.toFixed(0)}, $${(avgIncome/1000).toFixed(0)}K estimated income, ${(avgPopulation/1000).toFixed(0)}K average population. `;
+     
+     // Expansion opportunity distribution
+     const highExpansion = records.filter(r: any => r.value >= 70).length;
+     const moderateExpansion = records.filter(r: any => r.value >= 50).length;
+     const developingExpansion = records.filter(r: any => r.value >= 30).length;
+     
+     summary += `Expansion distribution: ${highExpansion} high-opportunity markets (${(highExpansion/recordCount*100).toFixed(1)}%), ${moderateExpansion} moderate+ (${(moderateExpansion/recordCount*100).toFixed(1)}%), ${developingExpansion} developing+ (${(developingExpansion/recordCount*100).toFixed(1)}%).
+ 
+ `;
+     
+     summary += `**Competitive Advantage Analysis:** Analyzed ${recordCount} markets to identify where ${targetBrandName} has the strongest competitive position. Scoring combines ${targetBrandName}'s market position vs ${competitorBrandName}, demographic alignment with ${targetBrandName}'s brand positioning, and competitive environment favorability. `;
@@ lines 645-651 @@
-       summary += `
- \n**🎯 Top Expansion Opportunities** (Markets with GROWTH potential, not current ${targetBrandName} dominance): `;
-       
-       topExpansionTargets.slice(0, 10).forEach((record, index) => {
-         const props = ((record as any).properties || {}) as any;
-         const targetShare = Number(props?.target_brand_share) || 0;
-         const competitorShare = Number(props?.primary_competitor_share) || 0;
---
+       summary += `
+ \n**🎯 Top Expansion Opportunities** (Markets with GROWTH potential, not current ${targetBrandName} dominance): `;
+       
+       topExpansionTargets.slice(0, 10).forEach((record: any, index: any) => {
+         const props = ((record as any).properties || {}) as any;
+         const targetShare = Number(props?.target_brand_share) || 0;
+         const competitorShare = Number(props?.primary_competitor_share) || 0;
+         const population = Number(props?.value_TOTPOP_CY) || 0;
+         const wealthIndex = Number(props?.value_WLTHINDXCY) || 100;
+         const income = Number(props?.value_AVGHINC_CY) || (wealthIndex * 500); // Use wealth index to estimate income
@@ lines 673-686 @@
-     }
-     
-     // Market segmentation based on expansion opportunity scores (not brand dominance)
-     const topTierMarkets = records.filter(r => r.value >= 80).slice(0, 10);
-     const strongMarkets = records.filter(r => r.value >= 60 && r.value < 80).slice(0, 10);
-     const emergingMarkets = records.filter(r => r.value >= 40 && r.value < 60).slice(0, 10);
-     
-     if (topTierMarkets.length > 0) {
-       summary += `
- \n**🏆 Premium Expansion Targets** (80+ expansion scores - high growth potential): `;
-       topTierMarkets.forEach((record) => {
-         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
-         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
-       });
---
+     }
+     
+     // Market segmentation based on expansion opportunity scores (not brand dominance)
+     const topTierMarkets = records.filter(r: any => r.value >= 80).slice(0, 10);
+     const strongMarkets = records.filter(r: any => r.value >= 60 && r.value < 80).slice(0, 10);
+     const emergingMarkets = records.filter(r: any => r.value >= 40 && r.value < 60).slice(0, 10);
+     
+     if (topTierMarkets.length > 0) {
+       summary += `
+ \n**🏆 Premium Expansion Targets** (80+ expansion scores - high growth potential): `;
+       topTierMarkets.forEach((record: any) => {
+         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
+         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
+       });
+       summary = summary.slice(0, -2) + '. ';
+     }
+     
@@ lines 690-696 @@
-     if (strongMarkets.length > 0) {
-       summary += `
- \n**📈 Strong Expansion Targets** (60-80 expansion scores - solid growth potential): `;
-       strongMarkets.forEach((record) => {
-         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
-         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
-       });
---
+     if (strongMarkets.length > 0) {
+       summary += `
+ \n**📈 Strong Expansion Targets** (60-80 expansion scores - solid growth potential): `;
+       strongMarkets.forEach((record: any) => {
+         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
+         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
+       });
+       summary = summary.slice(0, -2) + '. ';
+     }
+     
@@ lines 700-706 @@
-     if (emergingMarkets.length > 0) {
-       summary += `
- \n**🌱 Developing Expansion Markets** (40-60 expansion scores - moderate growth potential): `;
-       emergingMarkets.forEach((record) => {
-         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
-         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
-       });
---
+     if (emergingMarkets.length > 0) {
+       summary += `
+ \n**🌱 Developing Expansion Markets** (40-60 expansion scores - moderate growth potential): `;
+       emergingMarkets.forEach((record: any) => {
+         const targetShare = Number((((record as any).properties || {}) as any)?.target_brand_share) || 0;
+         summary += `${(record as any).area_name} (${(record as any).value.toFixed(1)} score, ${targetShare.toFixed(1)}% ${targetBrandName} share), `;
+       });
+       summary = summary.slice(0, -2) + '. ';
+     }
+     
@@ lines 720-726 @@
-     }
-     
-     // High-scoring market concentration
-     const highScoreMarkets = records.filter(r => r.value >= 70).length;
-     if (highScoreMarkets > 0) {
-       summary += `${highScoreMarkets} markets show exceptional expansion potential (70+ scores). `;
-     }
---
+     }
+     
+     // High-scoring market concentration
+     const highScoreMarkets = records.filter(r: any => r.value >= 70).length;
+     if (highScoreMarkets > 0) {
+       summary += `${highScoreMarkets} markets show exceptional expansion potential (70+ scores). `;
+     }
+     
+     // Competitive positioning insights
+   const competitiveAnalysisData = competitiveAnalysis?.categories;
@@ lines 748-754 @@
-    * Create direct renderer for competitive analysis visualization
-    */
-   private createCompetitiveRenderer(records: any[], primaryField?: string): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use same colors as strategic analysis: Red (low) -> Orange -> Light Green -> Dark Green (high)
---
+    * Create direct renderer for competitive analysis visualization
+    */
+   private createCompetitiveRenderer(records: any[], primaryField?: string): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use same colors as strategic analysis: Red (low) -> Orange -> Light Green -> Dark Green (high)
+     const competitiveColors = [
+       [215, 48, 39, 0.6],   // #d73027 - Red (lowest competitive advantage)
+       [253, 174, 97, 0.6],  // #fdae61 - Orange  
@@ lines 762-768 @@
-     return {
-       type: 'class-breaks',
-       field: primaryField || 'competitive_analysis_score', // Use correct scoring field
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+       field: primaryField || 'competitive_analysis_score', // Use correct scoring field
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: competitiveColors[i], // Direct array format
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 784-790 @@
-    * Create direct legend for competitive analysis
-    */
-   private createCompetitiveLegend(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use RGBA format with correct opacity to match features (same as strategic)
---
+    * Create direct legend for competitive analysis
+    */
+   private createCompetitiveLegend(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use RGBA format with correct opacity to match features (same as strategic)
+     const colors = [
+       'rgba(215, 48, 39, 0.6)',   // Low competitive advantage
+       'rgba(253, 174, 97, 0.6)',  // Medium-low  


*** FILE: components/geospatial-chat-interface.tsx
@@ lines 531-537 @@
-     if (detectedBrands.length > 0) {
-       // Set target to first detected brand
-       const firstBrandField = detectedBrands[0];
-       const targetOption = TARGET_OPTIONS.find(opt => opt.value === firstBrandField);
-       
-       if (targetOption && currentTarget !== firstBrandField) {
-         setCurrentTarget(firstBrandField);
---
+     if (detectedBrands.length > 0) {
+       // Set target to first detected brand
+       const firstBrandField = detectedBrands[0];
+       const targetOption = TARGET_OPTIONS.find(opt: any => opt.value === firstBrandField);
+       
+       if (targetOption && currentTarget !== firstBrandField) {
+         setCurrentTarget(firstBrandField);
+         const brandIcon = BRAND_ICON_MAP[targetOption.label] || SiNike;
+         setTargetIcon(() => brandIcon);
+         setManualTargetOverride(false);
@@ lines 553-559 @@
-   useEffect(() => {
-     if (lastAnalysisResult?.targetVariable) {
-       // Fix case sensitivity issue - search case-insensitively
-       const targetOption = TARGET_OPTIONS.find(opt => 
-         opt.value.toLowerCase() === lastAnalysisResult.targetVariable?.toLowerCase()
-       );
-       
---
+   useEffect(() => {
+     if (lastAnalysisResult?.targetVariable) {
+       // Fix case sensitivity issue - search case-insensitively
+       const targetOption = TARGET_OPTIONS.find(opt: any => 
+         opt.value.toLowerCase() === lastAnalysisResult.targetVariable?.toLowerCase()
+       );
+       
+       if (targetOption) {
+         setCurrentTarget(targetOption.value);
+         const brandIcon = BRAND_ICON_MAP[targetOption.label] || SiNike;
@@ lines 571-577 @@
-     console.log('[DEBUG] Target button state changed:', {
-       currentTarget,
-       targetIconName: targetIcon?.displayName || targetIcon?.name || 'Unknown',
-       targetLabel: TARGET_OPTIONS.find(o => o.value === currentTarget)?.label,
-       inputQuery: inputQuery.substring(0, 50),
-       timestamp: new Date().toISOString()
-     });
---
+     console.log('[DEBUG] Target button state changed:', {
+       currentTarget,
+       targetIconName: targetIcon?.displayName || targetIcon?.name || 'Unknown',
+       targetLabel: TARGET_OPTIONS.find(o: any => o.value === currentTarget)?.label,
+       inputQuery: inputQuery.substring(0, 50),
+       timestamp: new Date().toISOString()
+     });
+   }, [currentTarget, targetIcon, inputQuery]);
+ 
+   // Visualization customization panel state (moved earlier so it is declared before use)
@@ lines 602-608 @@
-         // Find the last assistant message
-         const lastAssistantMessageIndex = [...prevMessages]
-           .reverse()
-           .findIndex(msg => msg.role === 'assistant' || msg.role === 'system');
-         
-         if (lastAssistantMessageIndex >= 0) {
-           const actualIndex = prevMessages.length - 1 - lastAssistantMessageIndex;
---
+         // Find the last assistant message
+         const lastAssistantMessageIndex = [...prevMessages]
+           .reverse()
+           .findIndex(msg: any => msg.role === 'assistant' || msg.role === 'system');
+         
+         if (lastAssistantMessageIndex >= 0) {
+           const actualIndex = prevMessages.length - 1 - lastAssistantMessageIndex;
+           const updatedMessages = [...prevMessages];
+           const lastAssistantMessage = updatedMessages[actualIndex];
+           
@@ lines 613-619 @@
-           // Don't override detailed analysis results (like SHAP analysis)
-           if (lastAssistantMessage.content === 'Processing your query...') {
-             // Format information about the real data results
-             const layerIds = [...new Set(features.map(f => f.properties?.layerId || 'unknown'))];
-             const layerInfo = layerIds.length > 1 ? 
-               `across ${layerIds.length} layers` : 
-               layerIds[0] !== 'unknown' ? `from ${layerIds[0]}` : '';
---
+           // Don't override detailed analysis results (like SHAP analysis)
+           if (lastAssistantMessage.content === 'Processing your query...') {
+             // Format information about the real data results
+             const layerIds = [...new Set(features.map(f: any => f.properties?.layerId || 'unknown'))];
+             const layerInfo = layerIds.length > 1 ? 
+               `across ${layerIds.length} layers` : 
+               layerIds[0] !== 'unknown' ? `from ${layerIds[0]}` : '';
+             
+             console.log('[GeospatialChat] Processing features for message update:', {
+               featuresLength: features.length,
@@ lines 704-710 @@
-       const suggestions = suggestAnalysisEndpoint(newQuery);
-       if (suggestions.length > 0 && suggestions[0].confidence > 0.4) {
-         // Map to endpoint names for display
-         const suggestionInfo = suggestions.slice(0, 3).map(s => ({
-           id: s.endpointId,
-           name: getEndpointName(s.endpointId),
-           confidence: s.confidence,
---
+       const suggestions = suggestAnalysisEndpoint(newQuery);
+       if (suggestions.length > 0 && suggestions[0].confidence > 0.4) {
+         // Map to endpoint names for display
+         const suggestionInfo = suggestions.slice(0, 3).map(s: any => ({
+           id: s.endpointId,
+           name: getEndpointName(s.endpointId),
+           confidence: s.confidence,
+           reasoning: s.reasoning[0]
+         }));
+         setEndpointSuggestions(suggestionInfo);
@@ lines 784-790 @@
-         'real_estate_analysis': 'Real Estate Analysis Score'
-       };
-       
-       baseHeaders[2] = scoreNames[type] || `${targetVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
-       return baseHeaders;
-     };
- 
---
+         'real_estate_analysis': 'Real Estate Analysis Score'
+       };
+       
+       baseHeaders[2] = scoreNames[type] || `${targetVar.replace(/_/g, ' ').replace(/\b\w/g, l: any => l.toUpperCase())}`;
+       return baseHeaders;
+     };
+ 
+     // Create CSV headers
+     const headers = getReadableHeaders(analysisType, targetVariable);
+     
@@ lines 845-851 @@
-   const handleExportData = async (messageId: string) => {
-     try {
-       // Find the message with visualization data
-       const message = messages.find(m => m.id === messageId);
-       if (!message?.metadata?.analysisResult?.data) {
-         toast({
-           title: "Export failed",
---
+   const handleExportData = async (messageId: string) => {
+     try {
+       // Find the message with visualization data
+       const message = messages.find(m: any => m.id === messageId);
+       if (!message?.metadata?.analysisResult?.data) {
+         toast({
+           title: "Export failed",
+           description: "No analysis data found to export",
+           variant: "destructive",
+         });
@@ lines 910-917 @@
-             name: key.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()),
-             value: typeof value === 'number' ? value * 100 : 0 // Convert to percentage
-           }))
-           .sort((a, b) => b.value - a.value)
-           .filter(item => item.value > 0);
-         } else {
-           console.log('[SHAP Extract] No component weights found, creating fallback data');
-           // For strategic analysis without methodology, create a fallback based on the scoring components
---
+             name: key.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()),
+             value: typeof value === 'number' ? value * 100 : 0 // Convert to percentage
+           }))
+           .sort((a: any, b: any) => b.value - a.value)
+           .filter(item: any => item.value > 0);
+         } else {
+           console.log('[SHAP Extract] No component weights found, creating fallback data');
+           // For strategic analysis without methodology, create a fallback based on the scoring components
+           return [
+             { name: 'Demographic Opportunity Score', value: 21 },
+             { name: 'Competitive Advantage Score', value: 20 },
@@ lines 958-964 @@
-         const properties = record.properties || record;
-         
-         // Find all SHAP fields (fields starting with 'shap_')
-         Object.keys(properties).forEach(key => {
-           if (key.startsWith('shap_') && typeof properties[key] === 'number') {
-             // Clean field name (remove 'shap_' prefix and make readable)
-             const fieldName = key.replace('shap_', '').replace(/_/g, ' ');
---
+         const properties = record.properties || record;
+         
+         // Find all SHAP fields (fields starting with 'shap_')
+         Object.keys(properties).forEach(key: any => {
+           if (key.startsWith('shap_') && typeof properties[key] === 'number') {
+             // Clean field name (remove 'shap_' prefix and make readable)
+             const fieldName = key.replace('shap_', '').replace(/_/g, ' ');
+             const readableName = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
+             
+             if (!shapAggregation[readableName]) {
@@ lines 973-979 @@
- 
-         // Log SHAP fields found in first few records for debugging
-         if (index < 3) {
-           const shapFields = Object.keys(properties).filter(k => k.startsWith('shap_'));
-           console.log(`[SHAP Extract] Record ${index} SHAP fields:`, shapFields);
-         }
-       });
---
+ 
+         // Log SHAP fields found in first few records for debugging
+         if (index < 3) {
+           const shapFields = Object.keys(properties).filter(k: any => k.startsWith('shap_'));
+           console.log(`[SHAP Extract] Record ${index} SHAP fields:`, shapFields);
+         }
+       });
+ 
+       console.log('[SHAP Extract] Aggregated SHAP fields:', Object.keys(shapAggregation));
+ 
@@ lines 983-996 @@
-       // Calculate average importance for each field
-       const shapValues = Object.entries(shapAggregation).map(([name, values]) => ({
-         name,
-         value: values.reduce((sum, val) => sum + val, 0) / values.length
-       }));
- 
-       // Sort by importance (descending) and take top 10
-       return shapValues
-         .sort((a, b) => b.value - a.value)
-         .slice(0, 10)
-         .filter(item => item.value > 0); // Only include non-zero values
- 
-     } catch (error) {
-       console.error('[SHAP Extract] Error extracting SHAP values:', error);
---
+       // Calculate average importance for each field
+       const shapValues = Object.entries(shapAggregation).map(([name, values]) => ({
+         name,
+         value: values.reduce((sum: any, val: any) => sum + val, 0) / values.length
+       }));
+ 
+       // Sort by importance (descending) and take top 10
+       return shapValues
+         .sort((a: any, b: any) => b.value - a.value)
+         .slice(0, 10)
+         .filter(item: any => item.value > 0); // Only include non-zero values
+ 
+     } catch (error) {
+       console.error('[SHAP Extract] Error extracting SHAP values:', error);
+       return [];
+     }
+   };
@@ lines 1001-1007 @@
-   const handleSHAPChart = async (messageId: string) => {
-     try {
-       // Find the message with analysis data
-       const message = messages.find(m => m.id === messageId);
-       if (!message?.metadata?.analysisResult?.data) {
-         toast({
-           title: "Chart creation failed",
---
+   const handleSHAPChart = async (messageId: string) => {
+     try {
+       // Find the message with analysis data
+       const message = messages.find(m: any => m.id === messageId);
+       if (!message?.metadata?.analysisResult?.data) {
+         toast({
+           title: "Chart creation failed",
+           description: "No analysis data found to create chart",
+           variant: "destructive",
+         });
@@ lines 1018-1024 @@
-       
-       if (analysisData.features && analysisData.features.length > 0) {
-         console.log('[SHAP Chart] Sample feature properties:', analysisData.features[0]?.properties);
-         console.log('[SHAP Chart] SHAP fields in first feature:', Object.keys(analysisData.features[0]?.properties || {}).filter(k => k.startsWith('shap_')));
-       }
-       
-       // Extract SHAP values from the analysis data
---
+       
+       if (analysisData.features && analysisData.features.length > 0) {
+         console.log('[SHAP Chart] Sample feature properties:', analysisData.features[0]?.properties);
+         console.log('[SHAP Chart] SHAP fields in first feature:', Object.keys(analysisData.features[0]?.properties || {}).filter(k: any => k.startsWith('shap_')));
+       }
+       
+       // Extract SHAP values from the analysis data
+       const shapData = extractSHAPValues(analysisData);
+       
+       if (!shapData || shapData.length === 0) {
@@ lines 1080-1086 @@
-     // Clear visualization layer from map
-     if (currentMapView) {
-       const highlightLayer = currentMapView.map.layers.find(
-         (layer) => layer.title === "Highlighted FSAs"
-       );
-       if (highlightLayer && currentMapView && currentMapView.map) {
-         try {
---
+     // Clear visualization layer from map
+     if (currentMapView) {
+       const highlightLayer = currentMapView.map.layers.find(
+         (layer: any) => layer.title === "Highlighted FSAs"
+       );
+       if (highlightLayer && currentMapView && currentMapView.map) {
+         try {
+           currentMapView.map.remove(highlightLayer);
+         } catch (error) {
+           console.warn('[GeospatialChat] Error removing highlight layer:', error);
@@ lines 1151-1157 @@
-         }
-         
-         // Validate feature structure
-         const validFeatures = features.filter(f => f && f.properties && f.geometry);
-         if (validFeatures.length === 0) {
-           console.error('[loadGeographicFeatures] ❌ No valid boundary features with properties and geometry');
-           throw new Error('No valid boundary features found');
---
+         }
+         
+         // Validate feature structure
+         const validFeatures = features.filter(f: any => f && f.properties && f.geometry);
+         if (validFeatures.length === 0) {
+           console.error('[loadGeographicFeatures] ❌ No valid boundary features with properties and geometry');
+           throw new Error('No valid boundary features found');
+         }
+         
+         console.log('[loadGeographicFeatures] 🔍 Feature validation:', {
@@ lines 1248-1254 @@
-     
-     console.log('[loadBoundariesFromFile] ✅ Converted to internal format:', {
-       totalFeatures: features.length,
-       validFeatures: features.filter(f => f.geometry && f.properties).length,
-       sampleFeature: features[0] ? {
-         hasGeometry: !!features[0].geometry,
-         geometryType: features[0].geometry?.type,
---
+     
+     console.log('[loadBoundariesFromFile] ✅ Converted to internal format:', {
+       totalFeatures: features.length,
+       validFeatures: features.filter(f: any => f.geometry && f.properties).length,
+       sampleFeature: features[0] ? {
+         hasGeometry: !!features[0].geometry,
+         geometryType: features[0].geometry?.type,
+         hasProperties: !!features[0].properties,
+         sampleId: features[0].properties?.ID
+       } : null
@@ lines 1310-1316 @@
-       return normalizedFeatureId === targetId;
-     });
-     
-     console.log(`🔍 [DEBUG] Found ${matches.length} matches:`, matches.map(m => ({
-       area_name: m.area_name,
-       cluster_id: m.cluster_id,
-       hasGeometry: !!m.geometry,
---
+       return normalizedFeatureId === targetId;
+     });
+     
+     console.log(`🔍 [DEBUG] Found ${matches.length} matches:`, matches.map(m: any => ({
+       area_name: m.area_name,
+       cluster_id: m.cluster_id,
+       hasGeometry: !!m.geometry,
+       properties: m.properties
+     })));
+     
@@ lines 1318-1324 @@
-     })));
-     
-     // Sample some features that might be close
-     const sampleFeatures = features.slice(0, 20).map(f => {
-       let extractedId = null;
-       if (f.area_name) {
-         const zipMatch = f.area_name.match(/^\d{5}/);
---
+     })));
+     
+     // Sample some features that might be close
+     const sampleFeatures = features.slice(0, 20).map(f: any => {
+       let extractedId = null;
+       if (f.area_name) {
+         const zipMatch = f.area_name.match(/^\d{5}/);
+         if (zipMatch) extractedId = zipMatch[0];
+       }
+       return {
@@ lines 1378-1386 @@
-       // Debug: What type of data are we working with?
-       console.log('[ZoomToFeature] Data analysis:', {
-         totalFeatures: features.length,
-         isClustered: features.some(f => f.cluster_id !== undefined),
-         hasAreaNames: features.some(f => f.area_name !== undefined),
-         dataTypes: features.slice(0, 3).map(f => ({
-           hasProperties: !!f.properties,
-           hasAreaName: !!f.area_name,
-           hasClusterId: f.cluster_id !== undefined,
---
+       // Debug: What type of data are we working with?
+       console.log('[ZoomToFeature] Data analysis:', {
+         totalFeatures: features.length,
+         isClustered: features.some(f: any => f.cluster_id !== undefined),
+         hasAreaNames: features.some(f: any => f.area_name !== undefined),
+         dataTypes: features.slice(0, 3).map(f: any => ({
+           hasProperties: !!f.properties,
+           hasAreaName: !!f.area_name,
+           hasClusterId: f.cluster_id !== undefined,
+           areaNameSample: f.area_name,
+           propertiesKeys: Object.keys(f.properties || {}).slice(0, 5)
+         }))
@@ lines 1446-1452 @@
-         console.warn('[ZoomToFeature] Feature not found:', { 
-           targetId, 
-           totalFeatures: features.length,
-           first10Features: features.slice(0, 10).map(f => ({
-             FSA_ID: f.properties?.FSA_ID,
-             ID: f.properties?.ID,
-             OBJECTID: f.properties?.OBJECTID,
---
+         console.warn('[ZoomToFeature] Feature not found:', { 
+           targetId, 
+           totalFeatures: features.length,
+           first10Features: features.slice(0, 10).map(f: any => ({
+             FSA_ID: f.properties?.FSA_ID,
+             ID: f.properties?.ID,
+             OBJECTID: f.properties?.OBJECTID,
+             area_id: f.properties?.area_id,
+             zip_code: f.properties?.zip_code,
+             ZIPCODE: f.properties?.ZIPCODE,
@@ lines 1634-1640 @@
-       
-       // Call Claude API for contextual response
-     requestPayload = {
-         messages: [...messages, userMessage].map(m => ({ role: m.role, content: m.content })),
-         metadata: {
-           query,
-           analysisType: lastAnalysisEndpoint ? lastAnalysisEndpoint.replace('/', '').replace(/-/g, '_') : 'contextual_chat',
---
+       
+       // Call Claude API for contextual response
+     requestPayload = {
+         messages: [...messages, userMessage].map(m: any => ({ role: m.role, content: m.content })),
+         metadata: {
+           query,
+           analysisType: lastAnalysisEndpoint ? lastAnalysisEndpoint.replace('/', '').replace(/-/g, '_') : 'contextual_chat',
+           relevantLayers: [dataSource.layerId],
+           isContextualChat: true, // Flag to indicate this is contextual, not new analysis
+       contextualData, // Include all the contextual analysis state
@@ lines 2037-2043 @@
-         console.log('🚨🚨🚨 Records count:', analysisResult.data?.records?.length);
-         if (analysisResult.data?.records?.length > 0) {
-           console.log('🚨🚨🚨 First 3 record values:');
-           analysisResult.data.records.slice(0, 3).forEach((record, i) => {
-             console.log(`🚨🚨🚨   ${i+1}. ${record.area_name}: value=${record.value}`);
-           });
-           
---
+         console.log('🚨🚨🚨 Records count:', analysisResult.data?.records?.length);
+         if (analysisResult.data?.records?.length > 0) {
+           console.log('🚨🚨🚨 First 3 record values:');
+           analysisResult.data.records.slice(0, 3).forEach((record: any, i: any) => {
+             console.log(`🚨🚨🚨   ${i+1}. ${record.area_name}: value=${record.value}`);
+           });
+           
+           // Check for the 79.3 issue
+           const values = analysisResult.data.records.slice(0, 5).map((r: any) => r.value);
+           const uniqueValues = [...new Set(values)];
@@ lines 2091-2097 @@
-       // --- INTEGRATION: Convert AnalysisEngine result to existing format ---
-       
-       // Update processing steps to complete
-       setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s => 
-         s.id === 'narrative_generation' ? { ...s, status: 'processing' as any } : { ...s, status: 'complete' as any }
-       ));
-       setCurrentProcessingStep('narrative_generation');
---
+       // --- INTEGRATION: Convert AnalysisEngine result to existing format ---
+       
+       // Update processing steps to complete
+       setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s: any => 
+         s.id === 'narrative_generation' ? { ...s, status: 'processing' as any } : { ...s, status: 'complete' as any }
+       ));
+       setCurrentProcessingStep('narrative_generation');
+ 
+       // --- FIXED: Properly join AnalysisEngine data with geographic features ---
+       console.log('🚨 [DEBUG] GEOGRAPHIC JOIN SECTION REACHED - This should appear in console logs');
@@ lines 2123-2129 @@
-         // Use explicit await instead of mixing await + then to satisfy TypeScript diagnostics
-         const loadedFeatures = await loadGeographicFeatures();
-         console.log('[AnalysisEngine] loadGeographicFeatures resolved with:', (loadedFeatures as any)?.length || 0, 'features');
-         geographicFeatures = (loadedFeatures as any[]).filter((f): f is FeatureType => f !== null);
-         
-         const loadingTime = Date.now() - loadingStartTime;
-         console.log('[AnalysisEngine] ✅ ZIP Code polygon boundaries loaded:', {
---
+         // Use explicit await instead of mixing await + then to satisfy TypeScript diagnostics
+         const loadedFeatures = await loadGeographicFeatures();
+         console.log('[AnalysisEngine] loadGeographicFeatures resolved with:', (loadedFeatures as any)?.length || 0, 'features');
+         geographicFeatures = (loadedFeatures as any[]).filter((f: any): f is FeatureType => f !== null);
+         
+         const loadingTime = Date.now() - loadingStartTime;
+         console.log('[AnalysisEngine] ✅ ZIP Code polygon boundaries loaded:', {
+           count: geographicFeatures.length,
+           loadingTime: `${loadingTime}ms`,
+           sampleFeature: geographicFeatures[0] ? {
@@ lines 2234-2240 @@
-         }
-         
-         // Find matching boundary by ID (supports both ZIP codes and FSAs)
-         const zipFeature = geographicFeatures.find(f => {
-           if (!f?.properties) return false;
-           
-           // For FSAs (3 chars: letter-digit-letter), match without padding
---
+         }
+         
+         // Find matching boundary by ID (supports both ZIP codes and FSAs)
+         const zipFeature = geographicFeatures.find(f: any => {
+           if (!f?.properties) return false;
+           
+           // For FSAs (3 chars: letter-digit-letter), match without padding
+           if (isFSA) {
+             return (
+               String(f.properties.ID || '').toUpperCase() === recordZip ||
@@ lines 2310-2321 @@
-           
-           // Debug what's in ZIP boundary that might conflict
-           console.log(`   ZIP boundary conflicting fields:`, 
-             competitiveFields.filter(field => zipProps[field] !== undefined)
-               .map(field => `${field}=${zipProps[field]}`));
-           
-           // For competitive analysis, don't let ZIP boundary overwrite competitive fields
-           if (isCompetitiveAnalysis) {
-             competitiveFields.forEach(field => {
-               if (preservedProps[field] !== undefined && zipProps[field] !== undefined) {
-                 console.log(`   🔧 Removing conflicting ${field}: ${zipProps[field]} → deleted`);
-                 delete zipProps[field]; // Remove conflicting field from ZIP boundary
---
+           
+           // Debug what's in ZIP boundary that might conflict
+           console.log(`   ZIP boundary conflicting fields:`, 
+             competitiveFields.filter(field: any => zipProps[field] !== undefined)
+               .map(field: any => `${field}=${zipProps[field]}`));
+           
+           // For competitive analysis, don't let ZIP boundary overwrite competitive fields
+           if (isCompetitiveAnalysis) {
+             competitiveFields.forEach(field: any => {
+               if (preservedProps[field] !== undefined && zipProps[field] !== undefined) {
+                 console.log(`   🔧 Removing conflicting ${field}: ${zipProps[field]} → deleted`);
+                 delete zipProps[field]; // Remove conflicting field from ZIP boundary
+               }
+             });
+           }
@@ lines 2368-2376 @@
-       // CRITICAL DEBUG: Check join results
-       console.log('[AnalysisEngine] ❗ JOIN RESULTS DEBUG:', {
-         totalRecords: joinedResults.length,
-         recordsWithGeometry: joinedResults.filter(r => r.geometry !== null).length,
-         recordsWithoutGeometry: joinedResults.filter(r => r.geometry === null).length,
-         geometryTypes: [...new Set(joinedResults.map(r => r.geometry?.type).filter(Boolean))],
-         firstRecord: joinedResults[0] ? {
-           area_id: joinedResults[0].area_id,
-           area_name: joinedResults[0].area_name,
---
+       // CRITICAL DEBUG: Check join results
+       console.log('[AnalysisEngine] ❗ JOIN RESULTS DEBUG:', {
+         totalRecords: joinedResults.length,
+         recordsWithGeometry: joinedResults.filter(r: any => r.geometry !== null).length,
+         recordsWithoutGeometry: joinedResults.filter(r: any => r.geometry === null).length,
+         geometryTypes: [...new Set(joinedResults.map(r: any => r.geometry?.type).filter(Boolean))],
+         firstRecord: joinedResults[0] ? {
+           area_id: joinedResults[0].area_id,
+           area_name: joinedResults[0].area_name,
+           hasGeometry: joinedResults[0].geometry !== null,
+           geometryType: joinedResults[0].geometry?.type,
+           geometryCoords: joinedResults[0].geometry?.coordinates ? 'Present' : 'Missing',
@@ lines 2381-2396 @@
-         } : 'No records'
-       });
- 
-       if (joinedResults.filter(r => r.geometry !== null).length === 0) {
-         console.error('[AnalysisEngine] 🔥 CRITICAL: NO RECORDS WITH GEOMETRY AFTER JOIN - VISUALIZATION WILL FAIL');
-         console.error('[AnalysisEngine] Sample analysis IDs:', analysisResult.data.records.slice(0, 5).map(r => r.area_id || (r as any).ID || 'no-id'));
-         console.error('[AnalysisEngine] Sample boundary IDs:', geographicFeatures.slice(0, 5).map(f => f.properties?.ID || 'no-id'));
-       }
- 
-       console.log('[AnalysisEngine] Enhanced results created:', {
-         totalRecords: joinedResults.length,
-         withRealGeometry: joinedResults.filter(r => r.geometry?.type === 'Polygon').length,
-         withFallbackGeometry: joinedResults.filter(r => r.geometry?.type === 'Point').length,
-         sampleRecord: joinedResults[0] ? {
-           area_name: joinedResults[0].area_name,
-           value: joinedResults[0].value,
---
+         } : 'No records'
+       });
+ 
+       if (joinedResults.filter(r: any => r.geometry !== null).length === 0) {
+         console.error('[AnalysisEngine] 🔥 CRITICAL: NO RECORDS WITH GEOMETRY AFTER JOIN - VISUALIZATION WILL FAIL');
+         console.error('[AnalysisEngine] Sample analysis IDs:', analysisResult.data.records.slice(0, 5).map(r: any => r.area_id || (r as any).ID || 'no-id'));
+         console.error('[AnalysisEngine] Sample boundary IDs:', geographicFeatures.slice(0, 5).map(f: any => f.properties?.ID || 'no-id'));
+       }
+ 
+       console.log('[AnalysisEngine] Enhanced results created:', {
+         totalRecords: joinedResults.length,
+         withRealGeometry: joinedResults.filter(r: any => r.geometry?.type === 'Polygon').length,
+         withFallbackGeometry: joinedResults.filter(r: any => r.geometry?.type === 'Point').length,
+         sampleRecord: joinedResults[0] ? {
+           area_name: joinedResults[0].area_name,
+           value: joinedResults[0].value,
+           hasGeometry: !!joinedResults[0].geometry
+         } : null
+       });
@@ lines 2439-2445 @@
-         console.log('🎯 [CLUSTERING] Config:', analysisOptions.clusterConfig);
-         console.log('🎯 [CLUSTERING] Records before clustering:', {
-           count: enhancedAnalysisResult.data.records.length,
-           hasGeometry: enhancedAnalysisResult.data.records.filter(r => r.geometry).length,
-           sampleGeometry: enhancedAnalysisResult.data.records[0]?.geometry?.type
-         });
-         
---
+         console.log('🎯 [CLUSTERING] Config:', analysisOptions.clusterConfig);
+         console.log('🎯 [CLUSTERING] Records before clustering:', {
+           count: enhancedAnalysisResult.data.records.length,
+           hasGeometry: enhancedAnalysisResult.data.records.filter(r: any => r.geometry).length,
+           sampleGeometry: enhancedAnalysisResult.data.records[0]?.geometry?.type
+         });
+         
+         try {
+           // Get clustering service instance
+           const clusteringService = analysisEngine.engine.getClusteringService();
@@ lines 2527-2537 @@
-         console.log('🎯 [CLUSTERING] Clearing existing layers before creating cluster visualization');
-         
-         // Remove any existing analysis layers to prevent conflicts
-         const existingLayers = currentMapView.map.layers.toArray().filter(layer => 
-           layer.id && (layer.id.includes('analysis') || layer.id.includes('layer'))
-         );
-         
-         existingLayers.forEach(layer => {
-           console.log('🎯 [CLUSTERING] Removing existing layer:', layer.id);
-           currentMapView.map.remove(layer);
-         });
---
+         console.log('🎯 [CLUSTERING] Clearing existing layers before creating cluster visualization');
+         
+         // Remove any existing analysis layers to prevent conflicts
+         const existingLayers = currentMapView.map.layers.toArray().filter(layer: any => 
+           layer.id && (layer.id.includes('analysis') || layer.id.includes('layer'))
+         );
+         
+         existingLayers.forEach(layer: any => {
+           console.log('🎯 [CLUSTERING] Removing existing layer:', layer.id);
+           currentMapView.map.remove(layer);
+         });
+       }
+       
+       if (!finalAnalysisResult.visualization) {
@@ lines 2669-2676 @@
-         ]);
-         
-         const geometries = geographicFeatures
-           .filter(f => f?.geometry)
-           .map(f => f!.geometry);
-           
-         if (geometries.length > 0) {
-           const union = geometryEngine.union(geometries as any);
---
+         ]);
+         
+         const geometries = geographicFeatures
+           .filter(f: any => f?.geometry)
+           .map(f: any => f!.geometry);
+           
+         if (geometries.length > 0) {
+           const union = geometryEngine.union(geometries as any);
+           if (union && union.extent) {
+             currentMapView.goTo(union.extent.expand(1.2), {
+               duration: 1200,
@@ lines 2683-2689 @@
-         }
-       }
- 
-       const validFeatures = geographicFeatures.filter(f => f !== null) as GeospatialFeature[];
-       
-       // CRITICAL FIX: Don't call handleFeaturesFound for AnalysisEngine results
-       // This was causing the visualization to be cleared after being created
---
+         }
+       }
+ 
+       const validFeatures = geographicFeatures.filter(f: any => f !== null) as GeospatialFeature[];
+       
+       // CRITICAL FIX: Don't call handleFeaturesFound for AnalysisEngine results
+       // This was causing the visualization to be cleared after being created
+       console.log('[AnalysisEngine] 🚫 SKIPPING handleFeaturesFound to preserve visualization');
+       console.log('[AnalysisEngine] Features would have been:', validFeatures.length);
+       
@@ lines 2707-2713 @@
-         console.log('[AnalysisEngine] Generating narrative with Claude');
-         
-         // Debug the top 3 records being sent to Claude
-         console.log('[Claude] Top 3 records being sent:', finalAnalysisResult?.data?.records?.slice(0, 3).map(r => ({
-           area_name: r.area_name,
-           area_id: r.area_id,
-           competitive_score: r.value,
---
+         console.log('[AnalysisEngine] Generating narrative with Claude');
+         
+         // Debug the top 3 records being sent to Claude
+         console.log('[Claude] Top 3 records being sent:', finalAnalysisResult?.data?.records?.slice(0, 3).map(r: any => ({
+           area_name: r.area_name,
+           area_id: r.area_id,
+           competitive_score: r.value,
+           rank: r.rank,
+           cluster_id: r.cluster_id,
+           is_clustered: finalAnalysisResult?.data?.isClustered
@@ lines 2716-2722 @@
-           is_clustered: finalAnalysisResult?.data?.isClustered
-         })));
-         
-         setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s => 
-           s.id === 'narrative_generation' ? { ...s, message: 'Preparing data for narrative analysis...' } : s
-         ));
- 
---
+           is_clustered: finalAnalysisResult?.data?.isClustered
+         })));
+         
+         setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s: any => 
+           s.id === 'narrative_generation' ? { ...s, message: 'Preparing data for narrative analysis...' } : s
+         ));
+ 
+         // Save the endpoint for follow-up questions
+         setLastAnalysisEndpoint(finalAnalysisResult.endpoint);
+         
@@ lines 2724-2730 @@
-         setLastAnalysisEndpoint(finalAnalysisResult.endpoint);
-         
-         // Use existing Claude integration with enhanced analysis result
-         const targetPretty = TARGET_OPTIONS.find(opt => opt.value === currentTarget)?.label || 'Performance';
-         
-         // Check if this is clustered data and adjust the prompt accordingly
-         const isClusteredAnalysis = finalAnalysisResult?.data?.summary && finalAnalysisResult.data.summary.trim().length > 0;
---
+         setLastAnalysisEndpoint(finalAnalysisResult.endpoint);
+         
+         // Use existing Claude integration with enhanced analysis result
+         const targetPretty = TARGET_OPTIONS.find(opt: any => opt.value === currentTarget)?.label || 'Performance';
+         
+         // Check if this is clustered data and adjust the prompt accordingly
+         const isClusteredAnalysis = finalAnalysisResult?.data?.summary && finalAnalysisResult.data.summary.trim().length > 0;
+         const hasClusterAnalysis = isClusteredAnalysis && finalAnalysisResult.data.isClustered;
+         
+         console.log('🎯 [CLAUDE PAYLOAD] isClusteredAnalysis:', isClusteredAnalysis);
@@ lines 2849-2855 @@
-                 
-                 // Extract top SHAP features for this area
-                 const shapFeatures: Record<string, number> = {};
-                 Object.keys(result.properties || result).forEach(key => {
-                   if (key.startsWith('shap_') && Math.abs((result.properties || result)[key]) > 0.1) {
-                     const featureName = key.replace('shap_', '');
-                     shapFeatures[featureName] = (result.properties || result)[key];
---
+                 
+                 // Extract top SHAP features for this area
+                 const shapFeatures: Record<string, number> = {};
+                 Object.keys(result.properties || result).forEach(key: any => {
+                   if (key.startsWith('shap_') && Math.abs((result.properties || result)[key]) > 0.1) {
+                     const featureName = key.replace('shap_', '');
+                     shapFeatures[featureName] = (result.properties || result)[key];
+                   }
+                 });
+                 
@@ lines 3102-3108 @@
-       }
- 
-       // Complete narrative generation step
-       setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s => 
-         s.id === 'narrative_generation' ? { 
-           ...s, 
-           status: 'complete', 
---
+       }
+ 
+       // Complete narrative generation step
+       setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s: any => 
+         s.id === 'narrative_generation' ? { 
+           ...s, 
+           status: 'complete', 
+           message: narrativeContent ? 'Narrative analysis complete' : 'Analysis complete (using analysis data)' 
+         } : s
+       ));
@@ lines 3132-3138 @@
-       const finalContent = fallbackWarning + baseFinalContent;
-       
-       // Update message with streaming content
-       setMessages((prev: LocalChatMessage[]) => prev.map(msg =>
-         msg.id === assistantMessageId
-           ? { 
-               ...msg, 
---
+       const finalContent = fallbackWarning + baseFinalContent;
+       
+       // Update message with streaming content
+       setMessages((prev: LocalChatMessage[]) => prev.map(msg: any =>
+         msg.id === assistantMessageId
+           ? { 
+               ...msg, 
+               content: finalContent, 
+               metadata: { 
+                 ...msg.metadata, 
@@ lines 3222-3228 @@
-       const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
-       setError(errorMessage);
-       
-   setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s => {
-         if (s.status === 'processing') {
-           return { ...s, status: 'error', message: errorMessage };
-         }
---
+       const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
+       setError(errorMessage);
+       
+   setProcessingSteps((prev: GeoProcessingStep[]) => prev.map(s: any => {
+         if (s.status === 'processing') {
+           return { ...s, status: 'error', message: errorMessage };
+         }
+         if (currentProcessingStep && s.id === currentProcessingStep) {
+           return { ...s, status: 'error', message: errorMessage };
+         }
@@ lines 3236-3242 @@
-       setIsProcessing(false);
-       setCurrentProcessingStep(null);
-       
-       setMessages((prev: ChatMessage[]) => prev.map(msg =>
-         msg.id === assistantMessageId ? {
-           ...msg,
-           content: `Sorry, I encountered an error while processing your query: ${errorMessage}`,
---
+       setIsProcessing(false);
+       setCurrentProcessingStep(null);
+       
+       setMessages((prev: ChatMessage[]) => prev.map(msg: any =>
+         msg.id === assistantMessageId ? {
+           ...msg,
+           content: `Sorry, I encountered an error while processing your query: ${errorMessage}`,
+           metadata: { ...msg.metadata, error: errorMessage, isStreaming: false }
+         } : msg
+       ));
@@ lines 3347-3358 @@
-               primaryId,
-               rawZip,
-               recordZip,
-               sampleBoundaryIds: geographicFeatures.slice(0, 3).map(f => f?.properties?.ID)
-             });
-           }
-           
-           // Find matching boundary by ID (supports both ZIP codes and FSAs)
-           const zipFeature = geographicFeatures.find(f => {
-             if (!f?.properties) return false;
-             
-             // For FSAs (3 chars: letter-digit-letter), match without padding
---
+               primaryId,
+               rawZip,
+               recordZip,
+               sampleBoundaryIds: geographicFeatures.slice(0, 3).map(f: any => f?.properties?.ID)
+             });
+           }
+           
+           // Find matching boundary by ID (supports both ZIP codes and FSAs)
+           const zipFeature = geographicFeatures.find(f: any => {
+             if (!f?.properties) return false;
+             
+             // For FSAs (3 chars: letter-digit-letter), match without padding
+             if (isFSA) {
+               return (
+                 String(f.properties.ID || '').toUpperCase() === recordZip ||
@@ lines 3456-3462 @@
-         console.log('[UnifiedWorkflow] Visualization has legend:', !!analysisResult.visualization?.legend);
-   console.log('[UnifiedWorkflow] Visualization legend title:', (analysisResult.visualization as any)?.legend?.title);
-         
-         const recordsWithGeometry = joinedResults.filter(r => r.geometry).length;
-         const recordsWithoutGeometry = joinedResults.length - recordsWithGeometry;
-         
-         console.log('[UnifiedWorkflow] ✅ Geometry join complete:', {
---
+         console.log('[UnifiedWorkflow] Visualization has legend:', !!analysisResult.visualization?.legend);
+   console.log('[UnifiedWorkflow] Visualization legend title:', (analysisResult.visualization as any)?.legend?.title);
+         
+         const recordsWithGeometry = joinedResults.filter(r: any => r.geometry).length;
+         const recordsWithoutGeometry = joinedResults.length - recordsWithGeometry;
+         
+         console.log('[UnifiedWorkflow] ✅ Geometry join complete:', {
+           totalRecords: joinedResults.length,
+           recordsWithGeometry,
+           recordsWithoutGeometry,
@@ lines 3464-3473 @@
-           recordsWithGeometry,
-           recordsWithoutGeometry,
-           successRate: `${((recordsWithGeometry / joinedResults.length) * 100).toFixed(1)}%`,
-           sampleRecordWithGeometry: joinedResults.find(r => r.geometry) ? {
-             areaId: joinedResults.find(r => r.geometry)?.area_id,
-             hasGeometry: !!joinedResults.find(r => r.geometry)?.geometry,
-             geometryType: joinedResults.find(r => r.geometry)?.geometry?.type
-           } : 'No records with geometry found'
-         });
-         
---
+           recordsWithGeometry,
+           recordsWithoutGeometry,
+           successRate: `${((recordsWithGeometry / joinedResults.length) * 100).toFixed(1)}%`,
+           sampleRecordWithGeometry: joinedResults.find(r: any => r.geometry) ? {
+             areaId: joinedResults.find(r: any => r.geometry)?.area_id,
+             hasGeometry: !!joinedResults.find(r: any => r.geometry)?.geometry,
+             geometryType: joinedResults.find(r: any => r.geometry)?.geometry?.type
+           } : 'No records with geometry found'
+         });
+         
+         // CRITICAL: Log if no geometries were successfully joined
+         if (recordsWithGeometry === 0) {
+           console.error('[UnifiedWorkflow] ❌ CRITICAL: NO GEOMETRIES JOINED! This will cause visualization failure.');
@@ lines 3510-3516 @@
-     
-     // Update features for chat context (after geometry join)
-     if (analysisResult.data?.records) {
-       const features = analysisResult.data.records.map((record, index) => ({
-         ...record,
-         id: record.area_id || `feature_${index}`,
-         geometry: record.geometry || null
---
+     
+     // Update features for chat context (after geometry join)
+     if (analysisResult.data?.records) {
+       const features = analysisResult.data.records.map((record: any, index: any) => ({
+         ...record,
+         id: record.area_id || `feature_${index}`,
+         geometry: record.geometry || null
+       }));
+       
+       onFeaturesFound(features);
@@ lines 3675-3681 @@
-   console.log('[GeospatialChat] isInfographicsOpen:', isInfographicsOpen);
- 
-   const handleVisualizationUpdate = async (messageId: string, options: any) => {
-     const message = messages.find(m => m.id === messageId);
-     if (!message || !message.metadata?.analysisResult) {
-       toast({ title: "Update Failed", description: "Original analysis data not found.", variant: "destructive" });
-       return;
---
+   console.log('[GeospatialChat] isInfographicsOpen:', isInfographicsOpen);
+ 
+   const handleVisualizationUpdate = async (messageId: string, options: any) => {
+     const message = messages.find(m: any => m.id === messageId);
+     if (!message || !message.metadata?.analysisResult) {
+       toast({ title: "Update Failed", description: "Original analysis data not found.", variant: "destructive" });
+       return;
+     }
+   
+     // Retrieve original features directly from the message's metadata
@@ lines 3768-3774 @@
-           const claudeJson = await claudeResp.json();
-           const newContent = claudeJson?.content;
-           if (newContent) {
-             setMessages((prev: LocalChatMessage[]) => prev.map(m => m.id === messageId ? { 
-             ...m, 
-             content: newContent,
-             metadata: { ...m.metadata, isStreaming: false }
---
+           const claudeJson = await claudeResp.json();
+           const newContent = claudeJson?.content;
+           if (newContent) {
+             setMessages((prev: LocalChatMessage[]) => prev.map(m: any => m.id === messageId ? { 
+             ...m, 
+             content: newContent,
+             metadata: { ...m.metadata, isStreaming: false }
+           } : m));
+           }
+         }
@@ lines 3966-3972 @@
-         onExportData={handleExportData}
-         onSHAPChart={handleSHAPChart}
-         onInfographicsClick={handleInfographicsClick}
-         onReplyClick={(messageId) => {
-           setReplyToMessageId(messageId);
-           setReplyInput('');
-                                         setIsReplyDialogOpen(true);
---
+         onExportData={handleExportData}
+         onSHAPChart={handleSHAPChart}
+         onInfographicsClick={handleInfographicsClick}
+         onReplyClick={(messageId: any) => {
+           setReplyToMessageId(messageId);
+           setReplyInput('');
+                                         setIsReplyDialogOpen(true);
+                                       }}
+         onCustomizeVisualization={handleCustomizeVisualization}
+         onZoomToFeature={handleZoomToFeature}
@@ lines 4140-4146 @@
-                       </TooltipProvider>
-                       <DialogContent className="max-w-2xl min-h-[60vh] max-h-[80vh] overflow-y-auto theme-bg-primary rounded-xl shadow-lg" aria-describedby="query-dialog-description">
-                         <QueryDialog
-                           onQuestionSelect={(question) => {
-                                       // Check if we have existing analysis context - if so, treat as chat
-                                       const hasExistingContext = features.length > 0 || currentVisualizationLayer.current;
-                                       console.log('[QueryDialog] Processing predefined question:', {
---
+                       </TooltipProvider>
+                       <DialogContent className="max-w-2xl min-h-[60vh] max-h-[80vh] overflow-y-auto theme-bg-primary rounded-xl shadow-lg" aria-describedby="query-dialog-description">
+                         <QueryDialog
+                           onQuestionSelect={(question: any) => {
+                                       // Check if we have existing analysis context - if so, treat as chat
+                                       const hasExistingContext = features.length > 0 || currentVisualizationLayer.current;
+                                       console.log('[QueryDialog] Processing predefined question:', {
+                                         question,
+                                         hasExistingContext,
+                                         featuresCount: features.length,
@@ lines 4296-4308 @@
-                                   { className: 'h-3 w-3 mr-1' }
-                                 )}
-                                 <span className="truncate">
-                                   {personaMetadata.find(p => p.id === selectedPersona)?.name || 'Strategist'}
-                                 </span>
-                               </Button>
-                             </DialogTrigger>
-                           </TooltipTrigger>
-                           <TooltipContent side="top" className="theme-bg-primary">
-                             <p>Select AI persona: {personaMetadata.find(p => p.id === selectedPersona)?.name || 'Strategist'}</p>
-                           </TooltipContent>
-                         </Tooltip>
-                       </TooltipProvider>
---
+                                   { className: 'h-3 w-3 mr-1' }
+                                 )}
+                                 <span className="truncate">
+                                   {personaMetadata.find(p: any => p.id === selectedPersona)?.name || 'Strategist'}
+                                 </span>
+                               </Button>
+                             </DialogTrigger>
+                           </TooltipTrigger>
+                           <TooltipContent side="top" className="theme-bg-primary">
+                             <p>Select AI persona: {personaMetadata.find(p: any => p.id === selectedPersona)?.name || 'Strategist'}</p>
+                           </TooltipContent>
+                         </Tooltip>
+                       </TooltipProvider>
+                       <DialogContent className="max-w-lg theme-bg-primary" aria-describedby="persona-dialog-description">
+                         <DialogHeader>
+                           <DialogTitle>Select AI Persona</DialogTitle>
@@ lines 4314-4320 @@
-                           </p>
-                         </DialogHeader>
-                         <div className="grid grid-cols-1 gap-3 mt-4">
-                           {personaMetadata.map((persona) => (
-                             <Button
-                               key={persona.id}
-                               variant={selectedPersona === persona.id ? 'default' : 'outline'}
---
+                           </p>
+                         </DialogHeader>
+                         <div className="grid grid-cols-1 gap-3 mt-4">
+                           {personaMetadata.map((persona: any) => (
+                             <Button
+                               key={persona.id}
+                               variant={selectedPersona === persona.id ? 'default' : 'outline'}
+                               size="sm"
+                               className="flex items-start gap-3 p-4 h-auto text-left justify-start w-full whitespace-normal"
+                               onClick={() => {
@@ lines 4420-4426 @@
-                       <div className="mb-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
-                         <AnalysisEndpointSelector
-                           selectedEndpoint={selectedEndpoint === 'auto' ? undefined : selectedEndpoint}
-                           onEndpointSelect={(endpoint) => {
-                             console.log('[ENDPOINT SELECTION] 🎯 Endpoint selected:', {
-                               previousEndpoint: selectedEndpoint,
-                               newEndpoint: endpoint,
---
+                       <div className="mb-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
+                         <AnalysisEndpointSelector
+                           selectedEndpoint={selectedEndpoint === 'auto' ? undefined : selectedEndpoint}
+                           onEndpointSelect={(endpoint: any) => {
+                             console.log('[ENDPOINT SELECTION] 🎯 Endpoint selected:', {
+                               previousEndpoint: selectedEndpoint,
+                               newEndpoint: endpoint,
+                               timestamp: new Date().toISOString()
+                             });
+                             setSelectedEndpoint(endpoint);
@@ lines 4481-4487 @@
-                       ref={textareaRef}
-                       value={inputQuery}
-                       onChange={handleInputChange}
-                       onKeyDown={(e) => {
-                         if (e.key === 'Enter' && !e.shiftKey) {
-                           e.preventDefault();
-                           if (!isProcessing && inputQuery.trim()) {
---
+                       ref={textareaRef}
+                       value={inputQuery}
+                       onChange={handleInputChange}
+                       onKeyDown={(e: any) => {
+                         if (e.key === 'Enter' && !e.shiftKey) {
+                           e.preventDefault();
+                           if (!isProcessing && inputQuery.trim()) {
+                             analyzeButtonRef.current?.click();
+                           }
+                         }
@@ lines 4588-4594 @@
-               <div className="space-y-2">
-                 <div className="text-xs font-medium text-gray-700">💡 Try asking:</div>
-                 <div className="flex flex-wrap gap-1">
-                   {getSmartSuggestions().slice(0, 2).map((suggestion, index) => (
-                     <button
-                       key={index}
-                       onClick={() => handleSubmit(suggestion, 'reply')}
---
+               <div className="space-y-2">
+                 <div className="text-xs font-medium text-gray-700">💡 Try asking:</div>
+                 <div className="flex flex-wrap gap-1">
+                   {getSmartSuggestions().slice(0, 2).map((suggestion: any, index: any) => (
+                     <button
+                       key={index}
+                       onClick={() => handleSubmit(suggestion, 'reply')}
+                       className="text-xs px-2 py-1 bg-green-50 hover:bg-green-100 text-green-700 rounded border border-green-200 transition-colors"
+                       disabled={isProcessing}
+                     >
@@ lines 4603-4609 @@
-             )}
-             
-             <ChatBar 
-               onSend={(query) => handleSubmit(query, 'reply')} 
-               placeholder={getContextualPlaceholder()}
-               disabled={isProcessing}
-             />
---
+             )}
+             
+             <ChatBar 
+               onSend={(query: any) => handleSubmit(query, 'reply')} 
+               placeholder={getContextualPlaceholder()}
+               disabled={isProcessing}
+             />
+           </div>
+         )}
+       </div>
@@ lines 4711-4720 @@
-         <div className="py-4 space-y-4">
-           <Textarea 
-             value={replyInput}
-             onChange={(e) => setReplyInput(e.target.value)}
-             placeholder="Type your reply here..."
-             className="w-full h-24 resize-none text-xs"
-             onKeyDown={(e) => {
-               if (e.key === 'Enter' && !e.shiftKey) {
-                 e.preventDefault();
-                 if (replyInput.trim()) {
---
+         <div className="py-4 space-y-4">
+           <Textarea 
+             value={replyInput}
+             onChange={(e: any) => setReplyInput(e.target.value)}
+             placeholder="Type your reply here..."
+             className="w-full h-24 resize-none text-xs"
+             onKeyDown={(e: any) => {
+               if (e.key === 'Enter' && !e.shiftKey) {
+                 e.preventDefault();
+                 if (replyInput.trim()) {
+                   handleSubmit(replyInput, 'reply');
+                   setIsReplyDialogOpen(false);
+                   setReplyInput('');
@@ lines 4793-4799 @@
-     })()}
- 
-     {isVizPanelOpen && activeVizMessageId && (() => {
-       const activeMessage = messages.find(m => m.id === activeVizMessageId);
-       const vizLayer = activeMessage?.metadata?.visualizationResult?.layer;
- 
-       if (vizLayer) {
---
+     })()}
+ 
+     {isVizPanelOpen && activeVizMessageId && (() => {
+       const activeMessage = messages.find(m: any => m.id === activeVizMessageId);
+       const vizLayer = activeMessage?.metadata?.visualizationResult?.layer;
+ 
+       if (vizLayer) {
+         // The CustomVisualizationPanel expects a 'LayerConfig' object, which is not what we have.
+         // The vizLayer is an esri.FeatureLayer. We create a mock config object for the panel.
+         const layerConfigForPanel = {
@@ lines 4813-4819 @@
-             <CustomVisualizationPanel
-               layer={layerConfigForPanel as any} // Casting as the panel's internal type isn't exported.
-               onClose={() => setIsVizPanelOpen(false)}
-               onVisualizationUpdate={(options) => {
-                 if (activeVizMessageId) {
-                   handleVisualizationUpdate(activeVizMessageId, options);
-                 }
---
+             <CustomVisualizationPanel
+               layer={layerConfigForPanel as any} // Casting as the panel's internal type isn't exported.
+               onClose={() => setIsVizPanelOpen(false)}
+               onVisualizationUpdate={(options: any) => {
+                 if (activeVizMessageId) {
+                   handleVisualizationUpdate(activeVizMessageId, options);
+                 }
+               }}
+             />
+           </div>
@@ lines 4840-4846 @@
-         {currentLayerConfigForViz && activeVizMessageId && (
-           <CustomVisualizationPanel
-             layer={currentLayerConfigForViz}
-             onVisualizationUpdate={(cfg) => handleVisualizationUpdate(activeVizMessageId, cfg)}
-             onClose={() => setIsVizPanelOpen(false)}
-           />
-         )}
---
+         {currentLayerConfigForViz && activeVizMessageId && (
+           <CustomVisualizationPanel
+             layer={currentLayerConfigForViz}
+             onVisualizationUpdate={(cfg: any) => handleVisualizationUpdate(activeVizMessageId, cfg)}
+             onClose={() => setIsVizPanelOpen(false)}
+           />
+         )}
+       </DialogContent>
+     </Dialog>
+ 


*** FILE: lib/analysis/statsCalculator.ts
@@ lines 151-162 @@
-   };
- 
-   // Sort data by score descending
-   const sorted = [...data].sort((a, b) => getScore(b) - getScore(a));
-   
-   // Calculate statistics
-   const count = data.length;
-   const scores = sorted.map(d => getScore(d));
-   const mean = scores.reduce((a, b) => a + b, 0) / count;
-   
-   // Median
-   const median = count % 2 === 0
---
+   };
+ 
+   // Sort data by score descending
+   const sorted = [...data].sort((a: any, b: any) => getScore(b) - getScore(a));
+   
+   // Calculate statistics
+   const count = data.length;
+   const scores = sorted.map(d: any => getScore(d));
+   const mean = scores.reduce((a: any, b: any) => a + b, 0) / count;
+   
+   // Median
+   const median = count % 2 === 0
+     ? (scores[Math.floor(count / 2) - 1] + scores[Math.floor(count / 2)]) / 2
+     : scores[Math.floor(count / 2)];
+   
@@ lines 164-170 @@
-     : scores[Math.floor(count / 2)];
-   
-   // Standard deviation
-   const variance = scores.reduce((acc, val) => 
-     acc + Math.pow(val - mean, 2), 0) / count;
-   const stdDev = Math.sqrt(variance);
-   
---
+     : scores[Math.floor(count / 2)];
+   
+   // Standard deviation
+   const variance = scores.reduce((acc: any, val: any) => 
+     acc + Math.pow(val - mean, 2), 0) / count;
+   const stdDev = Math.sqrt(variance);
+   
+   // Min/Max
+   const minRecord = sorted[count - 1];
+   const maxRecord = sorted[0];
@@ lines 175-185 @@
-   // Calculate coverage if available
-   const coverage: any = {};
-   if (data[0]?.properties?.total_population !== undefined) {
-     coverage.totalPopulation = data.reduce((sum, d) => 
-       sum + (d.properties?.total_population || 0), 0);
-   }
-   if (data[0]?.properties?.area_sqmi !== undefined) {
-     coverage.totalArea = data.reduce((sum, d) => 
-       sum + (d.properties?.area_sqmi || 0), 0);
-   }
-   
---
+   // Calculate coverage if available
+   const coverage: any = {};
+   if (data[0]?.properties?.total_population !== undefined) {
+     coverage.totalPopulation = data.reduce((sum: any, d: any) => 
+       sum + (d.properties?.total_population || 0), 0);
+   }
+   if (data[0]?.properties?.area_sqmi !== undefined) {
+     coverage.totalArea = data.reduce((sum: any, d: any) => 
+       sum + (d.properties?.area_sqmi || 0), 0);
+   }
+   
+   return {
+     count,
+     mean,
@@ lines 196-206 @@
-       area: getAreaName(maxRecord), 
-       score: getScore(maxRecord) 
-     },
-     top5: sorted.slice(0, Math.min(5, count)).map(d => ({ 
-       area: getAreaName(d), 
-       score: getScore(d) 
-     })),
-     bottom5: sorted.slice(-Math.min(5, count)).reverse().map(d => ({ 
-       area: getAreaName(d), 
-       score: getScore(d) 
-     })),
---
+       area: getAreaName(maxRecord), 
+       score: getScore(maxRecord) 
+     },
+     top5: sorted.slice(0, Math.min(5, count)).map(d: any => ({ 
+       area: getAreaName(d), 
+       score: getScore(d) 
+     })),
+     bottom5: sorted.slice(-Math.min(5, count)).reverse().map(d: any => ({ 
+       area: getAreaName(d), 
+       score: getScore(d) 
+     })),
+     coverage
+   };
+ }
@@ lines 248-256 @@
-            'Unknown';
-   };
- 
-   const sorted = [...data].sort((a, b) => getScore(a) - getScore(b));
-   const n = sorted.length;
-   const scores = sorted.map(d => getScore(d));
-   
-   // Calculate quartiles
-   const q1Index = Math.floor(n * 0.25);
---
+            'Unknown';
+   };
+ 
+   const sorted = [...data].sort((a: any, b: any) => getScore(a) - getScore(b));
+   const n = sorted.length;
+   const scores = sorted.map(d: any => getScore(d));
+   
+   // Calculate quartiles
+   const q1Index = Math.floor(n * 0.25);
+   const q2Index = Math.floor(n * 0.50);
+   const q3Index = Math.floor(n * 0.75);
+   
@@ lines 267-284 @@
-   const upperBound = q3 + 1.5 * iqr;
-   
-   const outliers = data
-     .filter(d => {
-       const score = getScore(d);
-       return score < lowerBound || score > upperBound;
-     })
-     .map(d => ({
-       area: getAreaName(d),
-       score: getScore(d),
-       type: getScore(d) > upperBound ? 'high' : 'low' as 'high' | 'low'
-     }));
-   
-   // Determine distribution shape
-   const mean = scores.reduce((a, b) => a + b, 0) / n;
-   const skewness = calculateSkewness(scores, mean, stdDev(scores));
-   
-   let shape: Distribution['shape'] = 'normal';
---
+   const upperBound = q3 + 1.5 * iqr;
+   
+   const outliers = data
+     .filter(d: any => {
+       const score = getScore(d);
+       return score < lowerBound || score > upperBound;
+     })
+     .map(d: any => ({
+       area: getAreaName(d),
+       score: getScore(d),
+       type: getScore(d) > upperBound ? 'high' : 'low' as 'high' | 'low'
+     }));
+   
+   // Determine distribution shape
+   const mean = scores.reduce((a: any, b: any) => a + b, 0) / n;
+   const skewness = calculateSkewness(scores, mean, stdDev(scores));
+   
+   let shape: Distribution['shape'] = 'normal';
+   if (Math.abs(skewness) < 0.5) {
+     shape = 'normal';
+   } else if (skewness > 0.5) {
@@ lines 305-312 @@
-     { min: 0, max: 50, label: 'Low (0-50)' }
-   ];
-   
-   const buckets = bucketDefs.map(bucket => {
-     const items = data.filter(d => {
-       const score = getScore(d);
-       return score >= bucket.min && score < bucket.max;
-     });
---
+     { min: 0, max: 50, label: 'Low (0-50)' }
+   ];
+   
+   const buckets = bucketDefs.map(bucket: any => {
+     const items = data.filter(d: any => {
+       const score = getScore(d);
+       return score >= bucket.min && score < bucket.max;
+     });
+     
+     return {
+       range: bucket.label,
@@ lines 317-325 @@
-       max: bucket.max,
-       count: items.length,
-       percentage: (items.length / n) * 100,
-       areas: items.slice(0, 3).map(d => getAreaName(d))
-     };
-   }).filter(b => b.count > 0);
-   
-   return {
-     quartiles: { q1, q2, q3 },
---
+       max: bucket.max,
+       count: items.length,
+       percentage: (items.length / n) * 100,
+       areas: items.slice(0, 3).map(d: any => getAreaName(d))
+     };
+   }).filter(b: any => b.count > 0);
+   
+   return {
+     quartiles: { q1, q2, q3 },
+     iqr,
+     outliers,
+     shape,
@@ lines 371-378 @@
- // Helper functions
- 
- function stdDev(scores: number[]): number {
-   const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
-   const variance = scores.reduce((acc, val) => 
-     acc + Math.pow(val - mean, 2), 0) / scores.length;
-   return Math.sqrt(variance);
- }
---
+ // Helper functions
+ 
+ function stdDev(scores: number[]): number {
+   const mean = scores.reduce((a: any, b: any) => a + b, 0) / scores.length;
+   const variance = scores.reduce((acc: any, val: any) => 
+     acc + Math.pow(val - mean, 2), 0) / scores.length;
+   return Math.sqrt(variance);
+ }
+ 
+ function calculateSkewness(scores: number[], mean: number, stdDev: number): number {
+   if (stdDev === 0) return 0;
@@ lines 380-386 @@
- function calculateSkewness(scores: number[], mean: number, stdDev: number): number {
-   if (stdDev === 0) return 0;
-   const n = scores.length;
-   const sum = scores.reduce((acc, val) => 
-     acc + Math.pow((val - mean) / stdDev, 3), 0);
-   return sum / n;
- }
---
+ function calculateSkewness(scores: number[], mean: number, stdDev: number): number {
+   if (stdDev === 0) return 0;
+   const n = scores.length;
+   const sum = scores.reduce((acc: any, val: any) => 
+     acc + Math.pow((val - mean) / stdDev, 3), 0);
+   return sum / n;
+ }
+ 
+ function detectBimodal(scores: number[]): boolean {
+   // Simple bimodal detection - check for two distinct peaks
@@ lines 388-394 @@
- function detectBimodal(scores: number[]): boolean {
-   // Simple bimodal detection - check for two distinct peaks
-   const histogram: { [key: number]: number } = {};
-   scores.forEach(score => {
-     const bucket = Math.floor(score);
-     histogram[bucket] = (histogram[bucket] || 0) + 1;
-   });
---
+ function detectBimodal(scores: number[]): boolean {
+   // Simple bimodal detection - check for two distinct peaks
+   const histogram: { [key: number]: number } = {};
+   scores.forEach(score: any => {
+     const bucket = Math.floor(score);
+     histogram[bucket] = (histogram[bucket] || 0) + 1;
+   });
+   
+   const peaks = Object.entries(histogram)
+     .filter(([_, count]) => count > scores.length * 0.1)
@@ lines 402-410 @@
- 
- function identifyClusters(data: any[]): Patterns['clusters'] {
-   // Simple clustering by score ranges
-   const high = data.filter(d => extractScore(d) >= 8);
-   const medium = data.filter(d => extractScore(d) >= 6 && extractScore(d) < 8);
-   const low = data.filter(d => extractScore(d) < 6);
-   
-   const clusters: Patterns['clusters'] = [];
-   
---
+ 
+ function identifyClusters(data: any[]): Patterns['clusters'] {
+   // Simple clustering by score ranges
+   const high = data.filter(d: any => extractScore(d) >= 8);
+   const medium = data.filter(d: any => extractScore(d) >= 6 && extractScore(d) < 8);
+   const low = data.filter(d: any => extractScore(d) < 6);
+   
+   const clusters: Patterns['clusters'] = [];
+   
+   if (high.length > 0) {
+     clusters.push({
+       name: 'High Performers',
@@ lines 412-418 @@
-     clusters.push({
-       name: 'High Performers',
-       size: high.length,
-       avgScore: high.reduce((sum, d) => sum + extractScore(d), 0) / high.length,
-       characteristics: ['Strong market position', 'High growth potential']
-     });
-   }
---
+     clusters.push({
+       name: 'High Performers',
+       size: high.length,
+       avgScore: high.reduce((sum: any, d: any) => sum + extractScore(d), 0) / high.length,
+       characteristics: ['Strong market position', 'High growth potential']
+     });
+   }
+   
+   if (medium.length > 0) {
+     clusters.push({
@@ lines 421-427 @@
-     clusters.push({
-       name: 'Steady Markets',
-       size: medium.length,
-       avgScore: medium.reduce((sum, d) => sum + extractScore(d), 0) / medium.length,
-       characteristics: ['Stable performance', 'Moderate opportunity']
-     });
-   }
---
+     clusters.push({
+       name: 'Steady Markets',
+       size: medium.length,
+       avgScore: medium.reduce((sum: any, d: any) => sum + extractScore(d), 0) / medium.length,
+       characteristics: ['Stable performance', 'Moderate opportunity']
+     });
+   }
+   
+   if (low.length > 0) {
+     clusters.push({
@@ lines 430-436 @@
-     clusters.push({
-       name: 'Emerging Areas',
-       size: low.length,
-       avgScore: low.reduce((sum, d) => sum + extractScore(d), 0) / low.length,
-       characteristics: ['Development potential', 'Higher risk']
-     });
-   }
---
+     clusters.push({
+       name: 'Emerging Areas',
+       size: low.length,
+       avgScore: low.reduce((sum: any, d: any) => sum + extractScore(d), 0) / low.length,
+       characteristics: ['Development potential', 'Higher risk']
+     });
+   }
+   
+   return clusters;
+ }
@@ lines 443-449 @@
-   
-   if (data.length === 0) return correlations;
-   
-   const scores = data.map(d => extractScore(d)).filter(s => s > 0);
-   if (scores.length === 0) return correlations;
-   
-   // Check multiple population field possibilities
---
+   
+   if (data.length === 0) return correlations;
+   
+   const scores = data.map(d: any => extractScore(d)).filter(s: any => s > 0);
+   if (scores.length === 0) return correlations;
+   
+   // Check multiple population field possibilities
+   const populationFields = [
+     'total_population',
+     'population', 
@@ lines 456-471 @@
-   ];
-   
-   for (const field of populationFields) {
-     const hasField = data.some(d => 
-       d.properties?.[field] !== undefined || 
-       d[field] !== undefined
-     );
-     
-     if (hasField) {
-       const popValues = data.map(d => {
-         const val = d.properties?.[field] || d[field] || 0;
-         return typeof val === 'number' ? val : parseFloat(val) || 0;
-       }).filter(v => v > 0);
-       
-       if (popValues.length > 1 && popValues.length === scores.length) {
-         const popCorr = calculateCorrelation(scores, popValues);
---
+   ];
+   
+   for (const field of populationFields) {
+     const hasField = data.some(d: any => 
+       d.properties?.[field] !== undefined || 
+       d[field] !== undefined
+     );
+     
+     if (hasField) {
+       const popValues = data.map(d: any => {
+         const val = d.properties?.[field] || d[field] || 0;
+         return typeof val === 'number' ? val : parseFloat(val) || 0;
+       }).filter(v: any => v > 0);
+       
+       if (popValues.length > 1 && popValues.length === scores.length) {
+         const popCorr = calculateCorrelation(scores, popValues);
+         if (!isNaN(popCorr) && popCorr !== 0) {
+           correlations.push({
+             factor: 'Population Density',
@@ lines 493-508 @@
-   ];
-   
-   for (const field of incomeFields) {
-     const hasField = data.some(d => 
-       d.properties?.[field] !== undefined || 
-       d[field] !== undefined
-     );
-     
-     if (hasField) {
-       const incomeValues = data.map(d => {
-         const val = d.properties?.[field] || d[field] || 0;
-         return typeof val === 'number' ? val : parseFloat(val) || 0;
-       }).filter(v => v > 0);
-       
-       if (incomeValues.length > 1 && incomeValues.length === scores.length) {
-         const incomeCorr = calculateCorrelation(scores, incomeValues);
---
+   ];
+   
+   for (const field of incomeFields) {
+     const hasField = data.some(d: any => 
+       d.properties?.[field] !== undefined || 
+       d[field] !== undefined
+     );
+     
+     if (hasField) {
+       const incomeValues = data.map(d: any => {
+         const val = d.properties?.[field] || d[field] || 0;
+         return typeof val === 'number' ? val : parseFloat(val) || 0;
+       }).filter(v: any => v > 0);
+       
+       if (incomeValues.length > 1 && incomeValues.length === scores.length) {
+         const incomeCorr = calculateCorrelation(scores, incomeValues);
+         if (!isNaN(incomeCorr) && incomeCorr !== 0) {
+           correlations.push({
+             factor: 'Median Income',
@@ lines 526-540 @@
-     return [];
-   }
-   
-   return correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
- }
- 
- function calculateCorrelation(x: number[], y: number[]): number {
-   const n = x.length;
-   if (n === 0 || n !== y.length) return 0;
-   
-   const meanX = x.reduce((a, b) => a + b, 0) / n;
-   const meanY = y.reduce((a, b) => a + b, 0) / n;
-   
-   let numerator = 0;
-   let denomX = 0;
---
+     return [];
+   }
+   
+   return correlations.sort((a: any, b: any) => Math.abs(b.correlation) - Math.abs(a.correlation));
+ }
+ 
+ function calculateCorrelation(x: number[], y: number[]): number {
+   const n = x.length;
+   if (n === 0 || n !== y.length) return 0;
+   
+   const meanX = x.reduce((a: any, b: any) => a + b, 0) / n;
+   const meanY = y.reduce((a: any, b: any) => a + b, 0) / n;
+   
+   let numerator = 0;
+   let denomX = 0;
+   let denomY = 0;
+   
+   for (let i = 0; i < n; i++) {
@@ lines 573-580 @@
- function detectGeographicConcentration(data: any[]): Patterns['trends'][0] | null {
-   // Simple geographic pattern detection
-   const highScoreAreas = data
-     .filter(d => (d.score || 0) >= 8)
-     .map(d => d.area_name || d.area_id || 'Unknown');
-   
-   if (highScoreAreas.length >= 3) {
-     return {
---
+ function detectGeographicConcentration(data: any[]): Patterns['trends'][0] | null {
+   // Simple geographic pattern detection
+   const highScoreAreas = data
+     .filter(d: any => (d.score || 0) >= 8)
+     .map(d: any => d.area_name || d.area_id || 'Unknown');
+   
+   if (highScoreAreas.length >= 3) {
+     return {
+       pattern: 'Geographic Concentration',
+       strength: highScoreAreas.length > 5 ? 'strong' : 'moderate',
+       areas: highScoreAreas.slice(0, 5)
@@ lines 588-603 @@
- }
- 
- function detectScoreClustering(data: any[]): Patterns['trends'][0] | null {
-   const scores = data.map(d => d.score || 0);
-   const stdDevValue = stdDev(scores);
-   const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
-   
-   // Check for tight clustering
-   if (stdDevValue < mean * 0.15) {
-     return {
-       pattern: 'Tight Score Clustering',
-       strength: 'strong',
-       areas: data.slice(0, 3).map(d => d.area_name || d.area_id || 'Unknown')
-     };
-   }
-   
---
+ }
+ 
+ function detectScoreClustering(data: any[]): Patterns['trends'][0] | null {
+   const scores = data.map(d: any => d.score || 0);
+   const stdDevValue = stdDev(scores);
+   const mean = scores.reduce((a: any, b: any) => a + b, 0) / scores.length;
+   
+   // Check for tight clustering
+   if (stdDevValue < mean * 0.15) {
+     return {
+       pattern: 'Tight Score Clustering',
+       strength: 'strong',
+       areas: data.slice(0, 3).map(d: any => d.area_name || d.area_id || 'Unknown')
+     };
+   }
+   
+   return null;
+ }
+ 
@@ lines 638-646 @@
-   // Strategic insights based on performance distribution
-   const performanceInsights = [];
-   if (allData && allData.length > 0) {
-     const highPerformers = allData.filter(d => extractScore(d) >= 70).length;
-     const moderatePerformers = allData.filter(d => extractScore(d) >= 50 && extractScore(d) < 70).length;
-     const developingMarkets = allData.filter(d => extractScore(d) >= 30 && extractScore(d) < 50).length;
-     
-     lines.push(`**Strategic Insights:**`);
-     
---
+   // Strategic insights based on performance distribution
+   const performanceInsights = [];
+   if (allData && allData.length > 0) {
+     const highPerformers = allData.filter(d: any => extractScore(d) >= 70).length;
+     const moderatePerformers = allData.filter(d: any => extractScore(d) >= 50 && extractScore(d) < 70).length;
+     const developingMarkets = allData.filter(d: any => extractScore(d) >= 30 && extractScore(d) < 50).length;
+     
+     lines.push(`**Strategic Insights:**`);
+     
+     if (highPerformers > 0) {
+       performanceInsights.push(`**${highPerformers}** high-performing markets (70+ score)`);
+     }
@@ lines 671-680 @@
-   } else {
-     // Fallback when no allData is available - show key performers as examples
-     if (stats.top5.length > 0) {
-       lines.push(`**Market Leaders** (top examples): ${stats.top5.slice(0, 3).map(area => `${area.area} (${area.score.toFixed(1)})`).join(', ')}`);
-     }
-     if (stats.bottom5.length > 0) {
-       lines.push(`**Development opportunities** (lower examples): ${stats.bottom5.slice(0, 2).map(area => `${area.area} (${area.score.toFixed(1)})`).join(', ')}`);
-     }
-   }
-   
---
+   } else {
+     // Fallback when no allData is available - show key performers as examples
+     if (stats.top5.length > 0) {
+       lines.push(`**Market Leaders** (top examples): ${stats.top5.slice(0, 3).map(area: any => `${area.area} (${area.score.toFixed(1)})`).join(', ')}`);
+     }
+     if (stats.bottom5.length > 0) {
+       lines.push(`**Development opportunities** (lower examples): ${stats.bottom5.slice(0, 2).map(area: any => `${area.area} (${area.score.toFixed(1)})`).join(', ')}`);
+     }
+   }
+   
+   return lines.join('\n');
+ }
+ 
@@ lines 733-741 @@
-   lines.push('');
-   
-   // Distribution analysis
-   const highAdvantageCount = allData?.filter(d => extractScore(d) > strongAdvantageThreshold).length || 0;
-   const highDisadvantageCount = allData?.filter(d => extractScore(d) < -strongAdvantageThreshold).length || 0;
-   const competitiveCount = allData?.filter(d => Math.abs(extractScore(d)) <= moderateAdvantageThreshold).length || 0;
-   
-   if (highAdvantageCount + highDisadvantageCount + competitiveCount > 0) {
-     lines.push(`**Market Distribution:**`);
---
+   lines.push('');
+   
+   // Distribution analysis
+   const highAdvantageCount = allData?.filter(d: any => extractScore(d) > strongAdvantageThreshold).length || 0;
+   const highDisadvantageCount = allData?.filter(d: any => extractScore(d) < -strongAdvantageThreshold).length || 0;
+   const competitiveCount = allData?.filter(d: any => Math.abs(extractScore(d)) <= moderateAdvantageThreshold).length || 0;
+   
+   if (highAdvantageCount + highDisadvantageCount + competitiveCount > 0) {
+     lines.push(`**Market Distribution:**`);
+     if (highAdvantageCount > 0) {
+       lines.push(`• **${highAdvantageCount}** markets where ${brand1Name} has strong advantages (>${strongAdvantageThreshold}%)`);
+     }
@@ lines 762-782 @@
-     };
-     
-     const sortedAreas = allData
-       .map(d => ({ area: getAreaName(d), score: extractScore(d) }))
-       .sort((a, b) => b.score - a.score);
-     
-     const topAdvantages = sortedAreas.filter(item => item.score > strongAdvantageThreshold).slice(0, 3);
-     const bottomAdvantages = sortedAreas.filter(item => item.score < -strongAdvantageThreshold).slice(-3).reverse();
-     const competitive = sortedAreas.filter(item => Math.abs(item.score) <= moderateAdvantageThreshold).slice(0, 2);
-     
-     if (topAdvantages.length > 0) {
-       lines.push(`• **${brand1Name} strongholds:** ${topAdvantages.map(item => `${item.area} (+${item.score.toFixed(1)}%)`).join(', ')}`);
-     }
-     if (bottomAdvantages.length > 0) {
-       lines.push(`• **${brand2Name} strongholds:** ${bottomAdvantages.map(item => `${item.area} (${item.score.toFixed(1)}%)`).join(', ')}`);
-     }
-     if (competitive.length > 0) {
-       lines.push(`• **Competitive battlegrounds:** ${competitive.map(item => `${item.area} (${item.score >= 0 ? '+' : ''}${item.score.toFixed(1)}%)`).join(', ')}`);
-     }
-   }
-   
---
+     };
+     
+     const sortedAreas = allData
+       .map(d: any => ({ area: getAreaName(d), score: extractScore(d) }))
+       .sort((a: any, b: any) => b.score - a.score);
+     
+     const topAdvantages = sortedAreas.filter(item: any => item.score > strongAdvantageThreshold).slice(0, 3);
+     const bottomAdvantages = sortedAreas.filter(item: any => item.score < -strongAdvantageThreshold).slice(-3).reverse();
+     const competitive = sortedAreas.filter(item: any => Math.abs(item.score) <= moderateAdvantageThreshold).slice(0, 2);
+     
+     if (topAdvantages.length > 0) {
+       lines.push(`• **${brand1Name} strongholds:** ${topAdvantages.map(item: any => `${item.area} (+${item.score.toFixed(1)}%)`).join(', ')}`);
+     }
+     if (bottomAdvantages.length > 0) {
+       lines.push(`• **${brand2Name} strongholds:** ${bottomAdvantages.map(item: any => `${item.area} (${item.score.toFixed(1)}%)`).join(', ')}`);
+     }
+     if (competitive.length > 0) {
+       lines.push(`• **Competitive battlegrounds:** ${competitive.map(item: any => `${item.area} (${item.score >= 0 ? '+' : ''}${item.score.toFixed(1)}%)`).join(', ')}`);
+     }
+   }
+   
+   return lines.join('\n');
+ }
+ 
@@ lines 804-810 @@
-   
-   if (dist.outliers.length > 0) {
-     lines.push(`**Outliers:** **${dist.outliers.length}** detected`);
-     dist.outliers.slice(0, 3).forEach(outlier => {
-       lines.push(`  • **${outlier.area}**: **${outlier.score.toFixed(2)}** (${outlier.type})`);
-     });
-   } else {
---
+   
+   if (dist.outliers.length > 0) {
+     lines.push(`**Outliers:** **${dist.outliers.length}** detected`);
+     dist.outliers.slice(0, 3).forEach(outlier: any => {
+       lines.push(`  • **${outlier.area}**: **${outlier.score.toFixed(2)}** (${outlier.type})`);
+     });
+   } else {
+     lines.push('**Outliers:** None detected');
+   }
+   
@@ lines 877-883 @@
-   
-   if (patterns.clusters.length > 0) {
-     lines.push('**Market Clusters:**');
-     patterns.clusters.forEach(cluster => {
-       lines.push(`• **${cluster.name}**: **${cluster.size}** areas (avg: **${cluster.avgScore.toFixed(2)}**)`);
-       if (cluster.characteristics.length > 0) {
-         lines.push(`  - ${cluster.characteristics.join(', ')}`);
---
+   
+   if (patterns.clusters.length > 0) {
+     lines.push('**Market Clusters:**');
+     patterns.clusters.forEach(cluster: any => {
+       lines.push(`• **${cluster.name}**: **${cluster.size}** areas (avg: **${cluster.avgScore.toFixed(2)}**)`);
+       if (cluster.characteristics.length > 0) {
+         lines.push(`  - ${cluster.characteristics.join(', ')}`);
+       }
+     });
+     lines.push('');
@@ lines 888-894 @@
-   
-   if (patterns.correlations.length > 0) {
-     lines.push('**Key Correlations:**');
-     patterns.correlations.slice(0, 3).forEach(corr => {
-       const sign = corr.correlation > 0 ? '+' : '';
-       lines.push(`• **${corr.factor}**: **${sign}${(corr.correlation * 100).toFixed(0)}%** (${corr.significance})`);
-     });
---
+   
+   if (patterns.correlations.length > 0) {
+     lines.push('**Key Correlations:**');
+     patterns.correlations.slice(0, 3).forEach(corr: any => {
+       const sign = corr.correlation > 0 ? '+' : '';
+       lines.push(`• **${corr.factor}**: **${sign}${(corr.correlation * 100).toFixed(0)}%** (${corr.significance})`);
+     });
+     lines.push('');
+   } else {
+     lines.push('**Key Correlations:** Insufficient temporal data for meaningful correlation analysis');
@@ lines 900-906 @@
-   
-   if (patterns.trends.length > 0) {
-     lines.push('**Emerging Trends:**');
-     patterns.trends.forEach(trend => {
-       lines.push(`• **${trend.pattern}** (${trend.strength})`);
-       if (trend.areas.length > 0) {
-         lines.push(`  Areas: ${trend.areas.slice(0, 3).join(', ')}`);
---
+   
+   if (patterns.trends.length > 0) {
+     lines.push('**Emerging Trends:**');
+     patterns.trends.forEach(trend: any => {
+       lines.push(`• **${trend.pattern}** (${trend.strength})`);
+       if (trend.areas.length > 0) {
+         lines.push(`  Areas: ${trend.areas.slice(0, 3).join(', ')}`);
+       }
+     });
+   }
@@ lines 927-933 @@
-   
-   if (patterns.correlations.length > 0) {
-     lines.push('**Brand Success Drivers:**');
-     patterns.correlations.slice(0, 5).forEach(corr => {
-       const sign = corr.correlation > 0 ? '+' : '';
-       const direction = corr.correlation > 0 ? `favors ${brand1Name}` : `favors ${brand2Name}`;
-       lines.push(`• **${corr.factor}**: **${sign}${(corr.correlation * 100).toFixed(0)}%** correlation (${direction})`);
---
+   
+   if (patterns.correlations.length > 0) {
+     lines.push('**Brand Success Drivers:**');
+     patterns.correlations.slice(0, 5).forEach(corr: any => {
+       const sign = corr.correlation > 0 ? '+' : '';
+       const direction = corr.correlation > 0 ? `favors ${brand1Name}` : `favors ${brand2Name}`;
+       lines.push(`• **${corr.factor}**: **${sign}${(corr.correlation * 100).toFixed(0)}%** correlation (${direction})`);
+     });
+     lines.push('');
+   } else {
@@ lines 940-946 @@
-   
-   if (patterns.trends.length > 0) {
-     lines.push('**Competitive Trends:**');
-     patterns.trends.forEach(trend => {
-       lines.push(`• **${trend.pattern}** (${trend.strength})`);
-       if (trend.areas.length > 0) {
-         lines.push(`  Key markets: ${trend.areas.slice(0, 3).join(', ')}`);
---
+   
+   if (patterns.trends.length > 0) {
+     lines.push('**Competitive Trends:**');
+     patterns.trends.forEach(trend: any => {
+       lines.push(`• **${trend.pattern}** (${trend.strength})`);
+       if (trend.areas.length > 0) {
+         lines.push(`  Key markets: ${trend.areas.slice(0, 3).join(', ')}`);
+       }
+     });
+   }


*** FILE: utils/ai-visualization-selector.ts
@@ lines 125-139 @@
- 
-     // Prioritize recent and similar layer count feedback
-     return [...directMatches, ...similarEntries]
-       .filter(entry => Math.abs(entry.context.layerCount - layerCount) <= 2)
-       .sort((a, b) => b.context.timestamp - a.context.timestamp);
-   }
- 
-   private calculateQuerySimilarity(query1: string, query2: string): number {
-     const words1 = new Set(query1.toLowerCase().split(/\s+/));
-     const words2 = new Set(query2.toLowerCase().split(/\s+/));
-     
-     const intersection = new Set([...words1].filter(x => words2.has(x)));
-     const union = new Set([...words1, ...words2]);
-     
-     return intersection.size / union.size;
---
+ 
+     // Prioritize recent and similar layer count feedback
+     return [...directMatches, ...similarEntries]
+       .filter(entry: any => Math.abs(entry.context.layerCount - layerCount) <= 2)
+       .sort((a: any, b: any) => b.context.timestamp - a.context.timestamp);
+   }
+ 
+   private calculateQuerySimilarity(query1: string, query2: string): number {
+     const words1 = new Set(query1.toLowerCase().split(/\s+/));
+     const words2 = new Set(query2.toLowerCase().split(/\s+/));
+     
+     const intersection = new Set([...words1].filter(x: any => words2.has(x)));
+     const union = new Set([...words1, ...words2]);
+     
+     return intersection.size / union.size;
+   }
+ 
+   private adjustScoreBasedOnFeedback(
@@ lines 152-163 @@
-     }
- 
-     // Calculate feedback adjustment
-     const typeFeedback = relevantFeedback.filter(f => f.visualizationType === visualizationType);
-     if (typeFeedback.length === 0) {
-       return score;
-     }
- 
-     const avgFeedbackScore = typeFeedback.reduce((sum, f) => sum + f.score, 0) / typeFeedback.length;
-     const feedbackWeight = Math.min(0.3, 0.1 * typeFeedback.length); // Cap at 30% influence
-     
-     // Adjust score based on feedback
---
+     }
+ 
+     // Calculate feedback adjustment
+     const typeFeedback = relevantFeedback.filter(f: any => f.visualizationType === visualizationType);
+     if (typeFeedback.length === 0) {
+       return score;
+     }
+ 
+     const avgFeedbackScore = typeFeedback.reduce((sum: any, f: any) => sum + f.score, 0) / typeFeedback.length;
+     const feedbackWeight = Math.min(0.3, 0.1 * typeFeedback.length); // Cap at 30% influence
+     
+     // Adjust score based on feedback
+     const adjustedScore = score * (1 - feedbackWeight) + (avgFeedbackScore / 5) * feedbackWeight;
+     
+     console.log('Score adjustment:', {
@@ lines 181-187 @@
-     console.log('AI Visualization Selection:', {
-       layerCount: layers.length,
-       query,
-       layerTypes: layers.map(l => l.layer.type)
-     });
- 
-     // Analyze data characteristics
---
+     console.log('AI Visualization Selection:', {
+       layerCount: layers.length,
+       query,
+       layerTypes: layers.map(l: any => l.layer.type)
+     });
+ 
+     // Analyze data characteristics
+     const characteristics = await this.analyzeData(layers);
+     console.log('Data characteristics:', characteristics);
+ 
@@ lines 192-198 @@
-     let scores = await this.scoreVisualizationTypes(characteristics, query, layers);
- 
-     // Adjust scores based on feedback
-     scores = scores.map(score => ({
-       ...score,
-       score: this.adjustScoreBasedOnFeedback(
-         score.score,
---
+     let scores = await this.scoreVisualizationTypes(characteristics, query, layers);
+ 
+     // Adjust scores based on feedback
+     scores = scores.map(score: any => ({
+       ...score,
+       score: this.adjustScoreBasedOnFeedback(
+         score.score,
+         score.type,
+         query,
+         layers.length
@@ lines 203-209 @@
-     }));
- 
-     // Sort by adjusted scores
-     return scores.sort((a, b) => b.score - a.score);
-   }
- 
-   private async analyzeData(layers: LayerResult[]): Promise<DataCharacteristics> {
---
+     }));
+ 
+     // Sort by adjusted scores
+     return scores.sort((a: any, b: any) => b.score - a.score);
+   }
+ 
+   private async analyzeData(layers: LayerResult[]): Promise<DataCharacteristics> {
+     const characteristics: DataCharacteristics = {
+       spatialPatterns: await this.analyzeSpatialPatterns(layers),
+       attributePatterns: await this.analyzeAttributePatterns(layers),
@@ lines 223-229 @@
-       let pointCount = 0;
- 
-       for (const layer of layers) {
-         const points = layer.features.map(f => {
-           if (!f.geometry) return null;
- 
-           if (f.geometry.type === 'point') {
---
+       let pointCount = 0;
+ 
+       for (const layer of layers) {
+         const points = layer.features.map(f: any => {
+           if (!f.geometry) return null;
+ 
+           if (f.geometry.type === 'point') {
+             // Handle point geometry
+             const x = f.geometry.x || (f.geometry.coordinates && f.geometry.coordinates[0]);
+             const y = f.geometry.y || (f.geometry.coordinates && f.geometry.coordinates[1]);
@@ lines 247-253 @@
-             }
-           }
-           return null;
-         }).filter((p): p is number[] => p !== null);
- 
-         if (points.length > 0) {
-           const clustering = await this.calculateClustering(points);
---
+             }
+           }
+           return null;
+         }).filter((p: any): p is number[] => p !== null);
+ 
+         if (points.length > 0) {
+           const clustering = await this.calculateClustering(points);
+           const density = this.calculateDensity(points);
+           
+           totalClustering += clustering;
@@ lines 260-269 @@
-       }
- 
-       // Get numeric values from features for distribution analysis
-       const numericValues = layers.flatMap(layer => 
-         layer.features.flatMap(f => {
-           const attributes = f.attributes || {};
-           return Object.values(attributes).filter((v): v is number => 
-             typeof v === 'number' && !isNaN(v)
-           );
-         })
---
+       }
+ 
+       // Get numeric values from features for distribution analysis
+       const numericValues = layers.flatMap(layer: any => 
+         layer.features.flatMap(f: any => {
+           const attributes = f.attributes || {};
+           return Object.values(attributes).filter((v: any): v is number => 
+             typeof v === 'number' && !isNaN(v)
+           );
+         })
+       );
+ 
+       return {
@@ lines 293-299 @@
-       
-       // Analyze distributions
-       for (const field of numericFields) {
-         const values = layer.features.map(f => f.attributes[field]).filter(v => typeof v === 'number');
-         if (values.length > 0) {
-           const stats = this.calculateDistributionStats(values);
-           distributions[field] = stats;
---
+       
+       // Analyze distributions
+       for (const field of numericFields) {
+         const values = layer.features.map(f: any => f.attributes[field]).filter(v: any => typeof v === 'number');
+         if (values.length > 0) {
+           const stats = this.calculateDistributionStats(values);
+           distributions[field] = stats;
+         }
+       }
+ 
@@ lines 406-426 @@
-     ];
- 
-     // Check for proportional visualization keywords
-     if (proportionalKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.4;
-       confidence += 0.3;
-       reasons.push('Query explicitly requests proportional or scaled visualization');
-     }
- 
-     // Check for measurement-related keywords
-     if (measurementKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.3;
-       confidence += 0.2;
-       reasons.push('Query references quantities suitable for proportional representation');
-     }
- 
-     // Check for numeric fields with good distribution
-     const hasNumericFields = layers.some(l => {
-       const numericFields = this.getNumericFields(l);
-       return numericFields.length > 0;
-     });
---
+     ];
+ 
+     // Check for proportional visualization keywords
+     if (proportionalKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.4;
+       confidence += 0.3;
+       reasons.push('Query explicitly requests proportional or scaled visualization');
+     }
+ 
+     // Check for measurement-related keywords
+     if (measurementKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.3;
+       confidence += 0.2;
+       reasons.push('Query references quantities suitable for proportional representation');
+     }
+ 
+     // Check for numeric fields with good distribution
+     const hasNumericFields = layers.some(l: any => {
+       const numericFields = this.getNumericFields(l);
+       return numericFields.length > 0;
+     });
+ 
+     if (hasNumericFields) {
+       score += 0.2;
@@ lines 433-439 @@
- 
-     // Check distribution characteristics
-     const distributions = Object.values(characteristics.attributePatterns.distributions);
-     const hasWideDistribution = distributions.some(d => 
-       d.type === 'continuous' || Math.abs(d.skewness) > 0.5
-     );
- 
---
+ 
+     // Check distribution characteristics
+     const distributions = Object.values(characteristics.attributePatterns.distributions);
+     const hasWideDistribution = distributions.some(d: any => 
+       d.type === 'continuous' || Math.abs(d.skewness) > 0.5
+     );
+ 
+     if (hasWideDistribution) {
+       score += 0.2;
+       reasons.push('Data shows distribution suitable for proportional representation');
@@ lines 443-449 @@
-     }
- 
-     // Check for point or polygon features
-     const hasValidGeometry = layers.some(l => 
-       l.layer.type === 'point' || l.layer.type === 'polygon'
-     );
- 
---
+     }
+ 
+     // Check for point or polygon features
+     const hasValidGeometry = layers.some(l: any => 
+       l.layer.type === 'point' || l.layer.type === 'polygon'
+     );
+ 
+     if (hasValidGeometry) {
+       score += 0.2;
+       confidence += 0.2;
@@ lines 455-462 @@
- 
-     // Boost score for ideal combinations
-     if (
-       (proportionalKeywords.some(k => query.includes(k)) && hasNumericFields) ||
-       (measurementKeywords.some(k => query.includes(k)) && hasWideDistribution)
-     ) {
-       score = Math.min(1, score * 1.3);
-       confidence = Math.min(1, confidence * 1.2);
---
+ 
+     // Boost score for ideal combinations
+     if (
+       (proportionalKeywords.some(k: any => query.includes(k)) && hasNumericFields) ||
+       (measurementKeywords.some(k: any => query.includes(k)) && hasWideDistribution)
+     ) {
+       score = Math.min(1, score * 1.3);
+       confidence = Math.min(1, confidence * 1.2);
+       reasons.push('Strong indication for proportional symbol visualization');
+     }
+ 
@@ lines 498-510 @@
- 
-     // Check query intent
-     const hotspotKeywords = ['hotspot', 'concentration', 'density', 'cluster'];
-     if (hotspotKeywords.some(keyword => query.includes(keyword))) {
-       score += 0.3;
-       reasons.push('Query explicitly requests hotspot analysis');
-     }
- 
-     // Check layer types
-     const hasPointLayers = layers.some(l => l.layer.type === 'point');
-     if (hasPointLayers) {
-       score += 0.2;
-       reasons.push('Point features present for hotspot analysis');
---
+ 
+     // Check query intent
+     const hotspotKeywords = ['hotspot', 'concentration', 'density', 'cluster'];
+     if (hotspotKeywords.some(keyword: any => query.includes(keyword))) {
+       score += 0.3;
+       reasons.push('Query explicitly requests hotspot analysis');
+     }
+ 
+     // Check layer types
+     const hasPointLayers = layers.some(l: any => l.layer.type === 'point');
+     if (hasPointLayers) {
+       score += 0.2;
+       reasons.push('Point features present for hotspot analysis');
+     }
+ 
+     // Calculate confidence
@@ lines 531-537 @@
-     let confidence = 0;
- 
-     // Check for strong correlations
-     const hasStrongCorrelations = characteristics.attributePatterns.correlations.some(c => Math.abs(c.strength) > 0.7);
-     if (hasStrongCorrelations) {
-       score += 0.3;
-       reasons.push('Strong correlations found between variables');
---
+     let confidence = 0;
+ 
+     // Check for strong correlations
+     const hasStrongCorrelations = characteristics.attributePatterns.correlations.some(c: any => Math.abs(c.strength) > 0.7);
+     if (hasStrongCorrelations) {
+       score += 0.3;
+       reasons.push('Strong correlations found between variables');
+     }
+ 
+     // Check query intent
@@ lines 539-545 @@
- 
-     // Check query intent
-     const correlationKeywords = ['correlation', 'relationship', 'compare', 'versus', 'vs'];
-     if (correlationKeywords.some(keyword => query.includes(keyword))) {
-       score += 0.3;
-       reasons.push('Query explicitly requests correlation analysis');
-     }
---
+ 
+     // Check query intent
+     const correlationKeywords = ['correlation', 'relationship', 'compare', 'versus', 'vs'];
+     if (correlationKeywords.some(keyword: any => query.includes(keyword))) {
+       score += 0.3;
+       reasons.push('Query explicitly requests correlation analysis');
+     }
+ 
+     // Check layer compatibility
+     if (layers.length >= 2) {
@@ lines 551-557 @@
-     }
- 
-     // Check statistical relationships
-     if (characteristics.relationships.statistical.some(r => Math.abs(r.correlation) > 0.5)) {
-       score += 0.2;
-       reasons.push('Significant statistical relationships detected');
-     }
---
+     }
+ 
+     // Check statistical relationships
+     if (characteristics.relationships.statistical.some(r: any => Math.abs(r.correlation) > 0.5)) {
+       score += 0.2;
+       reasons.push('Significant statistical relationships detected');
+     }
+ 
+     // Calculate confidence
+     confidence = Math.min(1, (reasons.length / 4) * 0.8 + 0.2);
@@ lines 578-590 @@
- 
-     // Check query intent
-     const threeDKeywords = ['3d', 'three dimensional', 'height', 'elevation'];
-     if (threeDKeywords.some(keyword => query.includes(keyword))) {
-       score += 0.4;
-       reasons.push('Query explicitly requests 3D visualization');
-     }
- 
-     // Check layer types
-     const hasHeightData = layers.some(l => {
-       const config = getLayerConfigById(l.layer.id);
-       const metadata = config?.metadata;
-       return metadata?.tags?.some((tag: string) => 
---
+ 
+     // Check query intent
+     const threeDKeywords = ['3d', 'three dimensional', 'height', 'elevation'];
+     if (threeDKeywords.some(keyword: any => query.includes(keyword))) {
+       score += 0.4;
+       reasons.push('Query explicitly requests 3D visualization');
+     }
+ 
+     // Check layer types
+     const hasHeightData = layers.some(l: any => {
+       const config = getLayerConfigById(l.layer.id);
+       const metadata = config?.metadata;
+       return metadata?.tags?.some((tag: string) => 
+         tag.toLowerCase().includes('elevation') || 
+         tag.toLowerCase().includes('height') ||
+         tag.toLowerCase().includes('3d')
@@ lines 600-606 @@
-     }
- 
-     // Check for polygon layers
-     const hasPolygonLayer = layers.some(l => l.layer.type === 'polygon');
-     if (hasPolygonLayer) {
-       score += 0.3;
-       reasons.push('Polygon features available for 3D extrusion');
---
+     }
+ 
+     // Check for polygon layers
+     const hasPolygonLayer = layers.some(l: any => l.layer.type === 'polygon');
+     if (hasPolygonLayer) {
+       score += 0.3;
+       reasons.push('Polygon features available for 3D extrusion');
+     }
+ 
+     // Calculate confidence
@@ lines 627-633 @@
-     let confidence = 0;
- 
-     // Check layer types
-     const hasPointLayers = layers.some(l => l.layer.type === 'point');
-     if (hasPointLayers) {
-       score += 0.3;
-       confidence += 0.3;
---
+     let confidence = 0;
+ 
+     // Check layer types
+     const hasPointLayers = layers.some(l: any => l.layer.type === 'point');
+     if (hasPointLayers) {
+       score += 0.3;
+       confidence += 0.3;
+       reasons.push('Point features present');
+     }
+ 
@@ lines 651-671 @@
-     ];
- 
-     // Check for location-related keywords
-     if (locationKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.3;
-       confidence += 0.2;
-       reasons.push('Query explicitly references locations or places');
-     }
- 
-     // Check for business/facility names
-     if (businessKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.3;
-       confidence += 0.2;
-       reasons.push('Query references specific business or facility types');
-     }
- 
-     // Check for spatial relationship keywords
-     if (spatialKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.2;
-       confidence += 0.2;
-       reasons.push('Query includes spatial relationship indicators');
---
+     ];
+ 
+     // Check for location-related keywords
+     if (locationKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.3;
+       confidence += 0.2;
+       reasons.push('Query explicitly references locations or places');
+     }
+ 
+     // Check for business/facility names
+     if (businessKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.3;
+       confidence += 0.2;
+       reasons.push('Query references specific business or facility types');
+     }
+ 
+     // Check for spatial relationship keywords
+     if (spatialKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.2;
+       confidence += 0.2;
+       reasons.push('Query includes spatial relationship indicators');
+     }
+ 
+     // Check spatial patterns
@@ lines 695-702 @@
- 
-     // Boost score significantly if query strongly indicates point visualization
-     if (
-       (hasPointLayers && locationKeywords.some(k => query.toLowerCase().includes(k))) ||
-       (hasPointLayers && businessKeywords.some(k => query.toLowerCase().includes(k)))
-     ) {
-       score = Math.min(1, score * 1.5);
-       confidence = Math.min(1, confidence * 1.3);
---
+ 
+     // Boost score significantly if query strongly indicates point visualization
+     if (
+       (hasPointLayers && locationKeywords.some(k: any => query.toLowerCase().includes(k))) ||
+       (hasPointLayers && businessKeywords.some(k: any => query.toLowerCase().includes(k)))
+     ) {
+       score = Math.min(1, score * 1.5);
+       confidence = Math.min(1, confidence * 1.3);
+       reasons.push('Strong indication of point-based location query');
+     }
+ 
@@ lines 734-761 @@
-     const measurementKeywords = ['income', 'revenue', 'sales', 'population', 'value', 'score', 'price'];
- 
-     // Check for explicit top N patterns
-     if (topNPatterns.some(pattern => pattern.test(query))) {
-       score += 0.4;
-       reasons.push('Query explicitly requests top N results');
-       confidence += 0.4;
-     }
- 
-     // Check for ranking keywords
-     if (rankingKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.3;
-       reasons.push('Query indicates ranking or comparison');
-       confidence += 0.2;
-     }
- 
-     // Check for measurement keywords that often indicate ranking intent
-     if (measurementKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score += 0.2;
-       reasons.push('Query references measurable attributes suitable for ranking');
-       confidence += 0.2;
-     }
- 
-     // Check for numeric fields with clear ranking potential
-     const hasRankableFields = layers.some(l => {
-       const numericFields = this.getNumericFields(l);
-       return numericFields.length > 0;
-     });
---
+     const measurementKeywords = ['income', 'revenue', 'sales', 'population', 'value', 'score', 'price'];
+ 
+     // Check for explicit top N patterns
+     if (topNPatterns.some(pattern: any => pattern.test(query))) {
+       score += 0.4;
+       reasons.push('Query explicitly requests top N results');
+       confidence += 0.4;
+     }
+ 
+     // Check for ranking keywords
+     if (rankingKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.3;
+       reasons.push('Query indicates ranking or comparison');
+       confidence += 0.2;
+     }
+ 
+     // Check for measurement keywords that often indicate ranking intent
+     if (measurementKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score += 0.2;
+       reasons.push('Query references measurable attributes suitable for ranking');
+       confidence += 0.2;
+     }
+ 
+     // Check for numeric fields with clear ranking potential
+     const hasRankableFields = layers.some(l: any => {
+       const numericFields = this.getNumericFields(l);
+       return numericFields.length > 0;
+     });
+ 
+     if (hasRankableFields) {
+       score += 0.3;
@@ lines 768-774 @@
- 
-     // Check distribution characteristics
-     const hasSkewedDistribution = Object.values(characteristics.attributePatterns.distributions)
-       .some(d => Math.abs(d.skewness) > 1);
- 
-     if (hasSkewedDistribution) {
-       score += 0.2;
---
+ 
+     // Check distribution characteristics
+     const hasSkewedDistribution = Object.values(characteristics.attributePatterns.distributions)
+       .some(d: any => Math.abs(d.skewness) > 1);
+ 
+     if (hasSkewedDistribution) {
+       score += 0.2;
+       reasons.push('Data shows skewed distribution suitable for top N analysis');
+     }
+ 
@@ lines 808-825 @@
-     const measurementKeywords = ['population', 'count', 'amount', 'quantity', 'total', 'size', 'volume', 'number'];
- 
-     // Reduce score if query suggests proportional visualization
-     if (proportionalKeywords.some(keyword => query.toLowerCase().includes(keyword)) ||
-         measurementKeywords.some(keyword => query.toLowerCase().includes(keyword))) {
-       score -= 0.3;
-       reasons.push('Query suggests proportional visualization might be more appropriate');
-     } else if (singleLayerKeywords.some(keyword => query.includes(keyword))) {
-       score += 0.2;
-       reasons.push('Query suggests simple visualization');
-     }
- 
-     // Check for continuous data
-     const hasContinuousData = Object.values(characteristics.attributePatterns.distributions)
-       .some(d => d.type === 'continuous');
- 
-     if (hasContinuousData) {
-       score += 0.2;
---
+     const measurementKeywords = ['population', 'count', 'amount', 'quantity', 'total', 'size', 'volume', 'number'];
+ 
+     // Reduce score if query suggests proportional visualization
+     if (proportionalKeywords.some(keyword: any => query.toLowerCase().includes(keyword)) ||
+         measurementKeywords.some(keyword: any => query.toLowerCase().includes(keyword))) {
+       score -= 0.3;
+       reasons.push('Query suggests proportional visualization might be more appropriate');
+     } else if (singleLayerKeywords.some(keyword: any => query.includes(keyword))) {
+       score += 0.2;
+       reasons.push('Query suggests simple visualization');
+     }
+ 
+     // Check for continuous data
+     const hasContinuousData = Object.values(characteristics.attributePatterns.distributions)
+       .some(d: any => d.type === 'continuous');
+ 
+     if (hasContinuousData) {
+       score += 0.2;
+       reasons.push('Continuous data suitable for choropleth/single layer visualization');
+     }
+ 
@@ lines 866-873 @@
- 
-     const avgDistance = totalDistance / count;
-     const maxDistance = Math.sqrt(
-       Math.pow(Math.max(...points.map(p => p[0])) - Math.min(...points.map(p => p[0])), 2) +
-       Math.pow(Math.max(...points.map(p => p[1])) - Math.min(...points.map(p => p[1])), 2)
-     );
- 
-     return 1 - (avgDistance / maxDistance);
---
+ 
+     const avgDistance = totalDistance / count;
+     const maxDistance = Math.sqrt(
+       Math.pow(Math.max(...points.map(p: any => p[0])) - Math.min(...points.map(p: any => p[0])), 2) +
+       Math.pow(Math.max(...points.map(p: any => p[1])) - Math.min(...points.map(p: any => p[1])), 2)
+     );
+ 
+     return 1 - (avgDistance / maxDistance);
+   }
+ 
+   private calculateDensity(points: number[][]): number {
@@ lines 886-893 @@
-     if (values.length < 2) return 'unknown';
- 
-     // Calculate mean and standard deviation
-     const mean = values.reduce((a, b) => a + b) / values.length;
-     const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
-     const stdDev = Math.sqrt(variance);
- 
-     // Calculate skewness
---
+     if (values.length < 2) return 'unknown';
+ 
+     // Calculate mean and standard deviation
+     const mean = values.reduce((a: any, b: any) => a + b) / values.length;
+     const variance = values.reduce((a: any, b: any) => a + Math.pow(b - mean, 2), 0) / values.length;
+     const stdDev = Math.sqrt(variance);
+ 
+     // Calculate skewness
+     const skewness = this.calculateSkewness(values, mean, stdDev);
+ 
+     // Determine distribution type based on skewness
@@ lines 905-914 @@
- 
-   private getBounds(points: number[][]): {minX: number; maxX: number; minY: number; maxY: number} {
-     return {
-       minX: Math.min(...points.map(p => p[0])),
-       maxX: Math.max(...points.map(p => p[0])),
-       minY: Math.min(...points.map(p => p[1])),
-       maxY: Math.max(...points.map(p => p[1]))
-     };
-   }
- 
---
+ 
+   private getBounds(points: number[][]): {minX: number; maxX: number; minY: number; maxY: number} {
+     return {
+       minX: Math.min(...points.map(p: any => p[0])),
+       maxX: Math.max(...points.map(p: any => p[0])),
+       minY: Math.min(...points.map(p: any => p[1])),
+       maxY: Math.max(...points.map(p: any => p[1]))
+     };
+   }
+ 
+   private getNumericFields(layer: LayerResult): string[] {
+     if (!layer.features || layer.features.length === 0) {
+       throw new Error('No features available for analysis. Please ensure the layer contains data.');
@@ lines 956-963 @@
-     const n = values.length;
-     if (n < 2) return { type: 'unknown', skewness: 0, kurtosis: 0 };
- 
-     const mean = values.reduce((a, b) => a + b) / n;
-     const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
-     const stdDev = Math.sqrt(variance);
- 
-     const skewness = this.calculateSkewness(values, mean, stdDev);
---
+     const n = values.length;
+     if (n < 2) return { type: 'unknown', skewness: 0, kurtosis: 0 };
+ 
+     const mean = values.reduce((a: any, b: any) => a + b) / n;
+     const variance = values.reduce((a: any, b: any) => a + Math.pow(b - mean, 2), 0) / n;
+     const stdDev = Math.sqrt(variance);
+ 
+     const skewness = this.calculateSkewness(values, mean, stdDev);
+     const kurtosis = this.calculateKurtosis(values, mean, stdDev);
+ 
+     return {
@@ lines 972-989 @@
- 
-   private calculateSkewness(values: number[], mean: number, stdDev: number): number {
-     const n = values.length;
-     return (values.reduce((a, b) => a + Math.pow(b - mean, 3), 0) / n) / Math.pow(stdDev, 3);
-   }
- 
-   private calculateKurtosis(values: number[], mean: number, stdDev: number): number {
-     const n = values.length;
-     return (values.reduce((a, b) => a + Math.pow(b - mean, 4), 0) / n) / Math.pow(stdDev, 4);
-   }
- 
-   private calculateCorrelation(features: any[], field1: string, field2: string): number | null {
-     const pairs = features
-       .map(f => [f.attributes[field1], f.attributes[field2]])
-       .filter((pair): pair is [number, number] => 
-         typeof pair[0] === 'number' && 
-         typeof pair[1] === 'number' &&
-         !isNaN(pair[0]) && 
---
+ 
+   private calculateSkewness(values: number[], mean: number, stdDev: number): number {
+     const n = values.length;
+     return (values.reduce((a: any, b: any) => a + Math.pow(b - mean, 3), 0) / n) / Math.pow(stdDev, 3);
+   }
+ 
+   private calculateKurtosis(values: number[], mean: number, stdDev: number): number {
+     const n = values.length;
+     return (values.reduce((a: any, b: any) => a + Math.pow(b - mean, 4), 0) / n) / Math.pow(stdDev, 4);
+   }
+ 
+   private calculateCorrelation(features: any[], field1: string, field2: string): number | null {
+     const pairs = features
+       .map(f: any => [f.attributes[field1], f.attributes[field2]])
+       .filter((pair: any): pair is [number, number] => 
+         typeof pair[0] === 'number' && 
+         typeof pair[1] === 'number' &&
+         !isNaN(pair[0]) && 
+         !isNaN(pair[1])
+       );
+ 
@@ lines 993-1003 @@
-     if (pairs.length < 2) return null;
- 
-     const n = pairs.length;
-     const sum1 = pairs.reduce((sum, pair) => sum + pair[0], 0);
-     const sum2 = pairs.reduce((sum, pair) => sum + pair[1], 0);
-     const sum1Sq = pairs.reduce((sum, pair) => sum + pair[0] * pair[0], 0);
-     const sum2Sq = pairs.reduce((sum, pair) => sum + pair[1] * pair[1], 0);
-     const pSum = pairs.reduce((sum, pair) => sum + pair[0] * pair[1], 0);
- 
-     const num = pSum - (sum1 * sum2 / n);
-     const den = Math.sqrt((sum1Sq - sum1 * sum1 / n) * (sum2Sq - sum2 * sum2 / n));
---
+     if (pairs.length < 2) return null;
+ 
+     const n = pairs.length;
+     const sum1 = pairs.reduce((sum: any, pair: any) => sum + pair[0], 0);
+     const sum2 = pairs.reduce((sum: any, pair: any) => sum + pair[1], 0);
+     const sum1Sq = pairs.reduce((sum: any, pair: any) => sum + pair[0] * pair[0], 0);
+     const sum2Sq = pairs.reduce((sum: any, pair: any) => sum + pair[1] * pair[1], 0);
+     const pSum = pairs.reduce((sum: any, pair: any) => sum + pair[0] * pair[1], 0);
+ 
+     const num = pSum - (sum1 * sum2 / n);
+     const den = Math.sqrt((sum1Sq - sum1 * sum1 / n) * (sum2Sq - sum2 * sum2 / n));
+ 
+     return den === 0 ? 0 : num / den;
+   }


*** FILE: lib/analysis/strategies/processors/CustomerProfileProcessor.ts
@@ lines 123-129 @@
-   // ============================================================================
- 
-   private processCustomerProfileRecords(rawRecords: Array<Record<string, unknown>>): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       // Use BaseProcessor methods for area identification
-       const area_id = this.extractGeographicId(record) || `area_${index}`;
-       const area_name = this.generateAreaName(record);
---
+   // ============================================================================
+ 
+   private processCustomerProfileRecords(rawRecords: Array<Record<string, unknown>>): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       // Use BaseProcessor methods for area identification
+       const area_id = this.extractGeographicId(record) || `area_${index}`;
+       const area_name = this.generateAreaName(record);
+       
+       // Extract customer profile score
+       const customerProfileScore = this.extractCustomerProfileScore(record);
@@ lines 178-185 @@
-   (outRec.properties as any)[this.scoreField!] = customerProfileScore;
- 
-       return outRec;
-     }).sort((a, b) => b.value - a.value) // Sort by customer profile score
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
-   private extractCustomerProfileScore(record: Record<string, unknown>): number {
---
+   (outRec.properties as any)[this.scoreField!] = customerProfileScore;
+ 
+       return outRec;
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by customer profile score
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+   private extractCustomerProfileScore(record: Record<string, unknown>): number {
+     // First try to use the pre-calculated customer_profile_score if available
+     const rawScore = Number((record as any)[this.scoreField || 'customer_profile_score'] ?? (record as any).customer_profile_score);
+     if (!isNaN(rawScore) && rawScore > 0) {
@@ lines 429-438 @@
-   }
- 
-   private calculateCustomerProfileStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const scores = records.map(r => r.value);
-   const demographicScores = records.map(r => Number((r.properties as any).demographic_alignment) || 0);
-   const lifestyleScores = records.map(r => Number((r.properties as any).lifestyle_score) || 0);
-   const behavioralScores = records.map(r => Number((r.properties as any).behavioral_score) || 0);
-     
-     if (scores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateCustomerProfileStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const scores = records.map(r: any => r.value);
+   const demographicScores = records.map(r: any => Number((r.properties as any).demographic_alignment) || 0);
+   const lifestyleScores = records.map(r: any => Number((r.properties as any).lifestyle_score) || 0);
+   const behavioralScores = records.map(r: any => Number((r.properties as any).behavioral_score) || 0);
+     
+     if (scores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         avgDemographicAlignment: 0, avgLifestyleScore: 0, avgBehavioralScore: 0,
+         avgTargetConfidence: 0
@@ lines 442-464 @@
-       };
-     }
-     
-     const sorted = [...scores].sort((a, b) => a - b);
-     const total = scores.length;
-     const sum = scores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Customer profile-specific metrics
-   const avgDemographicAlignment = demographicScores.reduce((a, b) => a + b, 0) / total;
-   const avgLifestyleScore = lifestyleScores.reduce((a, b) => a + b, 0) / total;
-   const avgBehavioralScore = behavioralScores.reduce((a, b) => a + b, 0) / total;
-   const avgTargetConfidence = records.reduce((sum, r) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / total;
-     
-     return {
-       total,
---
+       };
+     }
+     
+     const sorted = [...scores].sort((a: any, b: any) => a - b);
+     const total = scores.length;
+     const sum = scores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Customer profile-specific metrics
+   const avgDemographicAlignment = demographicScores.reduce((a: any, b: any) => a + b, 0) / total;
+   const avgLifestyleScore = lifestyleScores.reduce((a: any, b: any) => a + b, 0) / total;
+   const avgBehavioralScore = behavioralScores.reduce((a: any, b: any) => a + b, 0) / total;
+   const avgTargetConfidence = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / total;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 478-484 @@
-     // Group by persona types
-   const personaMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const persona = String(((record as any).properties as any).persona_type || 'Unknown');
-       if (!personaMap.has(persona)) {
-         personaMap.set(persona, []);
---
+     // Group by persona types
+   const personaMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const persona = String(((record as any).properties as any).persona_type || 'Unknown');
+       if (!personaMap.has(persona)) {
+         personaMap.set(persona, []);
+       }
+       personaMap.get(persona)!.push(record);
+     });
@@ lines 488-495 @@
-     
-     // Analyze each persona
-     const personaAnalysis = Array.from(personaMap.entries()).map(([persona, personaRecords]) => {
-       const avgScore = personaRecords.reduce((sum, r) => sum + r.value, 0) / personaRecords.length;
-   const avgConfidence = personaRecords.reduce((sum, r) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / personaRecords.length;
-       
-       return {
-         persona,
---
+     
+     // Analyze each persona
+     const personaAnalysis = Array.from(personaMap.entries()).map(([persona, personaRecords]) => {
+       const avgScore = personaRecords.reduce((sum: any, r: any) => sum + r.value, 0) / personaRecords.length;
+   const avgConfidence = personaRecords.reduce((sum: any, r: any) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / personaRecords.length;
+       
+       return {
+         persona,
+         size: personaRecords.length,
+         percentage: (personaRecords.length / records.length) * 100,
+         avgCustomerProfileScore: avgScore,
@@ lines 498-506 @@
-         avgCustomerProfileScore: avgScore,
-         avgTargetConfidence: avgConfidence,
-         topAreas: personaRecords
-           .sort((a, b) => b.value - a.value)
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             score: r.value,
-             confidence: Number((r.properties as any).target_confidence) || 0
---
+         avgCustomerProfileScore: avgScore,
+         avgTargetConfidence: avgConfidence,
+         topAreas: personaRecords
+           .sort((a: any, b: any) => b.value - a.value)
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             score: r.value,
+             confidence: Number((r.properties as any).target_confidence) || 0
+           }))
+       };
+     });
@@ lines 510-533 @@
-     
-     // Identify profile leaders and opportunities
-     const profileLeaders = records
-       .filter(r => r.value >= 75)
-       .sort((a, b) => b.value - a.value)
-       .slice(0, 5);
-     
-     const emergingOpportunities = records
-       .filter(r => r.value >= 50 && r.value < 75 && ((Number((r.properties as any).target_confidence) || 0) >= 60))
-       .sort((a, b) => ((Number((b.properties as any).target_confidence) || 0) - (Number((a.properties as any).target_confidence) || 0)))
-       .slice(0, 5);
-     
-     return {
-       personas: personaAnalysis,
-       profileLeaders: profileLeaders.map(r => ({
-         area: r.area_name,
-         score: r.value,
-   persona: (r.properties as any).persona_type,
-   confidence: Number((r.properties as any).target_confidence) || 0
-       })),
-       emergingOpportunities: emergingOpportunities.map(r => ({
-         area: r.area_name,
-         currentScore: r.value,
-   confidence: Number((r.properties as any).target_confidence) || 0,
---
+     
+     // Identify profile leaders and opportunities
+     const profileLeaders = records
+       .filter(r: any => r.value >= 75)
+       .sort((a: any, b: any) => b.value - a.value)
+       .slice(0, 5);
+     
+     const emergingOpportunities = records
+       .filter(r: any => r.value >= 50 && r.value < 75 && ((Number((r.properties as any).target_confidence) || 0) >= 60))
+       .sort((a: any, b: any) => ((Number((b.properties as any).target_confidence) || 0) - (Number((a.properties as any).target_confidence) || 0)))
+       .slice(0, 5);
+     
+     return {
+       personas: personaAnalysis,
+       profileLeaders: profileLeaders.map(r: any => ({
+         area: r.area_name,
+         score: r.value,
+   persona: (r.properties as any).persona_type,
+   confidence: Number((r.properties as any).target_confidence) || 0
+       })),
+       emergingOpportunities: emergingOpportunities.map(r: any => ({
+         area: r.area_name,
+         currentScore: r.value,
+   confidence: Number((r.properties as any).target_confidence) || 0,
+   persona: (r.properties as any).persona_type
+       })),
+       marketDominance: this.assessMarketDominance(personaAnalysis)
@@ lines 538-546 @@
-   }
- 
-   private assessMarketDominance(personaAnalysis: any[]): string {
-     const enthusiastPercentage = personaAnalysis.find(p => p.persona === 'Brand Enthusiasts')?.percentage || 0;
-     const professionalPercentage = personaAnalysis.find(p => p.persona === 'Fashion-Forward Professionals')?.percentage || 0;
-     const premiumPercentage = personaAnalysis.find(p => p.persona === 'Premium Brand Loyalists')?.percentage || 0;
-     
-     if (enthusiastPercentage > 40) return 'Brand-Enthusiast Market';
-     if (professionalPercentage > 35) return 'Professional-Focused Market';
---
+   }
+ 
+   private assessMarketDominance(personaAnalysis: any[]): string {
+     const enthusiastPercentage = personaAnalysis.find(p: any => p.persona === 'Brand Enthusiasts')?.percentage || 0;
+     const professionalPercentage = personaAnalysis.find(p: any => p.persona === 'Fashion-Forward Professionals')?.percentage || 0;
+     const premiumPercentage = personaAnalysis.find(p: any => p.persona === 'Premium Brand Loyalists')?.percentage || 0;
+     
+     if (enthusiastPercentage > 40) return 'Brand-Enthusiast Market';
+     if (professionalPercentage > 35) return 'Professional-Focused Market';
+     if (premiumPercentage > 30) return 'Premium-Oriented Market';
+     if (enthusiastPercentage + professionalPercentage > 50) return 'Active-Professional Mix';
+     return 'Diverse Customer Profile Mix';
@@ lines 550-561 @@
-   }
- 
-   private processCustomerProfileFeatureImportance(rawFeatureImportance: Array<Record<string, unknown>>): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getCustomerProfileFeatureDescription((item as any).feature || (item as any).name),
-       profileImpact: this.assessCustomerProfileImpact((item as any).importance || 0)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getCustomerProfileFeatureDescription(featureName: string): string {
---
+   }
+ 
+   private processCustomerProfileFeatureImportance(rawFeatureImportance: Array<Record<string, unknown>>): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getCustomerProfileFeatureDescription((item as any).feature || (item as any).name),
+       profileImpact: this.assessCustomerProfileImpact((item as any).importance || 0)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getCustomerProfileFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'age': 'Age demographics and generational characteristics',
+       'income': 'Income levels and purchasing power indicators',
@@ lines 602-612 @@
-     const marketDominance = customerProfileAnalysis.marketDominance;
-     
-     // Calculate baseline metrics
-     const avgScore = records.reduce((sum, r) => sum + r.value, 0) / records.length;
-   const avgDemographic = records.reduce((sum, r) => sum + (Number((r.properties as any).demographic_alignment) || 0), 0) / records.length;
-   const avgLifestyle = records.reduce((sum, r) => sum + (Number((r.properties as any).lifestyle_score) || 0), 0) / records.length;
-   const avgBehavioral = records.reduce((sum, r) => sum + (Number((r.properties as any).behavioral_score) || 0), 0) / records.length;
-   const avgConfidence = records.reduce((sum, r) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / records.length;
-     
-     // Start with customer profile scoring explanation
-     let summary = `**👤 Customer Profile Formula (0-100 scale):**
---
+     const marketDominance = customerProfileAnalysis.marketDominance;
+     
+     // Calculate baseline metrics
+     const avgScore = records.reduce((sum: any, r: any) => sum + r.value, 0) / records.length;
+   const avgDemographic = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any).demographic_alignment) || 0), 0) / records.length;
+   const avgLifestyle = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any).lifestyle_score) || 0), 0) / records.length;
+   const avgBehavioral = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any).behavioral_score) || 0), 0) / records.length;
+   const avgConfidence = records.reduce((sum: any, r: any) => sum + (Number((r.properties as any).target_confidence) || 0), 0) / records.length;
+     
+     // Start with customer profile scoring explanation
+     let summary = `**👤 Customer Profile Formula (0-100 scale):**
+ • **Demographic Alignment (30% weight):** Age, income, household fit with target brand's customer profile (16-45 years, $35K-$150K income)
+ • **Lifestyle Score (25% weight):** Activity patterns, wealth indicators, and lifestyle characteristics aligned with brand positioning
+ • **Behavioral Score (25% weight):** Brand affinity, purchase propensity, and loyalty indicators based on target brand market presence
@@ lines 628-637 @@
- `;
-     
-     // Customer profile distribution
-     const idealProfile = records.filter(r => r.value >= 90).length;
-     const strongProfile = records.filter(r => r.value >= 75).length;
-     const goodProfile = records.filter(r => r.value >= 60).length;
-     const moderateProfile = records.filter(r => r.value >= 45).length;
-     
-     summary += `Customer profile distribution: ${idealProfile} ideal matches (${(idealProfile/totalAreas*100).toFixed(1)}%), ${strongProfile} strong fits (${(strongProfile/totalAreas*100).toFixed(1)}%), ${goodProfile} good alignments (${(goodProfile/totalAreas*100).toFixed(1)}%), ${moderateProfile} moderate potential (${(moderateProfile/totalAreas*100).toFixed(1)}%).
- 
---
+ `;
+     
+     // Customer profile distribution
+     const idealProfile = records.filter(r: any => r.value >= 90).length;
+     const strongProfile = records.filter(r: any => r.value >= 75).length;
+     const goodProfile = records.filter(r: any => r.value >= 60).length;
+     const moderateProfile = records.filter(r: any => r.value >= 45).length;
+     
+     summary += `Customer profile distribution: ${idealProfile} ideal matches (${(idealProfile/totalAreas*100).toFixed(1)}%), ${strongProfile} strong fits (${(strongProfile/totalAreas*100).toFixed(1)}%), ${goodProfile} good alignments (${(goodProfile/totalAreas*100).toFixed(1)}%), ${moderateProfile} moderate potential (${(moderateProfile/totalAreas*100).toFixed(1)}%).
+ 
+ `;
+     
+     summary += `**Customer Profile Analysis:** Analyzed ${totalAreas} geographic markets to identify customer profile strength and persona distribution. `;
@@ lines 684-692 @@
-     summary += `Market structure: ${marketDominance.replace(/-/g, ' ')}. `;
-     
-     // Component analysis insights
-   const strongDemographic = records.filter(r => ((Number((r.properties as any).demographic_alignment) || 0) >= 70)).length;
-   const strongLifestyle = records.filter(r => ((Number((r.properties as any).lifestyle_score) || 0) >= 70)).length;
-   const strongBehavioral = records.filter(r => ((Number((r.properties as any).behavioral_score) || 0) >= 70)).length;
-     
-     summary += `**Component Strengths:** ${strongDemographic} markets with strong demographic alignment (${(strongDemographic/totalAreas*100).toFixed(1)}%), ${strongLifestyle} with strong lifestyle scores (${(strongLifestyle/totalAreas*100).toFixed(1)}%), ${strongBehavioral} with strong behavioral indicators (${(strongBehavioral/totalAreas*100).toFixed(1)}%). `;
-     
---
+     summary += `Market structure: ${marketDominance.replace(/-/g, ' ')}. `;
+     
+     // Component analysis insights
+   const strongDemographic = records.filter(r: any => ((Number((r.properties as any).demographic_alignment) || 0) >= 70)).length;
+   const strongLifestyle = records.filter(r: any => ((Number((r.properties as any).lifestyle_score) || 0) >= 70)).length;
+   const strongBehavioral = records.filter(r: any => ((Number((r.properties as any).behavioral_score) || 0) >= 70)).length;
+     
+     summary += `**Component Strengths:** ${strongDemographic} markets with strong demographic alignment (${(strongDemographic/totalAreas*100).toFixed(1)}%), ${strongLifestyle} with strong lifestyle scores (${(strongLifestyle/totalAreas*100).toFixed(1)}%), ${strongBehavioral} with strong behavioral indicators (${(strongBehavioral/totalAreas*100).toFixed(1)}%). `;
+     
+     // Strategic recommendations
+     summary += `**Strategic Insights:** `;
+     if (avgScore >= 70) {
@@ lines 717-723 @@
-    * Create direct renderer for customer profile visualization
-    */
-   private createCustomerProfileRenderer(records: Array<GeographicDataPoint>): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use standard red-to-green color scheme consistent with other endpoints
---
+    * Create direct renderer for customer profile visualization
+    */
+   private createCustomerProfileRenderer(records: Array<GeographicDataPoint>): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use standard red-to-green color scheme consistent with other endpoints
+     const profileColors = [
+       [215, 48, 39, 0.6],     // #d73027 - Red (low customer profile fit)
+       [253, 174, 97, 0.6],    // #fdae61 - Orange  
@@ lines 732-738 @@
-     return {
-       type: 'class-breaks',
-       field: fieldName, // Render on the primary customer profile score
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+       field: fieldName, // Render on the primary customer profile score
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: profileColors[i], // Direct array format
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 754-760 @@
-    * Create direct legend for customer profile
-    */
-   private createCustomerProfileLegend(records: Array<GeographicDataPoint>): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use RGBA format with correct opacity to match features - standard red-to-green scheme
---
+    * Create direct legend for customer profile
+    */
+   private createCustomerProfileLegend(records: Array<GeographicDataPoint>): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use RGBA format with correct opacity to match features - standard red-to-green scheme
+     const colors = [
+       'rgba(215, 48, 39, 0.6)',   // Low customer profile fit
+       'rgba(253, 174, 97, 0.6)',  // Medium-low  
@@ lines 830-843 @@
- 
-     // Filter for records with valid coordinates
-     const validCoords = records
-       .filter(record => 
-         (record as any).coordinates && 
-         Array.isArray((record as any).coordinates) && 
-         (record as any).coordinates.length >= 2 &&
-         isFinite((record as any).coordinates[0]) && 
-         isFinite((record as any).coordinates[1])
-       )
-       .map(record => (record as any).coordinates);
- 
-     if (validCoords.length === 0) {
-       console.warn('[CustomerProfileProcessor] No records with valid coordinates found.');
---
+ 
+     // Filter for records with valid coordinates
+     const validCoords = records
+       .filter(record: any => 
+         (record as any).coordinates && 
+         Array.isArray((record as any).coordinates) && 
+         (record as any).coordinates.length >= 2 &&
+         isFinite((record as any).coordinates[0]) && 
+         isFinite((record as any).coordinates[1])
+       )
+       .map(record: any => (record as any).coordinates);
+ 
+     if (validCoords.length === 0) {
+       console.warn('[CustomerProfileProcessor] No records with valid coordinates found.');
+       return null;
+     }
+ 
@@ lines 849-855 @@
-     // Calculate bounding box from coordinate points
-     let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
- 
-     validCoords.forEach(coord => {
-       if (coord && coord.length >= 2) {
-         const x = coord[0];
-         const y = coord[1];
---
+     // Calculate bounding box from coordinate points
+     let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
+ 
+     validCoords.forEach(coord: any => {
+       if (coord && coord.length >= 2) {
+         const x = coord[0];
+         const y = coord[1];
+         xmin = Math.min(xmin, x);
+         ymin = Math.min(ymin, y);
+         xmax = Math.max(xmax, x);


*** FILE: lib/analysis/strategies/processors/DemographicDataProcessor.ts
@@ lines 25-31 @@
-     
-     // Validate real estate demographic fields - check for housing market data structure
-     const hasRealEstateDemographicFields = rawData.results.length === 0 || 
-       rawData.results.some(record => 
-         record && 
-         // Check for Quebec housing market demographic fields
-         ((record as any).ECYPTAPOP !== undefined ||            // Population (Quebec data)
---
+     
+     // Validate real estate demographic fields - check for housing market data structure
+     const hasRealEstateDemographicFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => 
+         record && 
+         // Check for Quebec housing market demographic fields
+         ((record as any).ECYPTAPOP !== undefined ||            // Population (Quebec data)
+          (record as any).ECYHRIAVG !== undefined ||            // Household income (Quebec data)
+          (record as any).value_TOTPOP_CY !== undefined ||      // Total population (other sources)
+          (record as any).TOTPOP_CY !== undefined ||            // Total population (alternative)
@@ lines 64-72 @@
-   // Resolve configured or legacy score field names. We explicitly prefer an
-   // incoming 'demographic_score' if present to satisfy legacy consumers/tests.
-   this.scoreField = getPrimaryScoreField('demographic_insights', (rawData as any)?.metadata) || 'demographic_score';
-   const hasPrimaryFieldInData = Array.isArray(rawData.results) && rawData.results.some(r => (r as any)[this.scoreField!] !== undefined);
-   const hasCanonicalInData = Array.isArray(rawData.results) && rawData.results.some(r => (r as any)['demographic_insights_score'] !== undefined);
-   const hasExplicitDemographicScore = Array.isArray(rawData.results) && rawData.results.some(r => (r as any)['demographic_score'] !== undefined);
- 
-   // Priority: explicit demographic_score in data -> configured primary -> canonical demographic_insights_score -> fallback
-   const canonicalScoreField = hasExplicitDemographicScore
---
+   // Resolve configured or legacy score field names. We explicitly prefer an
+   // incoming 'demographic_score' if present to satisfy legacy consumers/tests.
+   this.scoreField = getPrimaryScoreField('demographic_insights', (rawData as any)?.metadata) || 'demographic_score';
+   const hasPrimaryFieldInData = Array.isArray(rawData.results) && rawData.results.some(r: any => (r as any)[this.scoreField!] !== undefined);
+   const hasCanonicalInData = Array.isArray(rawData.results) && rawData.results.some(r: any => (r as any)['demographic_insights_score'] !== undefined);
+   const hasExplicitDemographicScore = Array.isArray(rawData.results) && rawData.results.some(r: any => (r as any)['demographic_score'] !== undefined);
+ 
+   // Priority: explicit demographic_score in data -> configured primary -> canonical demographic_insights_score -> fallback
+   const canonicalScoreField = hasExplicitDemographicScore
+     ? 'demographic_score'
+     : (hasPrimaryFieldInData ? this.scoreField! : (hasCanonicalInData ? 'demographic_insights_score' : this.scoreField!));
+ 
@@ lines 129-135 @@
-   // ============================================================================
- 
-   private processDemographicRecords(rawRecords: any[]): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       const area_id = (record as any).ID || (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
-       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
-       
---
+   // ============================================================================
+ 
+   private processDemographicRecords(rawRecords: any[]): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       const area_id = (record as any).ID || (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
+       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
+       
+       // Extract demographic score
+       const demographicScore = this.extractDemographicScore(record);
+       
@@ lines 178-185 @@
-       (outRec.properties as any)[this.scoreField!] = demographicScore;
- 
-       return outRec;
-     }).sort((a, b) => b.value - a.value) // Sort by demographic score
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
-   private extractDemographicScore(record: any): number {
---
+       (outRec.properties as any)[this.scoreField!] = demographicScore;
+ 
+       return outRec;
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by demographic score
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+   private extractDemographicScore(record: any): number {
+     // PRIORITY 1: PRE-CALCULATED REAL ESTATE DEMOGRAPHIC SCORES
+     if (((record as any).demographic_insights_score !== undefined && (record as any).demographic_insights_score !== null) ||
+         ((record as any).real_estate_demographic_score !== undefined && (record as any).real_estate_demographic_score !== null) ||
@@ lines 248-254 @@
-     if ((record as any).income_diversity) factors.push((record as any).income_diversity);
-     
-     if (factors.length > 0) {
-       return factors.reduce((sum, factor) => sum + factor, 0) / factors.length;
-     }
-     
-     // Default calculation based on available data
---
+     if ((record as any).income_diversity) factors.push((record as any).income_diversity);
+     
+     if (factors.length > 0) {
+       return factors.reduce((sum: any, factor: any) => sum + factor, 0) / factors.length;
+     }
+     
+     // Default calculation based on available data
+     const income = (record as any).value_AVGHINC_CY || 50000;
+     const age = (record as any).value_MEDAGE_CY || 40;
+     
@@ lines 344-352 @@
-   }
- 
-   private calculateDemographicStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const scores = records.map(r => r.value);
-     const incomes = records.map(r => (r.properties as any).avg_income || 0);
-     const ages = records.map(r => (r.properties as any).median_age || 0);
-     
-     if (scores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateDemographicStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const scores = records.map(r: any => r.value);
+     const incomes = records.map(r: any => (r.properties as any).avg_income || 0);
+     const ages = records.map(r: any => (r.properties as any).median_age || 0);
+     
+     if (scores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         avgIncome: 0, medianAge: 0, diversityIndex: 0
+       };
@@ lines 355-376 @@
-       };
-     }
-     
-     const sorted = [...scores].sort((a, b) => a - b);
-     const total = scores.length;
-     const sum = scores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Demographic-specific metrics
-     const avgIncome = incomes.reduce((a, b) => a + b, 0) / total;
-     const medianAge = ages.reduce((a, b) => a + b, 0) / total;
-     const diversityIndex = records.reduce((sum, r) => sum + ((r.properties as any).diversity_index || 0), 0) / total;
-     
-     return {
-       total,
---
+       };
+     }
+     
+     const sorted = [...scores].sort((a: any, b: any) => a - b);
+     const total = scores.length;
+     const sum = scores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Demographic-specific metrics
+     const avgIncome = incomes.reduce((a: any, b: any) => a + b, 0) / total;
+     const medianAge = ages.reduce((a: any, b: any) => a + b, 0) / total;
+     const diversityIndex = records.reduce((sum: any, r: any) => sum + ((r.properties as any).diversity_index || 0), 0) / total;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 389-395 @@
-     // Group by demographic categories
-     const categoryMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const category = (record as any).category!;
-       if (!categoryMap.has(category)) {
-         categoryMap.set(category, []);
---
+     // Group by demographic categories
+     const categoryMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const category = (record as any).category!;
+       if (!categoryMap.has(category)) {
+         categoryMap.set(category, []);
+       }
+       categoryMap.get(category)!.push(record);
+     });
@@ lines 399-406 @@
-     
-     // Analyze each category
-     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
-       const avgScore = categoryRecords.reduce((sum, r) => sum + r.value, 0) / categoryRecords.length;
-       const avgIncome = categoryRecords.reduce((sum, r) => sum + ((r.properties as any).avg_income || 0), 0) / categoryRecords.length;
-       
-       return {
-         category,
---
+     
+     // Analyze each category
+     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
+       const avgScore = categoryRecords.reduce((sum: any, r: any) => sum + r.value, 0) / categoryRecords.length;
+       const avgIncome = categoryRecords.reduce((sum: any, r: any) => sum + ((r.properties as any).avg_income || 0), 0) / categoryRecords.length;
+       
+       return {
+         category,
+         size: categoryRecords.length,
+         percentage: (categoryRecords.length / records.length) * 100,
+         avgDemographicScore: avgScore,
@@ lines 409-417 @@
-         avgDemographicScore: avgScore,
-         avgIncome,
-         topAreas: categoryRecords
-           .sort((a, b) => b.value - a.value)
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             score: r.value,
-             income: (r.properties as any).avg_income,
---
+         avgDemographicScore: avgScore,
+         avgIncome,
+         topAreas: categoryRecords
+           .sort((a: any, b: any) => b.value - a.value)
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             score: r.value,
+             income: (r.properties as any).avg_income,
+             age: (r.properties as any).median_age
+           }))
+       };
@@ lines 422-446 @@
-     
-     // Identify demographic leaders and targets
-     const demographicLeaders = records
-       .filter(r => r.category === 'optimal_demographics')
-       .sort((a, b) => b.value - a.value)
-       .slice(0, 5);
-     
-     const growthTargets = records
-       .filter(r => ['moderate_demographics', 'developing_demographics'].includes(r.category!))
-       .sort((a, b) => (b.properties as any).economic_stability - (a.properties as any).economic_stability)
-       .slice(0, 5);
-     
-     return {
-       categories: categoryAnalysis,
-       demographicLeaders: demographicLeaders.map(r => ({
-         area: r.area_name,
-         score: r.value,
-         income: (r.properties as any).avg_income,
-         age: (r.properties as any).median_age,
-         stability: (r.properties as any).economic_stability
-       })),
-       growthTargets: growthTargets.map(r => ({
-         area: r.area_name,
-         currentScore: r.value,
-         stability: (r.properties as any).economic_stability,
---
+     
+     // Identify demographic leaders and targets
+     const demographicLeaders = records
+       .filter(r: any => r.category === 'optimal_demographics')
+       .sort((a: any, b: any) => b.value - a.value)
+       .slice(0, 5);
+     
+     const growthTargets = records
+       .filter(r: any => ['moderate_demographics', 'developing_demographics'].includes(r.category!))
+       .sort((a: any, b: any) => (b.properties as any).economic_stability - (a.properties as any).economic_stability)
+       .slice(0, 5);
+     
+     return {
+       categories: categoryAnalysis,
+       demographicLeaders: demographicLeaders.map(r: any => ({
+         area: r.area_name,
+         score: r.value,
+         income: (r.properties as any).avg_income,
+         age: (r.properties as any).median_age,
+         stability: (r.properties as any).economic_stability
+       })),
+       growthTargets: growthTargets.map(r: any => ({
+         area: r.area_name,
+         currentScore: r.value,
+         stability: (r.properties as any).economic_stability,
+         potential: 'high'
+       })),
+       marketSegmentation: this.analyzeMarketSegmentation(categoryAnalysis)
@@ lines 451-458 @@
-   }
- 
-   private analyzeMarketSegmentation(categoryAnalysis: any[]): string {
-     const optimalPercentage = categoryAnalysis.find(c => c.category === 'optimal_demographics')?.percentage || 0;
-     const strongPercentage = categoryAnalysis.find(c => c.category === 'strong_demographics')?.percentage || 0;
-     
-     if (optimalPercentage > 40) return 'premium_market_dominated';
-     if (optimalPercentage + strongPercentage > 60) return 'upscale_market_focused';
---
+   }
+ 
+   private analyzeMarketSegmentation(categoryAnalysis: any[]): string {
+     const optimalPercentage = categoryAnalysis.find(c: any => c.category === 'optimal_demographics')?.percentage || 0;
+     const strongPercentage = categoryAnalysis.find(c: any => c.category === 'strong_demographics')?.percentage || 0;
+     
+     if (optimalPercentage > 40) return 'premium_market_dominated';
+     if (optimalPercentage + strongPercentage > 60) return 'upscale_market_focused';
+     if (strongPercentage > 40) return 'middle_market_strong';
+     return 'diverse_market_mix';
+   }
@@ lines 461-472 @@
-   }
- 
-   private processDemographicFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getDemographicFeatureDescription((item as any).feature || (item as any).name),
-       demographicImpact: this.assessDemographicImpact((item as any).importance || 0)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getDemographicFeatureDescription(featureName: string): string {
---
+   }
+ 
+   private processDemographicFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getDemographicFeatureDescription((item as any).feature || (item as any).name),
+       demographicImpact: this.assessDemographicImpact((item as any).importance || 0)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getDemographicFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'income': 'Household income levels and purchasing power',
+       'age': 'Age demographics and generational characteristics',
@@ lines 510-518 @@
-     const marketSegmentation = demographicAnalysis.marketSegmentation;
-     
-     // Calculate baseline metrics first
-     const avgScore = records.reduce((sum, r) => sum + r.value, 0) / records.length;
-     const avgIncome = records.reduce((sum, r) => sum + ((r.properties as any).avg_income || 0), 0) / records.length;
-     const avgAge = records.reduce((sum, r) => sum + ((r.properties as any).median_age || 0), 0) / records.length;
-     
-     // Start with formula explanation
-     let summary = `**📊 Demographic Fit Formula (0-100 scale):**
---
+     const marketSegmentation = demographicAnalysis.marketSegmentation;
+     
+     // Calculate baseline metrics first
+     const avgScore = records.reduce((sum: any, r: any) => sum + r.value, 0) / records.length;
+     const avgIncome = records.reduce((sum: any, r: any) => sum + ((r.properties as any).avg_income || 0), 0) / records.length;
+     const avgAge = records.reduce((sum: any, r: any) => sum + ((r.properties as any).median_age || 0), 0) / records.length;
+     
+     // Start with formula explanation
+     let summary = `**📊 Demographic Fit Formula (0-100 scale):**
+ • **Income Component (30 points):** Economic capability, optimal $40K-$100K range\n• **Population Component (25 points):** Market size and density factors\n• **Age Component (25 points):** Target demographics, optimal 25-45 years (peak at 35)\n• **Household Component (20 points):** Family size, optimal 2-4 people (peak at 3)\n\nHigher scores indicate better demographic alignment with target brand markets.\n
+ `;
+     
@@ lines 524-541 @@
-     summary += `Market average demographic score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
-     
-     // Calculate demographic baselines
-     const avgPopulation = records.reduce((sum, r) => sum + ((r.properties as any).population || 0), 0) / totalAreas;
-     const avgDiversityIndex = records.reduce((sum, r) => sum + ((r.properties as any).diversity_index || 0), 0) / totalAreas;
-     const avgHouseholdSize = records.reduce((sum, r) => sum + ((r.properties as any).household_size || 0), 0) / totalAreas;
-     const avgEconomicStability = records.reduce((sum, r) => sum + ((r.properties as any).economic_stability || 0), 0) / totalAreas;
-     
-     summary += `Demographic baseline: $${(avgIncome/1000).toFixed(0)}K income, ${avgAge.toFixed(0)} median age, ${(avgPopulation/1000).toFixed(0)}K population. `;
-     summary += `Market characteristics: ${avgHouseholdSize.toFixed(1)} avg household size, ${(avgDiversityIndex*100).toFixed(1)}% diversity index, ${(avgEconomicStability*100).toFixed(1)}% economic stability. `;
-     
-     // Demographic fit distribution
-     const optimalDemo = records.filter(r => r.value >= 70).length;
-     const strongDemo = records.filter(r => r.value >= 50).length;
-     const moderateDemo = records.filter(r => r.value >= 30).length;
-     
-     summary += `Demographic fit distribution: ${optimalDemo} optimal markets (${(optimalDemo/totalAreas*100).toFixed(1)}%), ${strongDemo} strong+ (${(strongDemo/totalAreas*100).toFixed(1)}%), ${moderateDemo} moderate+ (${(moderateDemo/totalAreas*100).toFixed(1)}%).
- 
---
+     summary += `Market average demographic score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
+     
+     // Calculate demographic baselines
+     const avgPopulation = records.reduce((sum: any, r: any) => sum + ((r.properties as any).population || 0), 0) / totalAreas;
+     const avgDiversityIndex = records.reduce((sum: any, r: any) => sum + ((r.properties as any).diversity_index || 0), 0) / totalAreas;
+     const avgHouseholdSize = records.reduce((sum: any, r: any) => sum + ((r.properties as any).household_size || 0), 0) / totalAreas;
+     const avgEconomicStability = records.reduce((sum: any, r: any) => sum + ((r.properties as any).economic_stability || 0), 0) / totalAreas;
+     
+     summary += `Demographic baseline: $${(avgIncome/1000).toFixed(0)}K income, ${avgAge.toFixed(0)} median age, ${(avgPopulation/1000).toFixed(0)}K population. `;
+     summary += `Market characteristics: ${avgHouseholdSize.toFixed(1)} avg household size, ${(avgDiversityIndex*100).toFixed(1)}% diversity index, ${(avgEconomicStability*100).toFixed(1)}% economic stability. `;
+     
+     // Demographic fit distribution
+     const optimalDemo = records.filter(r: any => r.value >= 70).length;
+     const strongDemo = records.filter(r: any => r.value >= 50).length;
+     const moderateDemo = records.filter(r: any => r.value >= 30).length;
+     
+     summary += `Demographic fit distribution: ${optimalDemo} optimal markets (${(optimalDemo/totalAreas*100).toFixed(1)}%), ${strongDemo} strong+ (${(strongDemo/totalAreas*100).toFixed(1)}%), ${moderateDemo} moderate+ (${(moderateDemo/totalAreas*100).toFixed(1)}%).
+ 
+ `;
+     
+     summary += `**Demographic Analysis Complete:** ${totalAreas} geographic markets analyzed across key demographic indicators. `;
@@ lines 638-644 @@
-    * Create direct renderer for demographic analysis visualization
-    */
-   private createDemographicRenderer(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use same colors as strategic analysis: Red (low) -> Orange -> Light Green -> Dark Green (high)
---
+    * Create direct renderer for demographic analysis visualization
+    */
+   private createDemographicRenderer(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use same colors as strategic analysis: Red (low) -> Orange -> Light Green -> Dark Green (high)
+     const demographicColors = [
+       [215, 48, 39, 0.6],   // #d73027 - Red (lowest demographic opportunity)
+       [253, 174, 97, 0.6],  // #fdae61 - Orange  
@@ lines 654-660 @@
-     return {
-       type: 'class-breaks',
-       field: fieldName, // Use the main value field that ArcGIS can access
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+       field: fieldName, // Use the main value field that ArcGIS can access
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: demographicColors[i], // Direct array format
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 676-682 @@
-    * Create direct legend for demographic analysis
-    */
-   private createDemographicLegend(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use RGBA format with correct opacity to match features (same as strategic)
---
+    * Create direct legend for demographic analysis
+    */
+   private createDemographicLegend(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use RGBA format with correct opacity to match features (same as strategic)
+     const colors = [
+       'rgba(215, 48, 39, 0.6)',   // Low demographic opportunity
+       'rgba(253, 174, 97, 0.6)',  // Medium-low  


*** FILE: components/map/enhancedPopupTemplate.tsx
@@ lines 255-268 @@
-     const groupId = data[0].groupId;
-     
-     // Find the matching group
-     const matchingGroup = this.layerGroups.find(group => {
-       // Check if the layer belongs to the main group
-       if (group.id === groupId) return true;
-       
-       // Check if the layer belongs to any subgroups
-       if (group.subGroups) {
-         return group.subGroups.some(subGroup => 
-           subGroup && subGroup.layers?.some(layer => layer.id === data[0].layerId)
-         );
-       }
-       
---
+     const groupId = data[0].groupId;
+     
+     // Find the matching group
+     const matchingGroup = this.layerGroups.find(group: any => {
+       // Check if the layer belongs to the main group
+       if (group.id === groupId) return true;
+       
+       // Check if the layer belongs to any subgroups
+       if (group.subGroups) {
+         return group.subGroups.some(subGroup: any => 
+           subGroup && subGroup.layers?.some(layer: any => layer.id === data[0].layerId)
+         );
+       }
+       
+       return false;
+     });
+ 
@@ lines 300-306 @@
-             showLegend: true,
-             colors: DEFAULT_COLORS
-           },
-       relatedLayers: matchingGroup.layers?.map(layer => layer.id) || []
-     }];
-   }
- 
---
+             showLegend: true,
+             colors: DEFAULT_COLORS
+           },
+       relatedLayers: matchingGroup.layers?.map(layer: any => layer.id) || []
+     }];
+   }
+ 
+   private async queryRelatedLayers(geometry: __esri.Geometry, attributes: any): Promise<PopupData[]> {
+     if (!this.layerGroups?.length) {
+       console.warn('DEBUG: No layer groups available');
@@ lines 325-337 @@
- 
-     try {
-       // Determine which group the current layer belongs to
-       const currentGroup = this.layerGroups.find(group => {
-         if (group.subGroups) {
-           return group.subGroups.some(subGroup => 
-             subGroup && subGroup.layers?.some(layer => layer.id === this.layerConfig.id)
-           );
-         }
-         return group.layers?.some(layer => layer.id === this.layerConfig.id);
-       });
- 
-       if (!currentGroup) {
---
+ 
+     try {
+       // Determine which group the current layer belongs to
+       const currentGroup = this.layerGroups.find(group: any => {
+         if (group.subGroups) {
+           return group.subGroups.some(subGroup: any => 
+             subGroup && subGroup.layers?.some(layer: any => layer.id === this.layerConfig.id)
+           );
+         }
+         return group.layers?.some(layer: any => layer.id === this.layerConfig.id);
+       });
+ 
+       if (!currentGroup) {
+         console.warn(`No matching group found for layer ${this.layerConfig.id}`);
+         return [];
+       }
@@ lines 342-352 @@
-       // Special handling for Google Trends group
-       if (currentGroup.id === 'google-trends-group') {
-         // Get all Google Trends layers from all subgroups
-         const googleTrendsLayers = currentGroup.subGroups?.flatMap(subGroup => 
-           subGroup.layers || []
-         ) || [];
- 
-         console.log('DEBUG: Google Trends layers to query:', googleTrendsLayers.map(l => l.id));
-         
-         // Get the current value directly from the attributes
-         // This is important - the attributes passed in are from the clicked feature
---
+       // Special handling for Google Trends group
+       if (currentGroup.id === 'google-trends-group') {
+         // Get all Google Trends layers from all subgroups
+         const googleTrendsLayers = currentGroup.subGroups?.flatMap(subGroup: any => 
+           subGroup.layers || []
+         ) || [];
+ 
+         console.log('DEBUG: Google Trends layers to query:', googleTrendsLayers.map(l: any => l.id));
+         
+         // Get the current value directly from the attributes
+         // This is important - the attributes passed in are from the clicked feature
+         // and already contain the normalized Google Trends values
+         
+         // Determine region (ON or BC) from clicked layer
@@ lines 354-360 @@
-         
-         // Determine region (ON or BC) from clicked layer
-         const region = this.layerConfig.id.endsWith('ON') ? 'ON' : 'BC';
-         const regionLayers = googleTrendsLayers.filter(layer => layer.id.endsWith(region));
-         
-         console.log(`DEBUG: Found ${regionLayers.length} layers for ${region} region`);
-         
---
+         
+         // Determine region (ON or BC) from clicked layer
+         const region = this.layerConfig.id.endsWith('ON') ? 'ON' : 'BC';
+         const regionLayers = googleTrendsLayers.filter(layer: any => layer.id.endsWith(region));
+         
+         console.log(`DEBUG: Found ${regionLayers.length} layers for ${region} region`);
+         
+         const popupDataArray: PopupData[] = [];
+         
+         // For each layer in the same region, get the value directly from the attributes
@@ lines 405-412 @@
-       const queryPromises = (() => {
-         if (currentGroup.subGroups) {
-           // For groups with subgroups, query only layers from the same subgroup
-           const currentSubGroup = currentGroup.subGroups.find(subGroup => 
-             subGroup && subGroup.layers?.some(layer => layer.id === this.layerConfig.id)
-           );
-           
-           if (!currentSubGroup) {
---
+       const queryPromises = (() => {
+         if (currentGroup.subGroups) {
+           // For groups with subgroups, query only layers from the same subgroup
+           const currentSubGroup = currentGroup.subGroups.find(subGroup: any => 
+             subGroup && subGroup.layers?.some(layer: any => layer.id === this.layerConfig.id)
+           );
+           
+           if (!currentSubGroup) {
+             console.warn(`No matching subgroup found for layer ${this.layerConfig.id}`);
+             return [];
+           }
@@ lines 414-420 @@
-             return [];
-           }
- 
-           return (currentSubGroup.layers || []).map(async (layer): Promise<PopupData | null> => {
-             try {
-               // Get the existing layer from layerStates
-               const existingLayer = this.layerStates[layer.id]?.layer;
---
+             return [];
+           }
+ 
+           return (currentSubGroup.layers || []).map(async (layer: any): Promise<PopupData | null> => {
+             try {
+               // Get the existing layer from layerStates
+               const existingLayer = this.layerStates[layer.id]?.layer;
+               if (!existingLayer) {
+                 console.warn(`No existing layer found for ${layer.id}`);
+                 return null;
@@ lines 460-467 @@
-               }
- 
-               const values = statsResult.features
-                 .map(f => f.attributes[valueField])
-                 .filter(v => v !== null && v !== undefined && !isNaN(v));
-               
-               if (values.length === 0) {
-                 console.warn(`No valid values found for layer ${layer.name} using field ${valueField}`);
---
+               }
+ 
+               const values = statsResult.features
+                 .map(f: any => f.attributes[valueField])
+                 .filter(v: any => v !== null && v !== undefined && !isNaN(v));
+               
+               if (values.length === 0) {
+                 console.warn(`No valid values found for layer ${layer.name} using field ${valueField}`);
+                 return null;
+               }
+ 
@@ lines 471-477 @@
-               // Calculate statistics
-               const min = Math.min(...values);
-               const max = Math.max(...values);
-               const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
-               const currentValue = result.features[0]?.attributes[valueField] || 0;
- 
-               if (result.features.length === 0) {
---
+               // Calculate statistics
+               const min = Math.min(...values);
+               const max = Math.max(...values);
+               const median = values.sort((a: any, b: any) => a - b)[Math.floor(values.length / 2)];
+               const currentValue = result.features[0]?.attributes[valueField] || 0;
+ 
+               if (result.features.length === 0) {
+                 console.log(`DEBUG: No features found for ${layer.name}`);
+                 return null;
+               }
@@ lines 503-509 @@
-           });
-         } else {
-           // For regular groups
-           return (currentGroup.layers || []).map(async (layer): Promise<PopupData | null> => {
-             try {
-               // Get the existing layer from layerStates
-               const existingLayer = this.layerStates[layer.id]?.layer;
---
+           });
+         } else {
+           // For regular groups
+           return (currentGroup.layers || []).map(async (layer: any): Promise<PopupData | null> => {
+             try {
+               // Get the existing layer from layerStates
+               const existingLayer = this.layerStates[layer.id]?.layer;
+               if (!existingLayer) {
+                 console.warn(`No existing layer found for ${layer.id}`);
+                 return null;
@@ lines 549-556 @@
-               }
- 
-               const values = statsResult.features
-                 .map(f => f.attributes[valueField])
-                 .filter(v => v !== null && v !== undefined && !isNaN(v));
-               
-               if (values.length === 0) {
-                 console.warn(`No valid values found for layer ${layer.name} using field ${valueField}`);
---
+               }
+ 
+               const values = statsResult.features
+                 .map(f: any => f.attributes[valueField])
+                 .filter(v: any => v !== null && v !== undefined && !isNaN(v));
+               
+               if (values.length === 0) {
+                 console.warn(`No valid values found for layer ${layer.name} using field ${valueField}`);
+                 return null;
+               }
+ 
@@ lines 560-566 @@
-               // Calculate statistics
-               const min = Math.min(...values);
-               const max = Math.max(...values);
-               const median = values.sort((a, b) => a - b)[Math.floor(values.length / 2)];
-               const currentValue = result.features[0]?.attributes[valueField] || 0;
- 
-               if (result.features.length === 0) {
---
+               // Calculate statistics
+               const min = Math.min(...values);
+               const max = Math.max(...values);
+               const median = values.sort((a: any, b: any) => a - b)[Math.floor(values.length / 2)];
+               const currentValue = result.features[0]?.attributes[valueField] || 0;
+ 
+               if (result.features.length === 0) {
+                 console.log(`DEBUG: No features found for ${layer.name}`);
+                 return null;
+               }
@@ lines 594-600 @@
-       })();
- 
-       const results = await Promise.all(queryPromises);
-       const filteredResults = results.filter((result): result is PopupData => result !== null);
-       console.log('DEBUG: Final query results:', filteredResults);
-       return filteredResults;
-     } catch (error) {
---
+       })();
+ 
+       const results = await Promise.all(queryPromises);
+       const filteredResults = results.filter((result: any): result is PopupData => result !== null);
+       console.log('DEBUG: Final query results:', filteredResults);
+       return filteredResults;
+     } catch (error) {
+       console.error('DEBUG: Error in queryRelatedLayers:', error);
+       return [];
+     }
@@ lines 645-651 @@
-     contentContainer.className = 'popup-content-container';
- 
-     // Create all tabs first
-     tabs.forEach((tab, index) => {
-       console.log(`DEBUG: Creating tab ${tab.id}`);
-       
-       const button = document.createElement('button');
---
+     contentContainer.className = 'popup-content-container';
+ 
+     // Create all tabs first
+     tabs.forEach((tab: any, index: any) => {
+       console.log(`DEBUG: Creating tab ${tab.id}`);
+       
+       const button = document.createElement('button');
+       button.className = `popup-tab-button ${index === 0 ? 'active' : ''}`;
+       button.textContent = tab.title;
+       tabsNav.appendChild(button);
@@ lines 665-674 @@
-       
-       button.addEventListener('click', () => {
-         // Remove active class from all buttons and contents
-         tabsNav.querySelectorAll('.popup-tab-button').forEach(btn => 
-           btn.classList.remove('active')
-         );
-         contentContainer.querySelectorAll('.popup-tab-content').forEach(content => 
-           content.classList.remove('active')
-         );
-         
---
+       
+       button.addEventListener('click', () => {
+         // Remove active class from all buttons and contents
+         tabsNav.querySelectorAll('.popup-tab-button').forEach(btn: any => 
+           btn.classList.remove('active')
+         );
+         contentContainer.querySelectorAll('.popup-tab-content').forEach(content: any => 
+           content.classList.remove('active')
+         );
+         
+         // Add active class to clicked button and corresponding content
+         button.classList.add('active');
+         content.classList.add('active');
@@ lines 717-729 @@
-       const region = this.layerConfig.id.endsWith('ON') ? 'ON' : 'BC';
-       
-       // Filter data to only include layers from the same region
-       return this.data.filter(item => 
-         item.groupId === 'google-trends-group' && 
-         item.layerId.endsWith(region)
-       );
-     }
-     
-     return this.data.filter(item => item.groupId === groupId);
-   }
- 
-   private createTabContent(container: HTMLElement, tab: TabConfig, data: PopupData[]): void {
---
+       const region = this.layerConfig.id.endsWith('ON') ? 'ON' : 'BC';
+       
+       // Filter data to only include layers from the same region
+       return this.data.filter(item: any => 
+         item.groupId === 'google-trends-group' && 
+         item.layerId.endsWith(region)
+       );
+     }
+     
+     return this.data.filter(item: any => item.groupId === groupId);
+   }
+ 
+   private createTabContent(container: HTMLElement, tab: TabConfig, data: PopupData[]): void {
+     console.log(`Creating content for tab ${tab.id} with data:`, data);
+ 
+     if (data.length === 0) {
@@ lines 756-762 @@
-     container.appendChild(chartSection);
-     
-     // Create chart data with statistics
-     const chartData = data.map(d => {
-       const valueField = d.type === 'index' ? d.rendererField : 
-         Object.entries(d.values).find(([key, value]) => 
-           typeof value === 'number' && 
---
+     container.appendChild(chartSection);
+     
+     // Create chart data with statistics
+     const chartData = data.map(d: any => {
+       const valueField = d.type === 'index' ? d.rendererField : 
+         Object.entries(d.values).find(([key, value]) => 
+           typeof value === 'number' && 
+           !key.toLowerCase().includes('id') && 
+           !key.toLowerCase().includes('objectid') &&
+           !key.toLowerCase().includes('shape') &&
@@ lines 797-812 @@
-     });
- 
-     // Sort data by current value (highest first)
-     chartData.sort((a, b) => b.currentValue - a.currentValue);
- 
-     // Create the chart
-     new ChartJS(canvas, {
-       type: 'bar',
-       data: {
-         labels: chartData.map(d => d.label),
-         datasets: [{
-           data: chartData.map(d => d.currentValue),
-             backgroundColor: chartData.map((_, index) => 
-             DEFAULT_COLORS[index % DEFAULT_COLORS.length]
-             ),
-           borderColor: '#ffffff',
---
+     });
+ 
+     // Sort data by current value (highest first)
+     chartData.sort((a: any, b: any) => b.currentValue - a.currentValue);
+ 
+     // Create the chart
+     new ChartJS(canvas, {
+       type: 'bar',
+       data: {
+         labels: chartData.map(d: any => d.label),
+         datasets: [{
+           data: chartData.map(d: any => d.currentValue),
+             backgroundColor: chartData.map((_: any, index: any) => 
+             DEFAULT_COLORS[index % DEFAULT_COLORS.length]
+             ),
+           borderColor: '#ffffff',
+           borderWidth: 1
+         }]
+       },
@@ lines 831-837 @@
-           },
-           tooltip: {
-             callbacks: {
-               label: (context) => {
-                 const data = chartData[context.dataIndex];
-                 const currentValue = data.currentValue.toFixed(2);
-                 const min = data.min.toFixed(2);
---
+           },
+           tooltip: {
+             callbacks: {
+               label: (context: any) => {
+                 const data = chartData[context.dataIndex];
+                 const currentValue = data.currentValue.toFixed(2);
+                 const min = data.min.toFixed(2);
+                 const max = data.max.toFixed(2);
+                 const median = data.median.toFixed(2);
+                 const unit = data.isGoogleTrendsLayer ? '%' : '';
@@ lines 853-859 @@
-             max: 100,
-             title: {
-               display: true,
-               text: chartData.some(d => d.isGoogleTrendsLayer) ? 'Normalized Value (%)' : 'Value'
-             }
-           }
-         }
---
+             max: 100,
+             title: {
+               display: true,
+               text: chartData.some(d: any => d.isGoogleTrendsLayer) ? 'Normalized Value (%)' : 'Value'
+             }
+           }
+         }
+       }
+     });
+   }
@@ lines 880-895 @@
-         party: votingData[`Party_${key.split('_')[1]}`] as string,
-         votes: votingData[`Votes_${key.split('_')[1]}`] as number
-       }))
-       .sort((a, b) => b.votes - a.votes);
- 
-     // Create pie chart
-     new ChartJS(canvas, {
-       type: 'pie',
-       data: {
-         labels: candidates.map(c => `${c.name} (${c.party})`),
-         datasets: [{
-           data: candidates.map(c => c.votes),
-           backgroundColor: candidates.map((_, index) => 
-             DEFAULT_COLORS[index % DEFAULT_COLORS.length]
-           ),
-           borderColor: '#ffffff',
---
+         party: votingData[`Party_${key.split('_')[1]}`] as string,
+         votes: votingData[`Votes_${key.split('_')[1]}`] as number
+       }))
+       .sort((a: any, b: any) => b.votes - a.votes);
+ 
+     // Create pie chart
+     new ChartJS(canvas, {
+       type: 'pie',
+       data: {
+         labels: candidates.map(c: any => `${c.name} (${c.party})`),
+         datasets: [{
+           data: candidates.map(c: any => c.votes),
+           backgroundColor: candidates.map((_: any, index: any) => 
+             DEFAULT_COLORS[index % DEFAULT_COLORS.length]
+           ),
+           borderColor: '#ffffff',
+           borderWidth: 1
+         }]
+       },
@@ lines 918-926 @@
-           },
-           tooltip: {
-             callbacks: {
-               label: (context) => {
-                 const candidate = candidates[context.dataIndex];
-                 const percentage = ((candidate.votes / candidates.reduce((sum, c) => sum + c.votes, 0)) * 100).toFixed(1);
-                 return `${candidate.name} (${candidate.party}): ${candidate.votes.toLocaleString()} votes (${percentage}%)`;
-               }
-             }
---
+           },
+           tooltip: {
+             callbacks: {
+               label: (context: any) => {
+                 const candidate = candidates[context.dataIndex];
+                 const percentage = ((candidate.votes / candidates.reduce((sum: any, c: any) => sum + c.votes, 0)) * 100).toFixed(1);
+                 return `${candidate.name} (${candidate.party}): ${candidate.votes.toLocaleString()} votes (${percentage}%)`;
+               }
+             }
+           }
+         }
+       }
@@ lines 947-954 @@
-         </tr>
-       </thead>
-       <tbody>
-         ${candidates.map(candidate => {
-           const percentage = ((candidate.votes / candidates.reduce((sum, c) => sum + c.votes, 0)) * 100).toFixed(1);
-           return `
-             <tr>
-               <td>${candidate.name}</td>
---
+         </tr>
+       </thead>
+       <tbody>
+         ${candidates.map(candidate: any => {
+           const percentage = ((candidate.votes / candidates.reduce((sum: any, c: any) => sum + c.votes, 0)) * 100).toFixed(1);
+           return `
+             <tr>
+               <td>${candidate.name}</td>
+               <td>${candidate.party}</td>
+               <td>${candidate.votes.toLocaleString()}</td>
+               <td>${percentage}%</td>
@@ lines 1005-1011 @@
-   }
- 
-   private createGoogleTrendsContent(container: HTMLElement, data: PopupData[]): void {
-     console.log('DEBUG: createGoogleTrendsContent received data:', data.map(d => ({
-       layerName: d.layerName,
-       layerId: d.layerId,
-       values: d.values,
---
+   }
+ 
+   private createGoogleTrendsContent(container: HTMLElement, data: PopupData[]): void {
+     console.log('DEBUG: createGoogleTrendsContent received data:', data.map(d: any => ({
+       layerName: d.layerName,
+       layerId: d.layerId,
+       values: d.values,
+       rendererField: d.rendererField,
+       stats: d.stats,
+       rawValue: d.values[d.layerId] // Use d.layerId to access the value
@@ lines 1039-1045 @@
-       }
-       
-       // Check if the clicked area has data
-       const activeLayerData = data.find(d => d.layerId === activeLayerId);
-       const rawValue = activeLayerData?.values[activeLayerId];
-       hasData = rawValue !== null && rawValue !== undefined && !isNaN(rawValue) && rawValue > 0;
-       
---
+       }
+       
+       // Check if the clicked area has data
+       const activeLayerData = data.find(d: any => d.layerId === activeLayerId);
+       const rawValue = activeLayerData?.values[activeLayerId];
+       hasData = rawValue !== null && rawValue !== undefined && !isNaN(rawValue) && rawValue > 0;
+       
+       console.log('DEBUG: Area name extraction:', {
+         areaName,
+         hasData,
@@ lines 1055-1061 @@
-     const region = activeLayerId.endsWith('ON') ? 'Ontario' : 'British Columbia';
-     
-     // Get active layer name
-     const activeLayerData = data.find(d => d.layerId === activeLayerId);
-     const activeLayerName = activeLayerData ? activeLayerData.layerName : "Selected Topic";
-     
-     // Add special note if the area has no data
---
+     const region = activeLayerId.endsWith('ON') ? 'Ontario' : 'British Columbia';
+     
+     // Get active layer name
+     const activeLayerData = data.find(d: any => d.layerId === activeLayerId);
+     const activeLayerName = activeLayerData ? activeLayerData.layerName : "Selected Topic";
+     
+     // Add special note if the area has no data
+     const noDataText = hasData ? '' : '<p style="font-size: 14px; margin: 4px 0; color: #e53e3e;"><strong>This area has little to no search data and appears in the lowest category on the map.</strong></p>';
+     
+     headerSection.innerHTML = `
@@ lines 1084-1091 @@
- 
-     // Process the data - always treating no-data as 0
-     const trendData = data
-       .filter(d => d.values !== undefined && d.layerId !== undefined)
-       .map(d => {
-         // Get the value directly from the feature attributes using the layer ID
-         // Make sure no-data is treated as 0
-         const rawValue = d.values[d.layerId];
---
+ 
+     // Process the data - always treating no-data as 0
+     const trendData = data
+       .filter(d: any => d.values !== undefined && d.layerId !== undefined)
+       .map(d: any => {
+         // Get the value directly from the feature attributes using the layer ID
+         // Make sure no-data is treated as 0
+         const rawValue = d.values[d.layerId];
+         const value = rawValue !== null && rawValue !== undefined && !isNaN(rawValue) ? rawValue : 0;
+         
+         console.log('DEBUG: Processing trend data for layer:', {
@@ lines 1109-1115 @@
-       });
- 
-     // Sort data: active layer first, then remaining by descending value
-     const sortedTrendData = trendData.sort((a, b) => {
-       // Active layer always comes first
-       if (a.layerId === activeLayerId) return -1;
-       if (b.layerId === activeLayerId) return 1;
---
+       });
+ 
+     // Sort data: active layer first, then remaining by descending value
+     const sortedTrendData = trendData.sort((a: any, b: any) => {
+       // Active layer always comes first
+       if (a.layerId === activeLayerId) return -1;
+       if (b.layerId === activeLayerId) return 1;
+       // Otherwise sort by value (descending)
+       return b.value - a.value;
+     });
@@ lines 1123-1139 @@
-     new ChartJS(canvas, {
-       type: 'bar',
-       data: {
-         labels: sortedTrendData.map(d => d.label),
-         datasets: [
-           {
-             label: 'Interest Index',
-             data: sortedTrendData.map(d => d.value),
-             backgroundColor: sortedTrendData.map((d, index) => 
-               d.layerId === activeLayerId 
-                 ? '#33a852' // Highlight active layer with green
-                 : DEFAULT_COLORS[index % DEFAULT_COLORS.length]
-             ),
-             borderColor: sortedTrendData.map((d, index) => 
-               d.layerId === activeLayerId 
-                 ? '#33a852' // Highlight active layer with green
-                 : DEFAULT_COLORS[index % DEFAULT_COLORS.length]
---
+     new ChartJS(canvas, {
+       type: 'bar',
+       data: {
+         labels: sortedTrendData.map(d: any => d.label),
+         datasets: [
+           {
+             label: 'Interest Index',
+             data: sortedTrendData.map(d: any => d.value),
+             backgroundColor: sortedTrendData.map((d: any, index: any) => 
+               d.layerId === activeLayerId 
+                 ? '#33a852' // Highlight active layer with green
+                 : DEFAULT_COLORS[index % DEFAULT_COLORS.length]
+             ),
+             borderColor: sortedTrendData.map((d: any, index: any) => 
+               d.layerId === activeLayerId 
+                 ? '#33a852' // Highlight active layer with green
+                 : DEFAULT_COLORS[index % DEFAULT_COLORS.length]
+             ),
+             borderWidth: 1,
+             barThickness: 20
@@ lines 1160-1166 @@
-           },
-           tooltip: {
-             callbacks: {
-               label: (context) => {
-                 const data = sortedTrendData[context.dataIndex];
-                 return [
-                   `Index Value: ${data.value.toFixed(0)}`,
---
+           },
+           tooltip: {
+             callbacks: {
+               label: (context: any) => {
+                 const data = sortedTrendData[context.dataIndex];
+                 return [
+                   `Index Value: ${data.value.toFixed(0)}`,
+                   `Range: 0-100`,
+                   data.layerId === activeLayerId ? '(Current layer)' : ''
+                 ].filter(Boolean);
@@ lines 1217-1223 @@
-                 return lines;
-               }
-             },
-             afterFit: function(scaleInstance) {
-               // Add padding to the scale to accommodate wrapped labels
-               scaleInstance.paddingBottom = 20;
-             }
---
+                 return lines;
+               }
+             },
+             afterFit: function(scaleInstance: any) {
+               // Add padding to the scale to accommodate wrapped labels
+               scaleInstance.paddingBottom = 20;
+             }
+           }
+         }
+       }
@@ lines 1255-1265 @@
- 
-     // Finally, try to get from the map's layers
-     const mapLayers = this.view.map.allLayers.toArray();
-     const featureLayers = mapLayers.filter(layer => layer.type === 'feature') as __esri.FeatureLayer[];
-     
-     if (featureLayers.length > 0) {
-       const reconstructedLayerStates: { [key: string]: { layer: __esri.FeatureLayer | null } } = {};
-       featureLayers.forEach(layer => {
-         reconstructedLayerStates[layer.id] = { layer };
-       });
-       return reconstructedLayerStates;
---
+ 
+     // Finally, try to get from the map's layers
+     const mapLayers = this.view.map.allLayers.toArray();
+     const featureLayers = mapLayers.filter(layer: any => layer.type === 'feature') as __esri.FeatureLayer[];
+     
+     if (featureLayers.length > 0) {
+       const reconstructedLayerStates: { [key: string]: { layer: __esri.FeatureLayer | null } } = {};
+       featureLayers.forEach(layer: any => {
+         reconstructedLayerStates[layer.id] = { layer };
+       });
+       return reconstructedLayerStates;
+     }
+ 
+     return null;
@@ lines 1320-1326 @@
-           }
-         }
-       ],
-       actions: this.config.actions?.map(action => ({
-         type: "button" as const,
-         id: action.id,
-         title: action.title,
---
+           }
+         }
+       ],
+       actions: this.config.actions?.map(action: any => ({
+         type: "button" as const,
+         id: action.id,
+         title: action.title,
+         className: action.className
+       }))
+     });
@@ lines 1345-1355 @@
- // Remove all project-specific popup config functions and replace with a generic one
- function createDefaultPopupConfig(layerConfig: LayerConfig, layerGroups: LayerGroup[]): EnhancedPopupConfig {
-   // Check if this is a Google Trends layer
-   const isGoogleTrendsLayer = layerGroups.some(group => 
-     group.id === 'google-trends-group' && 
-     (group.layers?.some(l => l.id === layerConfig.id) || 
-      group.subGroups?.some(subGroup => 
-        subGroup && subGroup.layers?.some(l => l.id === layerConfig.id)
-      ))
-   );
- 
---
+ // Remove all project-specific popup config functions and replace with a generic one
+ function createDefaultPopupConfig(layerConfig: LayerConfig, layerGroups: LayerGroup[]): EnhancedPopupConfig {
+   // Check if this is a Google Trends layer
+   const isGoogleTrendsLayer = layerGroups.some(group: any => 
+     group.id === 'google-trends-group' && 
+     (group.layers?.some(l: any => l.id === layerConfig.id) || 
+      group.subGroups?.some(subGroup: any => 
+        subGroup && subGroup.layers?.some(l: any => l.id === layerConfig.id)
+      ))
+   );
+ 
+   if (isGoogleTrendsLayer) {
+     return {
+       title: "{CSDNAME}",
@@ lines 1386-1392 @@
-   }
- 
-   // Create tabs dynamically from layer groups for non-Google Trends layers
-   const tabs = layerGroups.map(group => ({
-     id: group.id,
-     title: group.title,
-     content: 'chart' as const,
---
+   }
+ 
+   // Create tabs dynamically from layer groups for non-Google Trends layers
+   const tabs = layerGroups.map(group: any => ({
+     id: group.id,
+     title: group.title,
+     content: 'chart' as const,
+     chartOptions: {
+       type: 'bar' as const,
+       title: `${group.title} Comparison`,


*** FILE: components/map/SampleAreasPanel.tsx
@@ lines 237-243 @@
-     console.log('[SampleAreasPanel] First area:', preJoinedData.areas[0]);
-     
-     // Convert areas to ZipCodeArea format first
-     const zipCodeAreas: ZipCodeArea[] = preJoinedData.areas.map((area) => ({
-       zipCode: area.zipCode,
-       city: area.city,
-       geometry: area.geometry,
---
+     console.log('[SampleAreasPanel] First area:', preJoinedData.areas[0]);
+     
+     // Convert areas to ZipCodeArea format first
+     const zipCodeAreas: ZipCodeArea[] = preJoinedData.areas.map((area: any) => ({
+       zipCode: area.zipCode,
+       city: area.city,
+       geometry: area.geometry,
+       bounds: area.bounds,
+       
+       // Map our real stats to the expected housing fields
@@ lines 257-263 @@
-     console.log('[SampleAreasPanel] Converted to ZipCodeArea format:', zipCodeAreas.length);
-     
-     // Group areas by city for display
-     const cityGroups = zipCodeAreas.reduce((groups, area) => {
-       const city = area.city;
-       if (!groups[city]) {
-         groups[city] = [];
---
+     console.log('[SampleAreasPanel] Converted to ZipCodeArea format:', zipCodeAreas.length);
+     
+     // Group areas by city for display
+     const cityGroups = zipCodeAreas.reduce((groups: any, area: any) => {
+       const city = area.city;
+       if (!groups[city]) {
+         groups[city] = [];
+       }
+       groups[city].push(area);
+       return groups;
@@ lines 267-280 @@
-     }, {} as { [city: string]: ZipCodeArea[] });
-     
-     // Create display areas from city groups
-     const areas: DisplaySampleArea[] = Object.entries(cityGroups).map(([city, zipCodes], index) => {
-       // Calculate combined bounds for all ZIP codes in the city
-       const allBounds = zipCodes.map(z => z.bounds);
-       const combinedBounds = {
-         xmin: Math.min(...allBounds.map(b => b.xmin)),
-         ymin: Math.min(...allBounds.map(b => b.ymin)),
-         xmax: Math.max(...allBounds.map(b => b.xmax)),
-         ymax: Math.max(...allBounds.map(b => b.ymax))
-       };
-       
-       return {
---
+     }, {} as { [city: string]: ZipCodeArea[] });
+     
+     // Create display areas from city groups
+     const areas: DisplaySampleArea[] = Object.entries(cityGroups).map(([city, zipCodes], index: any) => {
+       // Calculate combined bounds for all ZIP codes in the city
+       const allBounds = zipCodes.map(z: any => z.bounds);
+       const combinedBounds = {
+         xmin: Math.min(...allBounds.map(b: any => b.xmin)),
+         ymin: Math.min(...allBounds.map(b: any => b.ymin)),
+         xmax: Math.max(...allBounds.map(b: any => b.xmax)),
+         ymax: Math.max(...allBounds.map(b: any => b.ymax))
+       };
+       
+       return {
+         id: `${city.replace(/\s+/g, '_').toLowerCase()}-${index}`,
+         name: `${city} (${zipCodes.length} FSAs)`,
+         zipCodes: zipCodes,
@@ lines 305-311 @@
-     console.log('[SampleAreasPanel] Selected random metrics:', randomMetrics);
-     
-     // Convert Quebec housing data to ZipCodeArea format
-     const zipCodes: ZipCodeArea[] = sampleData.map((area) => ({
-       zipCode: area.id, // FSA code like "G0A"
-       city: area.name,
-       geometry: {
---
+     console.log('[SampleAreasPanel] Selected random metrics:', randomMetrics);
+     
+     // Convert Quebec housing data to ZipCodeArea format
+     const zipCodes: ZipCodeArea[] = sampleData.map((area: any) => ({
+       zipCode: area.id, // FSA code like "G0A"
+       city: area.name,
+       geometry: {
+         type: "Polygon",
+         coordinates: [[
+           [-73.98, 45.41], [-73.48, 45.41], [-73.48, 45.71], [-73.98, 45.71], [-73.98, 45.41]
@@ lines 380-396 @@
-       citiesMap.get(cityKey)!.push(area);
-     });
-     
-     console.log('[SampleAreasPanel] STEP 3b - Cities grouped:', Array.from(citiesMap.keys()).map(city => `${city}: ${citiesMap.get(city)?.length} ZIPs`));
-     
-     // Convert to DisplaySampleArea format
-     const areas: DisplaySampleArea[] = [];
-     
-     citiesMap.forEach((zipAreas, cityKey) => {
-       const cityName = zipAreas[0].city;
-       console.log(`[SampleAreasPanel] STEP 4a - Processing city ${cityName} with ${zipAreas.length} ZIP codes`);
-       
-       // Convert areas to ZipCodeArea format with real geometry and demographics
-       const zipCodes: ZipCodeArea[] = zipAreas.map((area, index) => {
-         const demo = area.demographics;
-         
-         if (index < 3) {
---
+       citiesMap.get(cityKey)!.push(area);
+     });
+     
+     console.log('[SampleAreasPanel] STEP 3b - Cities grouped:', Array.from(citiesMap.keys()).map(city: any => `${city}: ${citiesMap.get(city)?.length} ZIPs`));
+     
+     // Convert to DisplaySampleArea format
+     const areas: DisplaySampleArea[] = [];
+     
+     citiesMap.forEach((zipAreas: any, cityKey: any) => {
+       const cityName = zipAreas[0].city;
+       console.log(`[SampleAreasPanel] STEP 4a - Processing city ${cityName} with ${zipAreas.length} ZIP codes`);
+       
+       // Convert areas to ZipCodeArea format with real geometry and demographics
+       const zipCodes: ZipCodeArea[] = zipAreas.map((area: any, index: any) => {
+         const demo = area.demographics;
+         
+         if (index < 3) {
+           console.log(`[DEBUG] ${cityName} FSA ${area.zipCode}:`);
+           console.log('  Demographics keys:', demo ? Object.keys(demo) : 'NO DEMO');
+           console.log('  Homeowner value:', demo ? demo['Homeownership Rate (%)'] : 'NO DEMO');
@@ lines 424-430 @@
-       // Use bookmark extents to ensure same zoom level as bookmarks widget
-       const combinedBounds = BOOKMARK_EXTENTS[cityKey] || {
-         // Fallback: calculate from ZIP codes if no bookmark extent available
-         ...zipCodes.reduce((bounds, zip) => {
-           if (!zip.bounds) {
-             console.log(`[SampleAreasPanel] WARNING: ZIP ${zip.zipCode} has no bounds`);
-             return bounds;
---
+       // Use bookmark extents to ensure same zoom level as bookmarks widget
+       const combinedBounds = BOOKMARK_EXTENTS[cityKey] || {
+         // Fallback: calculate from ZIP codes if no bookmark extent available
+         ...zipCodes.reduce((bounds: any, zip: any) => {
+           if (!zip.bounds) {
+             console.log(`[SampleAreasPanel] WARNING: ZIP ${zip.zipCode} has no bounds`);
+             return bounds;
+           }
+           return {
+             xmin: Math.min(bounds.xmin, zip.bounds.xmin),
@@ lines 456-462 @@
-     
-     setDisplayAreas(() => areas);
-     console.log('[SampleAreasPanel] STEP 5 - Created', areas.length, 'display areas from real data');
-     console.log('[SampleAreasPanel] STEP 5 - Available cities:', areas.map(a => `${a.name} (${a.zipCodes.length} ZIPs)`));
-     
-     // Create the choropleth layers on the map
-     createChoroplethLayers(areas);
---
+     
+     setDisplayAreas(() => areas);
+     console.log('[SampleAreasPanel] STEP 5 - Created', areas.length, 'display areas from real data');
+     console.log('[SampleAreasPanel] STEP 5 - Available cities:', areas.map(a: any => `${a.name} (${a.zipCodes.length} ZIPs)`));
+     
+     // Create the choropleth layers on the map
+     createChoroplethLayers(areas);
+     
+     // Don't auto-zoom - let MapClient handle initial view
+     // setTimeout(() => zoomToMontreal(), 1000);
@@ lines 539-549 @@
-         
-         // Calculate city-specific quartiles for coloring
-         const firstMetric = selectedMetrics[0] || 'homeowner_percent';
-         const metricValues = area.zipCodes.map(z => z[firstMetric as keyof ZipCodeArea] as number).sort((a, b) => a - b);
-         const cityBreaks = calculateMetricQuartiles(metricValues, firstMetric);
-         
-         // Apply colors directly to graphics based on quartiles
-         cityGraphics.forEach(graphic => {
-           const value = graphic.attributes[firstMetric];
-           let colorIndex = 0;
-           if (value > cityBreaks[3]) colorIndex = 3;
---
+         
+         // Calculate city-specific quartiles for coloring
+         const firstMetric = selectedMetrics[0] || 'homeowner_percent';
+         const metricValues = area.zipCodes.map(z: any => z[firstMetric as keyof ZipCodeArea] as number).sort((a: any, b: any) => a - b);
+         const cityBreaks = calculateMetricQuartiles(metricValues, firstMetric);
+         
+         // Apply colors directly to graphics based on quartiles
+         cityGraphics.forEach(graphic: any => {
+           const value = graphic.attributes[firstMetric];
+           let colorIndex = 0;
+           if (value > cityBreaks[3]) colorIndex = 3;
+           else if (value > cityBreaks[2]) colorIndex = 2;
+           else if (value > cityBreaks[1]) colorIndex = 1;
+           
@@ lines 576-585 @@
-   const zoomToMontreal = () => {
-     if (!view) return;
- 
-     console.log('[zoomToMontreal] Looking for Montreal in areas:', displayAreas.map(a => a.id));
-     
-     // Find Montreal area in displayAreas
-     const montrealArea = displayAreas.find(area => area.id === 'montreal');
-     if (montrealArea) {
-       console.log('[zoomToMontreal] Found Montreal area, zooming...');
-       handleAreaClick(montrealArea);
---
+   const zoomToMontreal = () => {
+     if (!view) return;
+ 
+     console.log('[zoomToMontreal] Looking for Montreal in areas:', displayAreas.map(a: any => a.id));
+     
+     // Find Montreal area in displayAreas
+     const montrealArea = displayAreas.find(area: any => area.id === 'montreal');
+     if (montrealArea) {
+       console.log('[zoomToMontreal] Found Montreal area, zooming...');
+       handleAreaClick(montrealArea);
+     } else {
+       console.log('[zoomToMontreal] Montreal area not found, using bookmark extent');
+       // Fallback: use bookmark extent for Montreal
@@ lines 598-604 @@
-       view.goTo(montrealExtent, {
-         duration: 2000,
-         easing: 'ease-in-out'
-       }).catch(error => {
-         console.error('Error zooming to Montreal:', error);
-       });
-       
---
+       view.goTo(montrealExtent, {
+         duration: 2000,
+         easing: 'ease-in-out'
+       }).catch(error: any => {
+         console.error('Error zooming to Montreal:', error);
+       });
+       
+       console.log('[SampleAreasPanel] Zoomed to Montreal fallback coordinates');
+     }
+   };
@@ lines 610-616 @@
-     if (!view || areas.length === 0) return;
-     
-     // Calculate overall bounds from all cities
-     const overallBounds = areas.reduce((bounds, area) => ({
-       xmin: Math.min(bounds.xmin, area.combinedBounds.xmin),
-       ymin: Math.min(bounds.ymin, area.combinedBounds.ymin),
-       xmax: Math.max(bounds.xmax, area.combinedBounds.xmax),
---
+     if (!view || areas.length === 0) return;
+     
+     // Calculate overall bounds from all cities
+     const overallBounds = areas.reduce((bounds: any, area: any) => ({
+       xmin: Math.min(bounds.xmin, area.combinedBounds.xmin),
+       ymin: Math.min(bounds.ymin, area.combinedBounds.ymin),
+       xmax: Math.max(bounds.xmax, area.combinedBounds.xmax),
+       ymax: Math.max(bounds.ymax, area.combinedBounds.ymax)
+     }), {
+       xmin: Infinity,
@@ lines 634-640 @@
-       view.goTo(extent, {
-         duration: 2000,
-         easing: 'ease-in-out'
-       }).catch(error => {
-         console.error('Error zooming to combined extent:', error);
-       });
-       
---
+       view.goTo(extent, {
+         duration: 2000,
+         easing: 'ease-in-out'
+       }).catch(error: any => {
+         console.error('Error zooming to combined extent:', error);
+       });
+       
+       console.log('[SampleAreasPanel] Zoomed to combined extent of all ZIP codes');
+     } catch (error) {
+       console.error('Error creating combined extent:', error);
@@ lines 650-656 @@
-     // Calculate quartile breaks for a city's population values
-     if (values.length === 0) return [0, 40000, 60000, 80000, 100000];
-     
-     const sorted = [...values].sort((a, b) => a - b);
-     const q1Index = Math.floor(sorted.length * 0.25);
-     const q2Index = Math.floor(sorted.length * 0.5);
-     const q3Index = Math.floor(sorted.length * 0.75);
---
+     // Calculate quartile breaks for a city's population values
+     if (values.length === 0) return [0, 40000, 60000, 80000, 100000];
+     
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const q1Index = Math.floor(sorted.length * 0.25);
+     const q2Index = Math.floor(sorted.length * 0.5);
+     const q3Index = Math.floor(sorted.length * 0.75);
+     
+     return [
+       sorted[0],
@@ lines 677-683 @@
-       }
-     }
-     
-     const sorted = [...values].sort((a, b) => a - b);
-     const q1Index = Math.floor(sorted.length * 0.25);
-     const q2Index = Math.floor(sorted.length * 0.5);
-     const q3Index = Math.floor(sorted.length * 0.75);
---
+       }
+     }
+     
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const q1Index = Math.floor(sorted.length * 0.25);
+     const q2Index = Math.floor(sorted.length * 0.5);
+     const q3Index = Math.floor(sorted.length * 0.75);
+     
+     return [
+       sorted[0],
@@ lines 758-764 @@
-     // Remove all sample area graphics from map view
-     if (view && view.graphics) {
-       // Filter out only our sample area graphics (those with zipCode attribute)
-       const sampleGraphics = view.graphics.toArray().filter(graphic => 
-         graphic.attributes && graphic.attributes.zipCode
-       );
-       console.log(`[SampleAreasPanel] Removing ${sampleGraphics.length} sample area graphics`);
---
+     // Remove all sample area graphics from map view
+     if (view && view.graphics) {
+       // Filter out only our sample area graphics (those with zipCode attribute)
+       const sampleGraphics = view.graphics.toArray().filter(graphic: any => 
+         graphic.attributes && graphic.attributes.zipCode
+       );
+       console.log(`[SampleAreasPanel] Removing ${sampleGraphics.length} sample area graphics`);
+       view.graphics.removeMany(sampleGraphics);
+     }
+   setChoroplethLayers(new Map());
@@ lines 798-804 @@
-     return () => {
-       console.log('[SampleAreasPanel] Component unmounting - cleaning up graphics');
-       if (view && view.graphics && !view.destroyed) {
-         const sampleGraphics = view.graphics.toArray().filter(graphic => 
-           graphic.attributes && graphic.attributes.zipCode
-         );
-         if (sampleGraphics.length > 0) {
---
+     return () => {
+       console.log('[SampleAreasPanel] Component unmounting - cleaning up graphics');
+       if (view && view.graphics && !view.destroyed) {
+         const sampleGraphics = view.graphics.toArray().filter(graphic: any => 
+           graphic.attributes && graphic.attributes.zipCode
+         );
+         if (sampleGraphics.length > 0) {
+           view.graphics.removeMany(sampleGraphics);
+           console.log(`[SampleAreasPanel] Removed ${sampleGraphics.length} sample graphics on unmount`);
+         }
@@ lines 841-898 @@
-     // Housing project specific metric calculators
-     const metricCalculators: Record<string, { calculate: () => any, label: string, icon: any, format: (val: any) => string }> = {
-       homeowner_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.homeowner_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'Homeowner %',
-         icon: Building,
-         format: (val) => `${val}%`
-       },
-       renter_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.renter_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'Rental %',
-         icon: Building,
-         format: (val) => `${val}%`
-       },
-       housing_affordable_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.housing_affordable_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'Affordable %',
-         icon: DollarSign,
-         format: (val) => `${val}%`
-       },
-       first_time_buyer_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.first_time_buyer_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'First-time %',
-         icon: Building,
-         format: (val) => `${val}%`
-       },
-       high_income_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.high_income_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'High Income %',
-         icon: DollarSign,
-         format: (val) => `${val}%`
-       },
-       young_families_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.young_families_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'Young Families %',
-         icon: Users,
-         format: (val) => `${val}%`
-       },
-       new_construction_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.new_construction_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'New Construction %',
-         icon: Building,
-         format: (val) => `${val}%`
-       },
-       housing_cost_burden_percent: {
-         calculate: () => Math.round((area.zipCodes.reduce((sum, zip) => sum + (zip.housing_cost_burden_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
-         label: 'Cost Burden %',
-         icon: DollarSign,
-         format: (val) => `${val}%`
-       },
-       // Removed genZ_percent - not applicable to housing project
-     };
- 
-     // Use the selectedMetrics to build the stats
-     return selectedMetrics.map(metricKey => {
-       const calculator = metricCalculators[metricKey];
-       if (!calculator) return null;
-       
---
+     // Housing project specific metric calculators
+     const metricCalculators: Record<string, { calculate: () => any, label: string, icon: any, format: (val: any) => string }> = {
+       homeowner_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.homeowner_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'Homeowner %',
+         icon: Building,
+         format: (val: any) => `${val}%`
+       },
+       renter_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.renter_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'Rental %',
+         icon: Building,
+         format: (val: any) => `${val}%`
+       },
+       housing_affordable_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.housing_affordable_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'Affordable %',
+         icon: DollarSign,
+         format: (val: any) => `${val}%`
+       },
+       first_time_buyer_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.first_time_buyer_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'First-time %',
+         icon: Building,
+         format: (val: any) => `${val}%`
+       },
+       high_income_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.high_income_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'High Income %',
+         icon: DollarSign,
+         format: (val: any) => `${val}%`
+       },
+       young_families_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.young_families_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'Young Families %',
+         icon: Users,
+         format: (val: any) => `${val}%`
+       },
+       new_construction_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.new_construction_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'New Construction %',
+         icon: Building,
+         format: (val: any) => `${val}%`
+       },
+       housing_cost_burden_percent: {
+         calculate: () => Math.round((area.zipCodes.reduce((sum: any, zip: any) => sum + (zip.housing_cost_burden_percent || 0), 0) / area.zipCodes.length) * 10) / 10,
+         label: 'Cost Burden %',
+         icon: DollarSign,
+         format: (val: any) => `${val}%`
+       },
+       // Removed genZ_percent - not applicable to housing project
+     };
+ 
+     // Use the selectedMetrics to build the stats
+     return selectedMetrics.map(metricKey: any => {
+       const calculator = metricCalculators[metricKey];
+       if (!calculator) return null;
+       
+       const value = calculator.calculate();
+       return {
+         label: calculator.label,
@@ lines 959-968 @@
-                   display: 'flex',
-                   alignItems: 'center'
-                 }}
-                 onMouseOver={(e) => {
-                   e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
-                 }}
-                 onMouseOut={(e) => {
-                   e.currentTarget.style.backgroundColor = 'transparent';
-                 }}
-                 aria-label="Information about Quick Stats"
---
+                   display: 'flex',
+                   alignItems: 'center'
+                 }}
+                 onMouseOver={(e: any) => {
+                   e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
+                 }}
+                 onMouseOut={(e: any) => {
+                   e.currentTarget.style.backgroundColor = 'transparent';
+                 }}
+                 aria-label="Information about Quick Stats"
+               >
+                 <Info className="h-3 w-3" />
+               </button>
@@ lines 1001-1010 @@
-                 display: 'flex',
-                 alignItems: 'center'
-               }}
-               onMouseEnter={(e) => {
-                 e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
-               }}
-               onMouseLeave={(e) => {
-                 e.currentTarget.style.backgroundColor = 'transparent';
-               }}
-               aria-label="Close panel"
---
+                 display: 'flex',
+                 alignItems: 'center'
+               }}
+               onMouseEnter={(e: any) => {
+                 e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
+               }}
+               onMouseLeave={(e: any) => {
+                 e.currentTarget.style.backgroundColor = 'transparent';
+               }}
+               aria-label="Close panel"
+             >
+               <X className="h-4 w-4" />
+             </button>
@@ lines 1028-1034 @@
-             </div>
-           ) : (
-             <div style={{ borderTop: '1px solid var(--theme-border)' }}>
-               {displayAreas.map((area) => {
-                 const quickStats = getQuickStats(area);
-                 const isSelected = selectedArea === area.id;
-                 
---
+             </div>
+           ) : (
+             <div style={{ borderTop: '1px solid var(--theme-border)' }}>
+               {displayAreas.map((area: any) => {
+                 const quickStats = getQuickStats(area);
+                 const isSelected = selectedArea === area.id;
+                 
+                 return (
+                   <div
+                     key={area.id}
@@ lines 1041-1052 @@
-                       backgroundColor: isSelected ? 'var(--theme-bg-tertiary)' : 'transparent',
-                       borderLeft: isSelected ? '4px solid var(--theme-accent-primary)' : 'none'
-                     }}
-                     onMouseEnter={(e) => {
-                       if (!isSelected) {
-                         e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
-                       }
-                     }}
-                     onMouseLeave={(e) => {
-                       if (!isSelected) {
-                         e.currentTarget.style.backgroundColor = 'transparent';
-                       }
---
+                       backgroundColor: isSelected ? 'var(--theme-bg-tertiary)' : 'transparent',
+                       borderLeft: isSelected ? '4px solid var(--theme-accent-primary)' : 'none'
+                     }}
+                     onMouseEnter={(e: any) => {
+                       if (!isSelected) {
+                         e.currentTarget.style.backgroundColor = 'var(--theme-bg-tertiary)';
+                       }
+                     }}
+                     onMouseLeave={(e: any) => {
+                       if (!isSelected) {
+                         e.currentTarget.style.backgroundColor = 'transparent';
+                       }
+                     }}
+                     onClick={() => handleAreaClick(area)}
+                   >
@@ lines 1065-1071 @@
- 
-                     {/* Quick Stats */}
-                     <div className="grid grid-cols-2 gap-3 mb-3">
-                       {quickStats.map((stat, idx) => stat && (
-                         <div key={idx} className="flex items-center space-x-1">
-                           <stat.icon className="h-3 w-3" style={{ color: '#33a852' }} />
-                           <div>
---
+ 
+                     {/* Quick Stats */}
+                     <div className="grid grid-cols-2 gap-3 mb-3">
+                       {quickStats.map((stat: any, idx: any) => stat && (
+                         <div key={idx} className="flex items-center space-x-1">
+                           <stat.icon className="h-3 w-3" style={{ color: '#33a852' }} />
+                           <div>
+                             <p className="text-xs" style={{ color: 'var(--theme-text-secondary)' }}>
+                               {stat.label}
+                             </p>


*** FILE: lib/analysis/strategies/processors/FeatureInteractionProcessor.ts
@@ lines 187-193 @@
-     }
- 
-     // Variable complexity
-     const activeVars = [strategicScore, demographicScore, nikeShare].filter(v => v > 0).length;
-     interactionScore += (activeVars / 3) * 25; // 25% weight
- 
-     // Non-linear patterns
---
+     }
+ 
+     // Variable complexity
+     const activeVars = [strategicScore, demographicScore, nikeShare].filter(v: any => v > 0).length;
+     interactionScore += (activeVars / 3) * 25; // 25% weight
+ 
+     // Non-linear patterns
+     if (strategicScore > 60 && demographicScore > 80) {
+       interactionScore += 10; // 10% weight for non-linear threshold
+     }
@@ lines 272-278 @@
-       Number((record && record['strategic_value_score']) as unknown) || 0,
-       Number((record && record['demographic_opportunity_score']) as unknown) || 0,
-       Number((record && record['trend_strength_score']) as unknown) || 0
-     ].filter(s => s > 0);
- 
-     let complexity = 0;
- 
---
+       Number((record && record['strategic_value_score']) as unknown) || 0,
+       Number((record && record['demographic_opportunity_score']) as unknown) || 0,
+       Number((record && record['trend_strength_score']) as unknown) || 0
+     ].filter(s: any => s > 0);
+ 
+     let complexity = 0;
+ 
+     // Base complexity from number of active variables
+     complexity += (activeVars / 7) * 40; // Up to 40 points for all variables active
+ 
@@ lines 281-288 @@
- 
-     // Score variance complexity
-     if (scores.length >= 2) {
-       const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
-       const variance = scores.reduce((acc, score) => acc + Math.pow(score - mean, 2), 0) / scores.length;
-       complexity += Math.min(variance / 400, 1) * 35; // Up to 35 points for high variance
-     }
- 
---
+ 
+     // Score variance complexity
+     if (scores.length >= 2) {
+       const mean = scores.reduce((a: any, b: any) => a + b, 0) / scores.length;
+       const variance = scores.reduce((acc: any, score: any) => acc + Math.pow(score - mean, 2), 0) / scores.length;
+       complexity += Math.min(variance / 400, 1) * 35; // Up to 35 points for high variance
+     }
+ 
+     // Population-income complexity — compute locally from the provided record
+   const medianIncome = Number(this.extractFieldValue(['median_income', 'value_AVGHINC_CY', 'AVGHINC_CY', 'household_income'], record)) || 0;
+   const totalPop = Number(this.extractFieldValue(['total_population', 'value_TOTPOP_CY', 'TOTPOP_CY', 'population'], record)) || 0;
@@ lines 352-358 @@
-   Number(this.extractFieldValue(['total_population', 'value_TOTPOP_CY', 'TOTPOP_CY', 'population'], record)) || 0
-     ];
- 
-     return variables.filter(v => v > 0).length;
-   }
- 
-   /**
---
+   Number(this.extractFieldValue(['total_population', 'value_TOTPOP_CY', 'TOTPOP_CY', 'population'], record)) || 0
+     ];
+ 
+     return variables.filter(v: any => v > 0).length;
+   }
+ 
+   /**
+    * Categorize interaction strength
+    */
+   private getInteractionCategory(interactionScore: number): string {
@@ lines 440-448 @@
-    */
-   private rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
-     // Sort by interaction score descending and assign ranks
-     const sorted = [...records].sort((a, b) => b.value - a.value);
-     
-     return sorted.map((record, index) => ({
-       ...record,
-       rank: index + 1
-     }));
---
+    */
+   private rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
+     // Sort by interaction score descending and assign ranks
+     const sorted = [...records].sort((a: any, b: any) => b.value - a.value);
+     
+     return sorted.map((record: any, index: any) => ({
+       ...record,
+       rank: index + 1
+     }));
+   }
+ 
+   /**
@@ lines 452-458 @@
-    * Process feature importance with interaction focus
-    */
-   private processInteractionFeatureImportance(rawFeatureImportance: unknown[]): FeatureImportance[] {
-     const interactionFeatures: FeatureImportance[] = (rawFeatureImportance || []).map(item => {
-       const it = item as Record<string, unknown> | undefined;
-       const featureName = it && (it['feature'] || it['name']) ? String(it['feature'] || it['name']) : 'unknown';
-       const importance = Number((it && (it['importance'] || it['value'])) as unknown) || 0;
---
+    * Process feature importance with interaction focus
+    */
+   private processInteractionFeatureImportance(rawFeatureImportance: unknown[]): FeatureImportance[] {
+     const interactionFeatures: FeatureImportance[] = (rawFeatureImportance || []).map(item: any => {
+       const it = item as Record<string, unknown> | undefined;
+       const featureName = it && (it['feature'] || it['name']) ? String(it['feature'] || it['name']) : 'unknown';
+       const importance = Number((it && (it['importance'] || it['value'])) as unknown) || 0;
+       return {
+         feature: featureName,
+         importance,
@@ lines 461-467 @@
-         importance,
-         description: this.getInteractionFeatureDescription(featureName)
-       };
-     }).filter(fi => !!fi.feature);
- 
-     // Add interaction-specific synthetic features if none provided
-     if (interactionFeatures.length === 0) {
---
+         importance,
+         description: this.getInteractionFeatureDescription(featureName)
+       };
+     }).filter(fi: any => !!fi.feature);
+ 
+     // Add interaction-specific synthetic features if none provided
+     if (interactionFeatures.length === 0) {
+       return [
+         { feature: 'correlation_strength', importance: 0.35, description: 'Strength of correlations between variables' },
+         { feature: 'synergy_effects', importance: 0.30, description: 'Combined effects stronger than individual effects' },
@@ lines 473-479 @@
-       ];
-     }
- 
-     return interactionFeatures.sort((a, b) => b.importance - a.importance);
-   }
- 
-   /**
---
+       ];
+     }
+ 
+     return interactionFeatures.sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   /**
+    * Get interaction-specific feature descriptions
+    */
+   private getInteractionFeatureDescription(featureName: string): string {
@@ lines 510-516 @@
-    * Calculate interaction-specific statistics
-    */
-   private calculateInteractionStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const values = records.map(r => r.value).filter(v => !isNaN(v));
-     
-     if (values.length === 0) {
-       return {
---
+    * Calculate interaction-specific statistics
+    */
+   private calculateInteractionStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v));
+     
+     if (values.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         percentile25: 0, percentile75: 0, iqr: 0, outlierCount: 0
+       };
@@ lines 519-527 @@
-       };
-     }
-     
-     const sorted = [...values].sort((a, b) => a - b);
-     const total = values.length;
-     const sum = values.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     // Calculate percentiles
---
+       };
+     }
+     
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const total = values.length;
+     const sum = values.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     // Calculate percentiles
+     const p25Index = Math.floor(total * 0.25);
+     const p75Index = Math.floor(total * 0.75);
+     const medianIndex = Math.floor(total * 0.5);
@@ lines 536-549 @@
-       : sorted[medianIndex];
-     
-     // Calculate standard deviation
-     const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Calculate IQR and outliers
-     const iqr = percentile75 - percentile25;
-     const lowerBound = percentile25 - 1.5 * iqr;
-     const upperBound = percentile75 + 1.5 * iqr;
-     const outlierCount = values.filter(v => v < lowerBound || v > upperBound).length;
-     
-     return {
-       total,
---
+       : sorted[medianIndex];
+     
+     // Calculate standard deviation
+     const variance = values.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Calculate IQR and outliers
+     const iqr = percentile75 - percentile25;
+     const lowerBound = percentile25 - 1.5 * iqr;
+     const upperBound = percentile75 + 1.5 * iqr;
+     const outlierCount = values.filter(v: any => v < lowerBound || v > upperBound).length;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 577-586 @@
-     summary += `Average interaction strength: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
-     
-     // Calculate interaction category distribution
-     const highInteractions = records.filter(r => r.value >= 50).length;
-     const moderateInteractions = records.filter(r => r.value >= 35 && r.value < 50).length;
-     const lowInteractions = records.filter(r => r.value >= 20 && r.value < 35).length;
-     const minimalInteractions = records.filter(r => r.value < 20).length;
-     
-     summary += `Interaction distribution: ${highInteractions} high interactions (${(highInteractions/records.length*100).toFixed(1)}%), `;
-     summary += `${moderateInteractions} moderate interactions (${(moderateInteractions/records.length*100).toFixed(1)}%), `;
---
+     summary += `Average interaction strength: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
+     
+     // Calculate interaction category distribution
+     const highInteractions = records.filter(r: any => r.value >= 50).length;
+     const moderateInteractions = records.filter(r: any => r.value >= 35 && r.value < 50).length;
+     const lowInteractions = records.filter(r: any => r.value >= 20 && r.value < 35).length;
+     const minimalInteractions = records.filter(r: any => r.value < 20).length;
+     
+     summary += `Interaction distribution: ${highInteractions} high interactions (${(highInteractions/records.length*100).toFixed(1)}%), `;
+     summary += `${moderateInteractions} moderate interactions (${(moderateInteractions/records.length*100).toFixed(1)}%), `;
+     summary += `${lowInteractions} low interactions (${(lowInteractions/records.length*100).toFixed(1)}%), `;
+     summary += `${minimalInteractions} minimal interactions (${(minimalInteractions/records.length*100).toFixed(1)}%).
+ 
@@ lines 592-611 @@
-     // Top interaction markets (5-8 areas)
-     const topInteractions = records.slice(0, 8);
-     if (topInteractions.length > 0) {
-       const strongInteractions = topInteractions.filter(r => r.value >= 45);
-       if (strongInteractions.length > 0) {
-         summary += `**Strongest Interaction Markets:** `;
-         const interactionNames = strongInteractions.slice(0, 6).map(r => `${r.area_name} (${r.value.toFixed(1)})`);
-         summary += `${interactionNames.join(', ')}. `;
-         
-         const avgTopInteraction = strongInteractions.reduce((sum, r) => sum + r.value, 0) / strongInteractions.length;
-         summary += `These markets show exceptional variable interactions with average score ${avgTopInteraction.toFixed(1)}. `;
-       }
-     }
-     
-     // Interaction type breakdown
-     if (records.length > 0) {
-       const interactionTypes = records.reduce((acc, record) => {
-         const props = record.properties as Record<string, unknown>;
-         const type = (props['dominant_interaction_type'] as string) || 'Unknown';
-         acc[type] = (acc[type] || 0) + 1;
---
+     // Top interaction markets (5-8 areas)
+     const topInteractions = records.slice(0, 8);
+     if (topInteractions.length > 0) {
+       const strongInteractions = topInteractions.filter(r: any => r.value >= 45);
+       if (strongInteractions.length > 0) {
+         summary += `**Strongest Interaction Markets:** `;
+         const interactionNames = strongInteractions.slice(0, 6).map(r: any => `${r.area_name} (${r.value.toFixed(1)})`);
+         summary += `${interactionNames.join(', ')}. `;
+         
+         const avgTopInteraction = strongInteractions.reduce((sum: any, r: any) => sum + r.value, 0) / strongInteractions.length;
+         summary += `These markets show exceptional variable interactions with average score ${avgTopInteraction.toFixed(1)}. `;
+       }
+     }
+     
+     // Interaction type breakdown
+     if (records.length > 0) {
+       const interactionTypes = records.reduce((acc: any, record: any) => {
+         const props = record.properties as Record<string, unknown>;
+         const type = (props['dominant_interaction_type'] as string) || 'Unknown';
+         acc[type] = (acc[type] || 0) + 1;
+         return acc;
+       }, {} as Record<string, number>);
+       
@@ lines 628-639 @@
-     // Synergy effect markets
-     if (records.length > 0) {
-   const synergyMarkets = records
-   .filter(r => (((r.properties as Record<string, unknown>)['synergy_effect'] as number) || 0) >= 60)
-   .slice(0, 5);
-       
-       if (synergyMarkets.length > 0) {
-         summary += `**High Synergy Markets:** `;
-         const synergyNames = synergyMarkets.map(r => 
-           `${r.area_name} (${((r.properties as any).synergy_effect || 0).toFixed(1)}% synergy)`
-         );
-         summary += `${synergyNames.join(', ')}. `;
---
+     // Synergy effect markets
+     if (records.length > 0) {
+   const synergyMarkets = records
+   .filter(r: any => (((r.properties as Record<string, unknown>)['synergy_effect'] as number) || 0) >= 60)
+   .slice(0, 5);
+       
+       if (synergyMarkets.length > 0) {
+         summary += `**High Synergy Markets:** `;
+         const synergyNames = synergyMarkets.map(r: any => 
+           `${r.area_name} (${((r.properties as any).synergy_effect || 0).toFixed(1)}% synergy)`
+         );
+         summary += `${synergyNames.join(', ')}. `;
+         summary += `These markets show strong synergistic effects between variables. `;
+       }
+     }
@@ lines 644-655 @@
-     // Complex interaction markets
-     if (records.length > 0) {
-   const complexMarkets = records
-   .filter(r => (((r.properties as Record<string, unknown>)['interaction_complexity'] as number) || 0) >= 70)
-   .slice(0, 5);
-       
-       if (complexMarkets.length > 0) {
-         summary += `**Complex Interaction Markets:** `;
-         const complexNames = complexMarkets.map(r => 
-           `${r.area_name} (${((r.properties as any).variable_count || 0)} active variables)`
-         );
-         summary += `${complexNames.join(', ')}. `;
---
+     // Complex interaction markets
+     if (records.length > 0) {
+   const complexMarkets = records
+   .filter(r: any => (((r.properties as Record<string, unknown>)['interaction_complexity'] as number) || 0) >= 70)
+   .slice(0, 5);
+       
+       if (complexMarkets.length > 0) {
+         summary += `**Complex Interaction Markets:** `;
+         const complexNames = complexMarkets.map(r: any => 
+           `${r.area_name} (${((r.properties as any).variable_count || 0)} active variables)`
+         );
+         summary += `${complexNames.join(', ')}. `;
+         summary += `These markets demonstrate multi-variable complexity requiring sophisticated analysis. `;
+       }
+     }
@@ lines 663-669 @@
-     // Top markets for detailed interaction analysis
-     const topMarkets = records.slice(0, 3);
-     if (topMarkets.length > 0) {
-       topMarkets.forEach((market, index) => {
-         const props = market.properties as Record<string, unknown>;
-         const examples = this.generateSpecificInteractionExamples(market, props);
-         summary += `${index + 1}. **${market.area_name}** (${market.value.toFixed(1)} interaction score): ${examples} `;
---
+     // Top markets for detailed interaction analysis
+     const topMarkets = records.slice(0, 3);
+     if (topMarkets.length > 0) {
+       topMarkets.forEach((market: any, index: any) => {
+         const props = market.properties as Record<string, unknown>;
+         const examples = this.generateSpecificInteractionExamples(market, props);
+         summary += `${index + 1}. **${market.area_name}** (${market.value.toFixed(1)} interaction score): ${examples} `;
+       });
+     }
+     
@@ lines 672-678 @@
-     
-     // Add common interaction patterns discovered
-     summary += `**📋 Common Interaction Patterns:** `;
-     const sampleMarket = records.find(r => r.value >= 35);
-     if (sampleMarket) {
-       const commonExamples = this.generateCommonInteractionPatterns(records);
-       summary += `${commonExamples} `;
---
+     
+     // Add common interaction patterns discovered
+     summary += `**📋 Common Interaction Patterns:** `;
+     const sampleMarket = records.find(r: any => r.value >= 35);
+     if (sampleMarket) {
+       const commonExamples = this.generateCommonInteractionPatterns(records);
+       summary += `${commonExamples} `;
+     }
+     
+     // Strategic insights
@@ lines 681-693 @@
-     // Strategic insights
-     summary += `**📊 Interaction Analysis:** ${statistics.total} geographic areas analyzed for feature interactions and variable relationships. `;
-     
-     const strongInteractionMarkets = records.filter(r => r.value >= 50).length;
-     if (strongInteractionMarkets > 0) {
-       summary += `${strongInteractionMarkets} markets (${(strongInteractionMarkets/records.length*100).toFixed(1)}%) show strong multi-variable interactions offering sophisticated targeting opportunities. `;
-     }
-     
-     // Variable complexity insights
-   const avgVariableCount = records.reduce((sum, r) => sum + (((r.properties as Record<string, unknown>)['variable_count'] as number) || 0), 0) / records.length;
-     summary += `Average active variables per market: ${avgVariableCount.toFixed(1)}, indicating ${avgVariableCount >= 5 ? 'high' : avgVariableCount >= 3 ? 'moderate' : 'low'} data complexity. `;
-     
-     // Actionable recommendations
---
+     // Strategic insights
+     summary += `**📊 Interaction Analysis:** ${statistics.total} geographic areas analyzed for feature interactions and variable relationships. `;
+     
+     const strongInteractionMarkets = records.filter(r: any => r.value >= 50).length;
+     if (strongInteractionMarkets > 0) {
+       summary += `${strongInteractionMarkets} markets (${(strongInteractionMarkets/records.length*100).toFixed(1)}%) show strong multi-variable interactions offering sophisticated targeting opportunities. `;
+     }
+     
+     // Variable complexity insights
+   const avgVariableCount = records.reduce((sum: any, r: any) => sum + (((r.properties as Record<string, unknown>)['variable_count'] as number) || 0), 0) / records.length;
+     summary += `Average active variables per market: ${avgVariableCount.toFixed(1)}, indicating ${avgVariableCount >= 5 ? 'high' : avgVariableCount >= 3 ? 'moderate' : 'low'} data complexity. `;
+     
+     // Actionable recommendations
+     summary += `**Strategic Recommendations:** `;
+     if (highInteractions > 0) {
+       summary += `Leverage ${highInteractions} high-interaction markets for multi-channel coordinated campaigns. `;
@@ lines 700-706 @@
-     }
-     
-     // Non-linear pattern insights
-   const nonLinearMarkets = records.filter(r => (((r.properties as Record<string, unknown>)['non_linear_patterns'] as number) || 0) >= 40).length;
-     if (nonLinearMarkets > 0) {
-       summary += `${nonLinearMarkets} markets show non-linear patterns requiring threshold-based strategies. `;
-     }
---
+     }
+     
+     // Non-linear pattern insights
+   const nonLinearMarkets = records.filter(r: any => (((r.properties as Record<string, unknown>)['non_linear_patterns'] as number) || 0) >= 40).length;
+     if (nonLinearMarkets > 0) {
+       summary += `${nonLinearMarkets} markets show non-linear patterns requiring threshold-based strategies. `;
+     }
+     
+     if (rawSummary) {
+       summary += rawSummary;
@@ lines 720-726 @@
-    * Create direct renderer for feature interaction visualization
-    */
-   private createFeatureInteractionRenderer(records: any[], primaryField: string): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use standard red-to-green gradient: Red (low) -> Orange -> Light Green -> Dark Green (high)
---
+    * Create direct renderer for feature interaction visualization
+    */
+   private createFeatureInteractionRenderer(records: any[], primaryField: string): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use standard red-to-green gradient: Red (low) -> Orange -> Light Green -> Dark Green (high)
+     const interactionColors = [
+       [215, 48, 39, 0.6],   // #d73027 - Red (low interaction)
+       [253, 174, 97, 0.6],  // #fdae61 - Orange
@@ lines 734-740 @@
-     return {
-       type: 'class-breaks',
-   field: primaryField, // Use canonical primary field
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+   field: primaryField, // Use canonical primary field
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: interactionColors[i], // Direct array format
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 758-764 @@
-   private createFeatureInteractionLegend(records: any[], _primaryField: string): any {
-     // reference _primaryField to avoid unused param lint
-     void _primaryField;
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use standard red-to-green RGBA format to match renderer
---
+   private createFeatureInteractionLegend(records: any[], _primaryField: string): any {
+     // reference _primaryField to avoid unused param lint
+     void _primaryField;
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use standard red-to-green RGBA format to match renderer
+     const colors = [
+       'rgba(215, 48, 39, 0.6)',   // Low interaction
+       'rgba(253, 174, 97, 0.6)',  // Medium-low  
@@ lines 872-884 @@
-     const patterns = [];
-     
-     // Analyze income-demographics patterns
-     const incomeDemo = records.filter(r => {
-       const props = r.properties as any;
-       return props.median_income > 0 && props.demographic_score > 0;
-     });
-     
-     if (incomeDemo.length >= 5) {
-       const avgIncomeEffect = incomeDemo.reduce((sum, r) => {
-         const props = r.properties as any;
-         return sum + (props.median_income / 1000) * (props.demographic_score / 100);
-       }, 0) / incomeDemo.length;
---
+     const patterns = [];
+     
+     // Analyze income-demographics patterns
+     const incomeDemo = records.filter(r: any => {
+       const props = r.properties as any;
+       return props.median_income > 0 && props.demographic_score > 0;
+     });
+     
+     if (incomeDemo.length >= 5) {
+       const avgIncomeEffect = incomeDemo.reduce((sum: any, r: any) => {
+         const props = r.properties as any;
+         return sum + (props.median_income / 1000) * (props.demographic_score / 100);
+       }, 0) / incomeDemo.length;
+       
+       patterns.push(`Income-demographics multiplier effect: ${avgIncomeEffect.toFixed(1)}x stronger in ${incomeDemo.length} markets`);
+     }
@@ lines 887-913 @@
-     }
-     
-     // Analyze population-competition patterns
-     const popComp = records.filter(r => {
-       const props = r.properties as any;
-       return props.total_population > 0 && props.competitive_score > 0;
-     });
-     
-     if (popComp.length >= 5) {
-       const highPop = popComp.filter(r => (r.properties as any).total_population > 40000);
-       const highPopCompScore = highPop.reduce((sum, r) => sum + (r.properties as any).competitive_score, 0) / (highPop.length || 1);
-       
-       patterns.push(`High-density markets (${highPop.length}) show ${highPopCompScore.toFixed(1)} average competitive intensity`);
-     }
-     
-     // Analyze synergy patterns
-     const synergyMarkets = records.filter(r => ((r.properties as any).synergy_effect || 0) > 40);
-     if (synergyMarkets.length >= 3) {
-       const avgSynergy = synergyMarkets.reduce((sum, r) => sum + ((r.properties as any).synergy_effect || 0), 0) / synergyMarkets.length;
-       patterns.push(`Synergy amplification: ${synergyMarkets.length} markets show ${avgSynergy.toFixed(1)}% combined effects exceeding individual variable impact`);
-     }
-     
-     // Analyze threshold effects
-     const nonLinearMarkets = records.filter(r => ((r.properties as any).non_linear_patterns || 0) > 30);
-     if (nonLinearMarkets.length >= 3) {
-       patterns.push(`Non-linear thresholds: ${nonLinearMarkets.length} markets exhibit tipping points where variable combinations create disproportionate results`);
-     }
---
+     }
+     
+     // Analyze population-competition patterns
+     const popComp = records.filter(r: any => {
+       const props = r.properties as any;
+       return props.total_population > 0 && props.competitive_score > 0;
+     });
+     
+     if (popComp.length >= 5) {
+       const highPop = popComp.filter(r: any => (r.properties as any).total_population > 40000);
+       const highPopCompScore = highPop.reduce((sum: any, r: any) => sum + (r.properties as any).competitive_score, 0) / (highPop.length || 1);
+       
+       patterns.push(`High-density markets (${highPop.length}) show ${highPopCompScore.toFixed(1)} average competitive intensity`);
+     }
+     
+     // Analyze synergy patterns
+     const synergyMarkets = records.filter(r: any => ((r.properties as any).synergy_effect || 0) > 40);
+     if (synergyMarkets.length >= 3) {
+       const avgSynergy = synergyMarkets.reduce((sum: any, r: any) => sum + ((r.properties as any).synergy_effect || 0), 0) / synergyMarkets.length;
+       patterns.push(`Synergy amplification: ${synergyMarkets.length} markets show ${avgSynergy.toFixed(1)}% combined effects exceeding individual variable impact`);
+     }
+     
+     // Analyze threshold effects
+     const nonLinearMarkets = records.filter(r: any => ((r.properties as any).non_linear_patterns || 0) > 30);
+     if (nonLinearMarkets.length >= 3) {
+       patterns.push(`Non-linear thresholds: ${nonLinearMarkets.length} markets exhibit tipping points where variable combinations create disproportionate results`);
+     }
+     
+     // Return patterns or fallback
+     if (patterns.length > 0) {


*** FILE: components/ProjectConfigManager/DependencyAnalyzer.tsx
@@ lines 181-188 @@
-     
-     // Different layouts based on node type
-     if (node.type === 'layer') {
-       const layerNodes = dependencyGraph.nodes.filter(n => n.type === 'layer');
-       const layerIndex = layerNodes.findIndex(n => n.id === node.id);
-       const angle = (layerIndex / Math.max(layerNodes.length, 1)) * 2 * Math.PI;
-       const radius = 120;
-       return {
---
+     
+     // Different layouts based on node type
+     if (node.type === 'layer') {
+       const layerNodes = dependencyGraph.nodes.filter(n: any => n.type === 'layer');
+       const layerIndex = layerNodes.findIndex(n: any => n.id === node.id);
+       const angle = (layerIndex / Math.max(layerNodes.length, 1)) * 2 * Math.PI;
+       const radius = 120;
+       return {
+         x: centerX + Math.cos(angle) * radius,
+         y: centerY + Math.sin(angle) * radius
+       };
@@ lines 190-197 @@
-         y: centerY + Math.sin(angle) * radius
-       };
-     } else if (node.type === 'group') {
-       const groupNodes = dependencyGraph.nodes.filter(n => n.type === 'group');
-       const groupIndex = groupNodes.findIndex(n => n.id === node.id);
-       const angle = (groupIndex / Math.max(groupNodes.length, 1)) * 2 * Math.PI;
-       const radius = 80;
-       return {
---
+         y: centerY + Math.sin(angle) * radius
+       };
+     } else if (node.type === 'group') {
+       const groupNodes = dependencyGraph.nodes.filter(n: any => n.type === 'group');
+       const groupIndex = groupNodes.findIndex(n: any => n.id === node.id);
+       const angle = (groupIndex / Math.max(groupNodes.length, 1)) * 2 * Math.PI;
+       const radius = 80;
+       return {
+         x: centerX + Math.cos(angle) * radius,
+         y: centerY + Math.sin(angle) * radius
+       };
@@ lines 199-214 @@
-         y: centerY + Math.sin(angle) * radius
-       };
-     } else if (node.type === 'file') {
-       const fileNodes = dependencyGraph.nodes.filter(n => n.type === 'file');
-       const fileIndex = fileNodes.findIndex(n => n.id === node.id);
-       return {
-         x: 50 + (fileIndex * 100) % (width - 100),
-         y: 50 + Math.floor((fileIndex * 100) / (width - 100)) * 60
-       };
-     } else {
-       // Service or other types - place in outer ring
-       const otherNodes = dependencyGraph.nodes.filter(n => !['layer', 'group', 'file'].includes(n.type));
-       const otherIndex = otherNodes.findIndex(n => n.id === node.id);
-       const angle = (otherIndex / Math.max(otherNodes.length, 1)) * 2 * Math.PI;
-       const radius = 180;
-       return {
---
+         y: centerY + Math.sin(angle) * radius
+       };
+     } else if (node.type === 'file') {
+       const fileNodes = dependencyGraph.nodes.filter(n: any => n.type === 'file');
+       const fileIndex = fileNodes.findIndex(n: any => n.id === node.id);
+       return {
+         x: 50 + (fileIndex * 100) % (width - 100),
+         y: 50 + Math.floor((fileIndex * 100) / (width - 100)) * 60
+       };
+     } else {
+       // Service or other types - place in outer ring
+       const otherNodes = dependencyGraph.nodes.filter(n: any => !['layer', 'group', 'file'].includes(n.type));
+       const otherIndex = otherNodes.findIndex(n: any => n.id === node.id);
+       const angle = (otherIndex / Math.max(otherNodes.length, 1)) * 2 * Math.PI;
+       const radius = 180;
+       return {
+         x: centerX + Math.cos(angle) * radius,
+         y: centerY + Math.sin(angle) * radius
+       };
@@ lines 220-226 @@
- 
-   // Filter nodes based on search and filters
-   const filteredNodes = useMemo(() => {
-     return dependencyGraph.nodes.filter(node => {
-       const matchesSearch = node.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
-                           (node.path && node.path.toLowerCase().includes(searchTerm.toLowerCase()));
-       const matchesType = filterType === 'all' || node.type === filterType;
---
+ 
+   // Filter nodes based on search and filters
+   const filteredNodes = useMemo(() => {
+     return dependencyGraph.nodes.filter(node: any => {
+       const matchesSearch = node.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
+                           (node.path && node.path.toLowerCase().includes(searchTerm.toLowerCase()));
+       const matchesType = filterType === 'all' || node.type === filterType;
+       const matchesRisk = filterRisk === 'all' || node.riskLevel === filterRisk;
+       
+       return matchesSearch && matchesType && matchesRisk;
@@ lines 240-246 @@
-       const clusters: DependencyCluster[] = [];
- 
-       // Create nodes for layers
-       layers.forEach(layer => {
-         nodes.push({
-           id: layer.id,
-           name: layer.name,
---
+       const clusters: DependencyCluster[] = [];
+ 
+       // Create nodes for layers
+       layers.forEach(layer: any => {
+         nodes.push({
+           id: layer.id,
+           name: layer.name,
+           type: 'layer',
+           dependencies: [],
+           dependents: [],
@@ lines 254-260 @@
-       });
- 
-       // Create nodes for groups
-       groups.forEach(group => {
-         nodes.push({
-           id: group.id,
-           name: group.name,
---
+       });
+ 
+       // Create nodes for groups
+       groups.forEach(group: any => {
+         nodes.push({
+           id: group.id,
+           name: group.name,
+           type: 'group',
+           dependencies: group.layers,
+           dependents: [],
@@ lines 267-273 @@
-         });
- 
-         // Create edges from group to layers
-         group.layers.forEach(layerId => {
-           edges.push({
-             id: `${group.id}-${layerId}`,
-             source: group.id,
---
+         });
+ 
+         // Create edges from group to layers
+         group.layers.forEach(layerId: any => {
+           edges.push({
+             id: `${group.id}-${layerId}`,
+             source: group.id,
+             target: layerId,
+             type: 'config',
+             strength: 1.0,
@@ lines 294-300 @@
-           name: file.path.split('/').pop() || file.path,
-           type: 'file',
-           path: file.path,
-           dependencies: file.layers[0] === '*' ? layers.map(l => l.id) : file.layers,
-           dependents: [],
-           status: 'active',
-           complexity: file.layers.length,
---
+           name: file.path.split('/').pop() || file.path,
+           type: 'file',
+           path: file.path,
+           dependencies: file.layers[0] === '*' ? layers.map(l: any => l.id) : file.layers,
+           dependents: [],
+           status: 'active',
+           complexity: file.layers.length,
+           riskLevel: file.layers[0] === '*' ? 'high' : 'medium'
+         });
+ 
@@ lines 302-309 @@
-         });
- 
-         // Create edges from file to layers
-         const layerDeps = file.layers[0] === '*' ? layers.map(l => l.id) : file.layers;
-         layerDeps.forEach(layerId => {
-           edges.push({
-             id: `${fileId}-${layerId}`,
-             source: fileId,
---
+         });
+ 
+         // Create edges from file to layers
+         const layerDeps = file.layers[0] === '*' ? layers.map(l: any => l.id) : file.layers;
+         layerDeps.forEach(layerId: any => {
+           edges.push({
+             id: `${fileId}-${layerId}`,
+             source: fileId,
+             target: layerId,
+             type: 'import',
+             strength: 0.8,
@@ lines 329-336 @@
-       }
- 
-       // Update dependents
-       edges.forEach(edge => {
-         const targetNode = nodes.find(n => n.id === edge.target);
-         if (targetNode && !targetNode.dependents.includes(edge.source)) {
-           targetNode.dependents.push(edge.source);
-         }
---
+       }
+ 
+       // Update dependents
+       edges.forEach(edge: any => {
+         const targetNode = nodes.find(n: any => n.id === edge.target);
+         if (targetNode && !targetNode.dependents.includes(edge.source)) {
+           targetNode.dependents.push(edge.source);
+         }
+       });
+ 
+       setDependencyGraph({ nodes, edges, clusters });
@@ lines 364-370 @@
-       visited.add(nodeId);
-       recursionStack.add(nodeId);
- 
-       const dependencies = edges.filter(e => e.source === nodeId).map(e => e.target);
-       for (const depId of dependencies) {
-         if (dfs(depId)) {
-           circularNodes.add(nodeId);
---
+       visited.add(nodeId);
+       recursionStack.add(nodeId);
+ 
+       const dependencies = edges.filter(e: any => e.source === nodeId).map(e: any => e.target);
+       for (const depId of dependencies) {
+         if (dfs(depId)) {
+           circularNodes.add(nodeId);
+           return true;
+         }
+       }
@@ lines 376-382 @@
-       return false;
-     };
- 
-     nodes.forEach(node => {
-       if (!visited.has(node.id)) {
-         dfs(node.id);
-       }
---
+       return false;
+     };
+ 
+     nodes.forEach(node: any => {
+       if (!visited.has(node.id)) {
+         dfs(node.id);
+       }
+     });
+ 
+     return Array.from(circularNodes);
@@ lines 390-396 @@
-     const suggestions: OptimizationSuggestion[] = [];
- 
-     // Find unused layers
-     const unusedLayers = nodes.filter(n => n.type === 'layer' && n.dependents.length === 0);
-     if (unusedLayers.length > 0) {
-       suggestions.push({
-         id: 'unused_layers',
---
+     const suggestions: OptimizationSuggestion[] = [];
+ 
+     // Find unused layers
+     const unusedLayers = nodes.filter(n: any => n.type === 'layer' && n.dependents.length === 0);
+     if (unusedLayers.length > 0) {
+       suggestions.push({
+         id: 'unused_layers',
+         type: 'unused_layer',
+         title: `Remove ${unusedLayers.length} Unused Layers`,
+         description: `Found ${unusedLayers.length} layers that are not referenced by any components or groups`,
@@ lines 412-418 @@
-     }
- 
-     // Find high-complexity components
-     const complexComponents = nodes.filter(n => n.complexity > 8);
-     if (complexComponents.length > 0) {
-       suggestions.push({
-         id: 'complex_components',
---
+     }
+ 
+     // Find high-complexity components
+     const complexComponents = nodes.filter(n: any => n.complexity > 8);
+     if (complexComponents.length > 0) {
+       suggestions.push({
+         id: 'complex_components',
+         type: 'performance',
+         title: 'Optimize High-Complexity Components',
+         description: `${complexComponents.length} components have high complexity and may benefit from optimization`,
@@ lines 434-440 @@
-     }
- 
-     // Bundle size optimization
-     const totalLayers = nodes.filter(n => n.type === 'layer').length;
-     if (totalLayers > 50) {
-       suggestions.push({
-         id: 'bundle_optimization',
---
+     }
+ 
+     // Bundle size optimization
+     const totalLayers = nodes.filter(n: any => n.type === 'layer').length;
+     if (totalLayers > 50) {
+       suggestions.push({
+         id: 'bundle_optimization',
+         type: 'bundle_size',
+         title: 'Implement Layer Lazy Loading',
+         description: 'Large number of layers detected. Consider implementing lazy loading to improve initial load time',
@@ lines 465-479 @@
-     const affectedServices = new Set<string>();
-     const breakingChanges: BreakingChange[] = [];
- 
-     changes.forEach(change => {
-       if (change.target === 'layer') {
-         // Find all files that depend on this layer
-         const layerId = change.path.split('.')[1];
-         const dependentNodes = dependencyGraph.nodes.filter(n => 
-           n.dependencies.includes(layerId) || n.dependents.includes(layerId)
-         );
- 
-         dependentNodes.forEach(node => {
-           if (node.type === 'file' && node.path) {
-             affectedFiles.add(node.path);
-           } else if (node.type === 'component') {
---
+     const affectedServices = new Set<string>();
+     const breakingChanges: BreakingChange[] = [];
+ 
+     changes.forEach(change: any => {
+       if (change.target === 'layer') {
+         // Find all files that depend on this layer
+         const layerId = change.path.split('.')[1];
+         const dependentNodes = dependencyGraph.nodes.filter(n: any => 
+           n.dependencies.includes(layerId) || n.dependents.includes(layerId)
+         );
+ 
+         dependentNodes.forEach(node: any => {
+           if (node.type === 'file' && node.path) {
+             affectedFiles.add(node.path);
+           } else if (node.type === 'component') {
+             affectedComponents.add(node.name);
+           } else if (node.type === 'service') {
+             affectedServices.add(node.name);
@@ lines 487-493 @@
-           breakingChanges.push({
-             type: 'layer_removal',
-             description: `Removing layer ${layerId} will break ${dependentNodes.length} components`,
-             affectedFiles: dependentNodes.filter(n => n.path).map(n => n.path!),
-             severity: dependentNodes.length > 5 ? 'critical' : 'medium',
-             autoFixAvailable: false,
-             recommendation: 'Update all dependent components before removing layer'
---
+           breakingChanges.push({
+             type: 'layer_removal',
+             description: `Removing layer ${layerId} will break ${dependentNodes.length} components`,
+             affectedFiles: dependentNodes.filter(n: any => n.path).map(n: any => n.path!),
+             severity: dependentNodes.length > 5 ? 'critical' : 'medium',
+             autoFixAvailable: false,
+             recommendation: 'Update all dependent components before removing layer'
+           });
+         }
+       }
@@ lines 500-507 @@
-       affectedFiles: Array.from(affectedFiles),
-       affectedComponents: Array.from(affectedComponents),
-       affectedServices: Array.from(affectedServices),
-       riskLevel: breakingChanges.some(c => c.severity === 'critical') ? 'critical' : 
-                 breakingChanges.some(c => c.severity === 'high') ? 'high' : 'medium',
-       estimatedDowntime: breakingChanges.length * 5, // minutes
-       rollbackComplexity: breakingChanges.length > 3 ? 'complex' : 'simple',
-       recommendations: [
---
+       affectedFiles: Array.from(affectedFiles),
+       affectedComponents: Array.from(affectedComponents),
+       affectedServices: Array.from(affectedServices),
+       riskLevel: breakingChanges.some(c: any => c.severity === 'critical') ? 'critical' : 
+                 breakingChanges.some(c: any => c.severity === 'high') ? 'high' : 'medium',
+       estimatedDowntime: breakingChanges.length * 5, // minutes
+       rollbackComplexity: breakingChanges.length > 3 ? 'complex' : 'simple',
+       recommendations: [
+         'Create backup before deployment',
+         'Test changes in staging environment',
+         'Update dependent components gradually'
@@ lines 574-583 @@
-                     
-                     {/* Render Edges */}
-                     {dependencyGraph.edges
-                       .filter(edge => showOptionalDeps || !edge.isOptional)
-                       .map((edge, index) => {
-                         const sourceNode = dependencyGraph.nodes.find(n => n.id === edge.source);
-                         const targetNode = dependencyGraph.nodes.find(n => n.id === edge.target);
-                         if (!sourceNode || !targetNode) return null;
-                         
-                         // Calculate positions based on node type and index
---
+                     
+                     {/* Render Edges */}
+                     {dependencyGraph.edges
+                       .filter(edge: any => showOptionalDeps || !edge.isOptional)
+                       .map((edge: any, index: any) => {
+                         const sourceNode = dependencyGraph.nodes.find(n: any => n.id === edge.source);
+                         const targetNode = dependencyGraph.nodes.find(n: any => n.id === edge.target);
+                         if (!sourceNode || !targetNode) return null;
+                         
+                         // Calculate positions based on node type and index
+                         const sourcePos = getNodePosition(sourceNode, index, dependencyGraph.nodes.length);
+                         const targetPos = getNodePosition(targetNode, index, dependencyGraph.nodes.length);
+                         
@@ lines 607-613 @@
-                       })}
-                     
-                     {/* Render Nodes */}
-                     {dependencyGraph.nodes.map((node, index) => {
-                       const pos = getNodePosition(node, index, dependencyGraph.nodes.length);
-                       const nodeColor = 
-                         node.type === 'layer' ? '#3b82f6' :
---
+                       })}
+                     
+                     {/* Render Nodes */}
+                     {dependencyGraph.nodes.map((node: any, index: any) => {
+                       const pos = getNodePosition(node, index, dependencyGraph.nodes.length);
+                       const nodeColor = 
+                         node.type === 'layer' ? '#3b82f6' :
+                         node.type === 'group' ? '#10b981' :
+                         node.type === 'file' ? '#f59e0b' :
+                         node.type === 'service' ? '#8b5cf6' : '#6b7280';
@@ lines 677-695 @@
-                   <div className="grid grid-cols-2 gap-2">
-                     <div className="flex items-center gap-2">
-                       <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
-                       <span>Layers ({dependencyGraph.nodes.filter(n => n.type === 'layer').length})</span>
-                     </div>
-                     <div className="flex items-center gap-2">
-                       <div className="w-3 h-3 bg-green-500 rounded-full"></div>
-                       <span>Groups ({dependencyGraph.nodes.filter(n => n.type === 'group').length})</span>
-                     </div>
-                     <div className="flex items-center gap-2">
-                       <div className="w-3 h-3 bg-orange-500 rounded-full"></div>
-                       <span>Files ({dependencyGraph.nodes.filter(n => n.type === 'file').length})</span>
-                     </div>
-                     <div className="flex items-center gap-2">
-                       <div className="w-3 h-3 bg-purple-500 rounded-full"></div>
-                       <span>Services ({dependencyGraph.nodes.filter(n => n.type === 'service').length})</span>
-                     </div>
-                   </div>
-                   <div className="mt-2 pt-2 border-t text-gray-500">
---
+                   <div className="grid grid-cols-2 gap-2">
+                     <div className="flex items-center gap-2">
+                       <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
+                       <span>Layers ({dependencyGraph.nodes.filter(n: any => n.type === 'layer').length})</span>
+                     </div>
+                     <div className="flex items-center gap-2">
+                       <div className="w-3 h-3 bg-green-500 rounded-full"></div>
+                       <span>Groups ({dependencyGraph.nodes.filter(n: any => n.type === 'group').length})</span>
+                     </div>
+                     <div className="flex items-center gap-2">
+                       <div className="w-3 h-3 bg-orange-500 rounded-full"></div>
+                       <span>Files ({dependencyGraph.nodes.filter(n: any => n.type === 'file').length})</span>
+                     </div>
+                     <div className="flex items-center gap-2">
+                       <div className="w-3 h-3 bg-purple-500 rounded-full"></div>
+                       <span>Services ({dependencyGraph.nodes.filter(n: any => n.type === 'service').length})</span>
+                     </div>
+                   </div>
+                   <div className="mt-2 pt-2 border-t text-gray-500">
+                     {dependencyGraph.edges.length} connections
+                   </div>
+                 </div>
@@ lines 705-711 @@
-               {selectedNode ? (
-                 <div className="space-y-3">
-                   {(() => {
-                     const node = dependencyGraph.nodes.find(n => n.id === selectedNode);
-                     if (!node) return null;
-                     
-                     return (
---
+               {selectedNode ? (
+                 <div className="space-y-3">
+                   {(() => {
+                     const node = dependencyGraph.nodes.find(n: any => n.id === selectedNode);
+                     if (!node) return null;
+                     
+                     return (
+                       <div className="p-3 border rounded-lg">
+                         <div className="flex items-center gap-2 mb-2">
+                           {node.type === 'layer' && <Layers className="h-4 w-4 text-blue-500" />}
@@ lines 764-770 @@
-           </CardHeader>
-           <CardContent>
-             <div className="space-y-3">
-               {dependencyGraph.clusters.map(cluster => (
-                 <div key={cluster.id} className="flex items-center justify-between p-3 border rounded-lg">
-                   <div className="flex items-center gap-3">
-                     <div className={`w-3 h-3 rounded-full ${
---
+           </CardHeader>
+           <CardContent>
+             <div className="space-y-3">
+               {dependencyGraph.clusters.map(cluster: any => (
+                 <div key={cluster.id} className="flex items-center justify-between p-3 border rounded-lg">
+                   <div className="flex items-center gap-3">
+                     <div className={`w-3 h-3 rounded-full ${
+                       cluster.riskLevel === 'critical' ? 'bg-red-500' :
+                       cluster.riskLevel === 'high' ? 'bg-orange-500' :
+                       cluster.riskLevel === 'medium' ? 'bg-yellow-500' : 'bg-green-500'
@@ lines 858-864 @@
-                   Affected Files ({impactAnalysis.affectedFiles.length})
-                 </h4>
-                 <div className="space-y-2">
-                   {impactAnalysis.affectedFiles.slice(0, 5).map(file => (
-                     <div key={file} className="text-sm p-2 bg-gray-50 rounded">
-                       {file}
-                     </div>
---
+                   Affected Files ({impactAnalysis.affectedFiles.length})
+                 </h4>
+                 <div className="space-y-2">
+                   {impactAnalysis.affectedFiles.slice(0, 5).map(file: any => (
+                     <div key={file} className="text-sm p-2 bg-gray-50 rounded">
+                       {file}
+                     </div>
+                   ))}
+                   {impactAnalysis.affectedFiles.length > 5 && (
+                     <div className="text-sm text-gray-500">
@@ lines 878-884 @@
-                   Affected Components ({impactAnalysis.affectedComponents.length})
-                 </h4>
-                 <div className="space-y-2">
-                   {impactAnalysis.affectedComponents.slice(0, 5).map(component => (
-                     <div key={component} className="text-sm p-2 bg-gray-50 rounded">
-                       {component}
-                     </div>
---
+                   Affected Components ({impactAnalysis.affectedComponents.length})
+                 </h4>
+                 <div className="space-y-2">
+                   {impactAnalysis.affectedComponents.slice(0, 5).map(component: any => (
+                     <div key={component} className="text-sm p-2 bg-gray-50 rounded">
+                       {component}
+                     </div>
+                   ))}
+                   {impactAnalysis.affectedComponents.length > 5 && (
+                     <div className="text-sm text-gray-500">
@@ lines 922-928 @@
-                   Breaking Changes
-                 </h4>
-                 <div className="space-y-3">
-                   {impactAnalysis.breakingChanges.map((change, index) => (
-                     <Alert key={index} variant={change.severity === 'critical' ? 'destructive' : 'default'}>
-                       <AlertTriangle className="h-4 w-4" />
-                       <AlertDescription>
---
+                   Breaking Changes
+                 </h4>
+                 <div className="space-y-3">
+                   {impactAnalysis.breakingChanges.map((change: any, index: any) => (
+                     <Alert key={index} variant={change.severity === 'critical' ? 'destructive' : 'default'}>
+                       <AlertTriangle className="h-4 w-4" />
+                       <AlertDescription>
+                         <div className="space-y-2">
+                           <div className="font-medium">{change.description}</div>
+                           <div className="text-sm">
@@ lines 951-957 @@
-                 Recommendations
-               </h4>
-               <div className="space-y-2">
-                 {impactAnalysis.recommendations.map((rec, index) => (
-                   <div key={index} className="flex items-center gap-2 text-sm">
-                     <CheckCircle className="h-3 w-3 text-green-500" />
-                     {rec}
---
+                 Recommendations
+               </h4>
+               <div className="space-y-2">
+                 {impactAnalysis.recommendations.map((rec: any, index: any) => (
+                   <div key={index} className="flex items-center gap-2 text-sm">
+                     <CheckCircle className="h-3 w-3 text-green-500" />
+                     {rec}
+                   </div>
+                 ))}
+               </div>
@@ lines 988-1000 @@
-             </div>
-             <div className="text-center p-4 border rounded-lg">
-               <div className="text-2xl font-bold text-green-600">
-                 {optimizationSuggestions.reduce((sum, s) => sum + (s.savings.bundleSize || 0), 0)}KB
-               </div>
-               <div className="text-sm text-gray-500">Potential Bundle Savings</div>
-             </div>
-             <div className="text-center p-4 border rounded-lg">
-               <div className="text-2xl font-bold text-orange-600">
-                 {optimizationSuggestions.reduce((sum, s) => sum + (s.savings.loadTime || 0), 0)}ms
-               </div>
-               <div className="text-sm text-gray-500">Load Time Savings</div>
-             </div>
---
+             </div>
+             <div className="text-center p-4 border rounded-lg">
+               <div className="text-2xl font-bold text-green-600">
+                 {optimizationSuggestions.reduce((sum: any, s: any) => sum + (s.savings.bundleSize || 0), 0)}KB
+               </div>
+               <div className="text-sm text-gray-500">Potential Bundle Savings</div>
+             </div>
+             <div className="text-center p-4 border rounded-lg">
+               <div className="text-2xl font-bold text-orange-600">
+                 {optimizationSuggestions.reduce((sum: any, s: any) => sum + (s.savings.loadTime || 0), 0)}ms
+               </div>
+               <div className="text-sm text-gray-500">Load Time Savings</div>
+             </div>
+           </div>
+         </CardContent>
+       </Card>
@@ lines 1004-1010 @@
- 
-       {/* Optimization Suggestions */}
-       <div className="space-y-4">
-         {optimizationSuggestions.map(suggestion => (
-           <Card key={suggestion.id}>
-             <CardContent className="p-4">
-               <div className="flex items-start justify-between">
---
+ 
+       {/* Optimization Suggestions */}
+       <div className="space-y-4">
+         {optimizationSuggestions.map(suggestion: any => (
+           <Card key={suggestion.id}>
+             <CardContent className="p-4">
+               <div className="flex items-start justify-between">
+                 <div className="flex-1">
+                   <div className="flex items-center gap-2 mb-2">
+                     <h4 className="font-medium">{suggestion.title}</h4>
@@ lines 1051-1057 @@
-                   
-                   <div className="space-y-1">
-                     <div className="text-sm font-medium">Implementation Steps:</div>
-                     {suggestion.implementation.map((step, index) => (
-                       <div key={index} className="text-sm text-gray-600 flex items-start gap-2">
-                         <span className="text-gray-400">{index + 1}.</span>
-                         {step}
---
+                   
+                   <div className="space-y-1">
+                     <div className="text-sm font-medium">Implementation Steps:</div>
+                     {suggestion.implementation.map((step: any, index: any) => (
+                       <div key={index} className="text-sm text-gray-600 flex items-start gap-2">
+                         <span className="text-gray-400">{index + 1}.</span>
+                         {step}
+                       </div>
+                     ))}
+                   </div>
@@ lines 1091-1097 @@
-   );
- 
-   const renderFileAnalysis = () => {
-     const fileNodes = dependencyGraph.nodes.filter(n => n.type === 'file');
-     
-     return (
-       <div className="space-y-6">
---
+   );
+ 
+   const renderFileAnalysis = () => {
+     const fileNodes = dependencyGraph.nodes.filter(n: any => n.type === 'file');
+     
+     return (
+       <div className="space-y-6">
+         {/* File Analysis Overview */}
+         <Card>
+           <CardHeader>
@@ lines 1111-1129 @@
-               </div>
-               <div className="text-center p-4 border rounded-lg">
-                 <div className="text-2xl font-bold text-orange-600">
-                   {fileNodes.filter(n => n.riskLevel === 'high').length}
-                 </div>
-                 <div className="text-sm text-gray-500">High Risk Files</div>
-               </div>
-               <div className="text-center p-4 border rounded-lg">
-                 <div className="text-2xl font-bold text-green-600">
-                   {dependencyGraph.edges.filter(e => e.type === 'import').length}
-                 </div>
-                 <div className="text-sm text-gray-500">Import Dependencies</div>
-               </div>
-               <div className="text-center p-4 border rounded-lg">
-                 <div className="text-2xl font-bold text-purple-600">
-                   {dependencyGraph.edges.filter(e => e.type === 'hardcoded').length}
-                 </div>
-                 <div className="text-sm text-gray-500">Hardcoded References</div>
-               </div>
---
+               </div>
+               <div className="text-center p-4 border rounded-lg">
+                 <div className="text-2xl font-bold text-orange-600">
+                   {fileNodes.filter(n: any => n.riskLevel === 'high').length}
+                 </div>
+                 <div className="text-sm text-gray-500">High Risk Files</div>
+               </div>
+               <div className="text-center p-4 border rounded-lg">
+                 <div className="text-2xl font-bold text-green-600">
+                   {dependencyGraph.edges.filter(e: any => e.type === 'import').length}
+                 </div>
+                 <div className="text-sm text-gray-500">Import Dependencies</div>
+               </div>
+               <div className="text-center p-4 border rounded-lg">
+                 <div className="text-2xl font-bold text-purple-600">
+                   {dependencyGraph.edges.filter(e: any => e.type === 'hardcoded').length}
+                 </div>
+                 <div className="text-sm text-gray-500">Hardcoded References</div>
+               </div>
+             </div>
+           </CardContent>
+         </Card>
@@ lines 1138-1144 @@
-           </CardHeader>
-           <CardContent>
-             <div className="space-y-3">
-               {fileNodes.map(file => (
-                 <div key={file.id} className="flex items-center justify-between p-3 border rounded-lg">
-                   <div className="flex items-center gap-3">
-                     <FileText className="h-4 w-4 text-orange-500" />
---
+           </CardHeader>
+           <CardContent>
+             <div className="space-y-3">
+               {fileNodes.map(file: any => (
+                 <div key={file.id} className="flex items-center justify-between p-3 border rounded-lg">
+                   <div className="flex items-center gap-3">
+                     <FileText className="h-4 w-4 text-orange-500" />
+                     <div>
+                       <div className="font-medium">{file.name}</div>
+                       <div className="text-sm text-gray-500">{file.path}</div>


*** FILE: services/project-config-manager.ts
@@ lines 156-162 @@
-     
-     for (const group of config.groups) {
-       // Check for orphaned layers in groups
-       const invalidLayers = group.layers.filter(layerId => !allLayerIds.includes(layerId));
-       if (invalidLayers.length > 0) {
-         errors.push({
-           type: 'missing_layer',
---
+     
+     for (const group of config.groups) {
+       // Check for orphaned layers in groups
+       const invalidLayers = group.layers.filter(layerId: any => !allLayerIds.includes(layerId));
+       if (invalidLayers.length > 0) {
+         errors.push({
+           type: 'missing_layer',
+           message: `Group ${group.id} references non-existent layers: ${invalidLayers.join(', ')}`,
+           path: `groups.${group.id}.layers`,
+           severity: 'error',
@@ lines 179-186 @@
-     }
- 
-     // Check for ungrouped layers
-     const groupedLayers = new Set(config.groups.flatMap(g => g.layers));
-     const ungroupedLayers = allLayerIds.filter(id => !groupedLayers.has(id));
-     
-     if (ungroupedLayers.length > 0) {
-       warnings.push({
---
+     }
+ 
+     // Check for ungrouped layers
+     const groupedLayers = new Set(config.groups.flatMap(g: any => g.layers));
+     const ungroupedLayers = allLayerIds.filter(id: any => !groupedLayers.has(id));
+     
+     if (ungroupedLayers.length > 0) {
+       warnings.push({
+         type: 'best_practice',
+         message: `${ungroupedLayers.length} layers are not assigned to any group`,
+         path: 'groups',
@@ lines 203-209 @@
- 
-     // Validate layer mappings
-     for (const [concept, layerIds] of Object.entries(conceptMappings.layerMappings)) {
-       const invalidLayers = layerIds.filter(id => !allLayerIds.includes(id));
-       if (invalidLayers.length > 0) {
-         errors.push({
-           type: 'missing_layer',
---
+ 
+     // Validate layer mappings
+     for (const [concept, layerIds] of Object.entries(conceptMappings.layerMappings)) {
+       const invalidLayers = layerIds.filter(id: any => !allLayerIds.includes(id));
+       if (invalidLayers.length > 0) {
+         errors.push({
+           type: 'missing_layer',
+           message: `Concept ${concept} maps to non-existent layers: ${invalidLayers.join(', ')}`,
+           path: `conceptMappings.layerMappings.${concept}`,
+           severity: 'error',
@@ lines 217-223 @@
- 
-     // Check for unmapped layers
-     const mappedLayers = new Set(Object.values(conceptMappings.layerMappings).flat());
-     const unmappedLayers = allLayerIds.filter(id => !mappedLayers.has(id));
-     
-     if (unmappedLayers.length > 0) {
-       suggestions.push({
---
+ 
+     // Check for unmapped layers
+     const mappedLayers = new Set(Object.values(conceptMappings.layerMappings).flat());
+     const unmappedLayers = allLayerIds.filter(id: any => !mappedLayers.has(id));
+     
+     if (unmappedLayers.length > 0) {
+       suggestions.push({
+         type: 'enhancement',
+         message: `${unmappedLayers.length} layers are not mapped to any concepts`,
+         implementation: 'Add concept mappings to improve AI query understanding',
@@ lines 380-391 @@
-         return {
-           success: false,
-           filesUpdated: [],
-           errors: validationResult.errors.map(e => ({
-             file: e.path,
-             error: e.message,
-             critical: e.severity === 'error'
-           })),
-           warnings: validationResult.warnings.map(w => w.message),
-           rollbackAvailable: false,
-           deploymentId: `test-${Date.now()}`,
-           simulationMode: true,
---
+         return {
+           success: false,
+           filesUpdated: [],
+           errors: validationResult.errors.map(e: any => ({
+             file: e.path,
+             error: e.message,
+             critical: e.severity === 'error'
+           })),
+           warnings: validationResult.warnings.map(w: any => w.message),
+           rollbackAvailable: false,
+           deploymentId: `test-${Date.now()}`,
+           simulationMode: true,
+           queryTestingEnabled: false
+         };
+       }
@@ lines 404-417 @@
-         return {
-           success: false,
-           filesUpdated: [],
-           errors: dependencyTestResults.criticalFailures.map(failure => ({
-             file: 'dependency-testing',
-             error: failure,
-             critical: true
-           })),
-           warnings: Object.entries(dependencyTestResults.results)
-                    .flatMap(([category, result]) => 
-                      result.errors.map(error => `${category}: ${error}`)
-                    ),
-           rollbackAvailable: false,
-           deploymentId: `test-${Date.now()}`,
---
+         return {
+           success: false,
+           filesUpdated: [],
+           errors: dependencyTestResults.criticalFailures.map(failure: any => ({
+             file: 'dependency-testing',
+             error: failure,
+             critical: true
+           })),
+           warnings: Object.entries(dependencyTestResults.results)
+                    .flatMap(([category, result]) => 
+                      result.errors.map(error: any => `${category}: ${error}`)
+                    ),
+           rollbackAvailable: false,
+           deploymentId: `test-${Date.now()}`,
+           simulationMode: true,
+           queryTestingEnabled: false,
+           dependencyTestResults
@@ lines 428-434 @@
-       const structurePreservationResults = await this.generateAllFilesWithStructurePreservation(config);
-       
-       // Check structure preservation success rate
-       const preservationSuccessRate = structurePreservationResults.preservationResults.filter(r => r.preserved).length / 
-                                      structurePreservationResults.preservationResults.length;
-       
-       if (preservationSuccessRate < 1.0) {
---
+       const structurePreservationResults = await this.generateAllFilesWithStructurePreservation(config);
+       
+       // Check structure preservation success rate
+       const preservationSuccessRate = structurePreservationResults.preservationResults.filter(r: any => r.preserved).length / 
+                                      structurePreservationResults.preservationResults.length;
+       
+       if (preservationSuccessRate < 1.0) {
+         console.error(`🚨 Structure preservation failed: ${(preservationSuccessRate * 100).toFixed(1)}% success rate`);
+         return {
+           success: false,
@@ lines 442-449 @@
-             critical: true
-           }],
-           warnings: structurePreservationResults.preservationResults
-                    .filter(r => !r.preserved)
-                    .map(r => `Failed to preserve structure in ${r.file}: ${r.reason}`),
-           rollbackAvailable: false,
-           deploymentId: `test-${Date.now()}`,
-           simulationMode: true,
---
+             critical: true
+           }],
+           warnings: structurePreservationResults.preservationResults
+                    .filter(r: any => !r.preserved)
+                    .map(r: any => `Failed to preserve structure in ${r.file}: ${r.reason}`),
+           rollbackAvailable: false,
+           deploymentId: `test-${Date.now()}`,
+           simulationMode: true,
+           queryTestingEnabled: false,
+           dependencyTestResults
+         };
@@ lines 493-499 @@
-       let displayFailures = 0;
-       
-       if (queryTestResults.failedTests) {
-         queryTestResults.failedTests.forEach(test => {
-           switch (test.pipelineStage) {
-             case 'parsing': parsingFailures++; break;
-             case 'classification': classificationFailures++; break;
---
+       let displayFailures = 0;
+       
+       if (queryTestResults.failedTests) {
+         queryTestResults.failedTests.forEach(test: any => {
+           switch (test.pipelineStage) {
+             case 'parsing': parsingFailures++; break;
+             case 'classification': classificationFailures++; break;
+             case 'visualization': visualizationFailures++; break;
+             case 'display': displayFailures++; break;
+           }
@@ lines 560-571 @@
-         return {
-           success: false,
-           filesUpdated: [],
-           errors: validationResult.errors.map(e => ({
-             file: e.path,
-             error: e.message,
-             critical: e.severity === 'error'
-           })),
-           warnings: validationResult.warnings.map(w => w.message),
-           rollbackAvailable: false,
-           deploymentId: `test-${Date.now()}`,
-           simulationMode: true,
---
+         return {
+           success: false,
+           filesUpdated: [],
+           errors: validationResult.errors.map(e: any => ({
+             file: e.path,
+             error: e.message,
+             critical: e.severity === 'error'
+           })),
+           warnings: validationResult.warnings.map(w: any => w.message),
+           rollbackAvailable: false,
+           deploymentId: `test-${Date.now()}`,
+           simulationMode: true,
+           queryTestingEnabled: false
+         };
+       }
@@ lines 578-584 @@
-       const structurePreservationResults = await this.generateAllFilesWithStructurePreservation(config);
-       
-       // Check structure preservation success rate
-       const preservationSuccessRate = structurePreservationResults.preservationResults.filter(r => r.preserved).length / 
-                                      structurePreservationResults.preservationResults.length;
-       
-       if (preservationSuccessRate < 1.0) {
---
+       const structurePreservationResults = await this.generateAllFilesWithStructurePreservation(config);
+       
+       // Check structure preservation success rate
+       const preservationSuccessRate = structurePreservationResults.preservationResults.filter(r: any => r.preserved).length / 
+                                      structurePreservationResults.preservationResults.length;
+       
+       if (preservationSuccessRate < 1.0) {
+         console.error(`🚨 Structure preservation failed: ${(preservationSuccessRate * 100).toFixed(1)}% success rate`);
+         return {
+           success: false,
@@ lines 592-599 @@
-             critical: true
-           }],
-           warnings: structurePreservationResults.preservationResults
-                    .filter(r => !r.preserved)
-                    .map(r => `Failed to preserve structure in ${r.file}: ${r.reason}`),
-           rollbackAvailable: false,
-           deploymentId: `test-${Date.now()}`,
-           simulationMode: true,
---
+             critical: true
+           }],
+           warnings: structurePreservationResults.preservationResults
+                    .filter(r: any => !r.preserved)
+                    .map(r: any => `Failed to preserve structure in ${r.file}: ${r.reason}`),
+           rollbackAvailable: false,
+           deploymentId: `test-${Date.now()}`,
+           simulationMode: true,
+           queryTestingEnabled: false
+         };
+       }
@@ lines 642-648 @@
-       let displayFailures = 0;
-       
-       if (queryTestResults.failedTests) {
-         queryTestResults.failedTests.forEach(test => {
-           switch (test.pipelineStage) {
-             case 'parsing': parsingFailures++; break;
-             case 'classification': classificationFailures++; break;
---
+       let displayFailures = 0;
+       
+       if (queryTestResults.failedTests) {
+         queryTestResults.failedTests.forEach(test: any => {
+           switch (test.pipelineStage) {
+             case 'parsing': parsingFailures++; break;
+             case 'classification': classificationFailures++; break;
+             case 'visualization': visualizationFailures++; break;
+             case 'display': displayFailures++; break;
+           }
@@ lines 807-813 @@
-     // Helper function to normalize field objects
-     const normalizeFields = (fields: any[]): any[] => {
-       if (!Array.isArray(fields)) return [];
-       return fields.map(field => {
-         const normalizedField: any = {
-           name: field.name || 'unknown',
-           type: mapFieldType(field.type || 'string')
---
+     // Helper function to normalize field objects
+     const normalizeFields = (fields: any[]): any[] => {
+       if (!Array.isArray(fields)) return [];
+       return fields.map(field: any => {
+         const normalizedField: any = {
+           name: field.name || 'unknown',
+           type: mapFieldType(field.type || 'string')
+         };
+         // Only include properties that exist in LayerField interface
+         if (field.alias) normalizedField.alias = field.alias;
@@ lines 859-865 @@
- 
-     // This generates a config that maintains the expected structure
-     // even without access to the original file
-     const layersArray = Object.values(config.layers).map(layer => {
-       const layerAny = layer as any;
-       const normalizedFields = normalizeFields(layer.fields || []);
-       const normalizedMetadata = normalizeMetadata(layer.metadata);
---
+ 
+     // This generates a config that maintains the expected structure
+     // even without access to the original file
+     const layersArray = Object.values(config.layers).map(layer: any => {
+       const layerAny = layer as any;
+       const normalizedFields = normalizeFields(layer.fields || []);
+       const normalizedMetadata = normalizeMetadata(layer.metadata);
+       const normalizedType = mapLayerType(layer.type);
+       
+       return `  {
@@ lines 1143-1149 @@
-       // Helper function to normalize field objects
-       const normalizeFields = (fields: any[]): any[] => {
-         if (!Array.isArray(fields)) return [];
-         return fields.map(field => {
-           const normalizedField: any = {
-             name: field.name || 'unknown',
-             type: mapFieldType(field.type || 'string')
---
+       // Helper function to normalize field objects
+       const normalizeFields = (fields: any[]): any[] => {
+         if (!Array.isArray(fields)) return [];
+         return fields.map(field: any => {
+           const normalizedField: any = {
+             name: field.name || 'unknown',
+             type: mapFieldType(field.type || 'string')
+           };
+           // Only include properties that exist in LayerField interface
+           if (field.alias) normalizedField.alias = field.alias;
@@ lines 1292-1312 @@
-     // Now, build the groups exactly as defined in the project config
-     console.log('🔍 Building groups from project config:', {
-       configGroups: projectConfig.groups.length,
-       groupNames: projectConfig.groups.map(g => g.name),
-       groupIds: projectConfig.groups.map(g => g.id),
-       availableLayers: Object.keys(adaptedLayers)
-     });
- 
-     const groups: LayerGroup[] = projectConfig.groups.map(groupConfig => {
-       // Get the full layer objects for the IDs in the group
-       const groupLayers: LayerConfig[] = groupConfig.layers
-         .map(layerId => adaptedLayers[layerId])
-         .filter((l): l is LayerConfig => l !== undefined);
-         
-       console.log(`📋 Group "${groupConfig.name}" (${groupConfig.id}):`, {
-         requestedLayers: groupConfig.layers,
-         foundLayers: groupLayers.length,
-         layerNames: groupLayers.map(l => l.name)
-       });
-         
-       return {
---
+     // Now, build the groups exactly as defined in the project config
+     console.log('🔍 Building groups from project config:', {
+       configGroups: projectConfig.groups.length,
+       groupNames: projectConfig.groups.map(g: any => g.name),
+       groupIds: projectConfig.groups.map(g: any => g.id),
+       availableLayers: Object.keys(adaptedLayers)
+     });
+ 
+     const groups: LayerGroup[] = projectConfig.groups.map(groupConfig: any => {
+       // Get the full layer objects for the IDs in the group
+       const groupLayers: LayerConfig[] = groupConfig.layers
+         .map(layerId: any => adaptedLayers[layerId])
+         .filter((l: any): l is LayerConfig => l !== undefined);
+         
+       console.log(`📋 Group "${groupConfig.name}" (${groupConfig.id}):`, {
+         requestedLayers: groupConfig.layers,
+         foundLayers: groupLayers.length,
+         layerNames: groupLayers.map(l: any => l.name)
+       });
+         
+       return {
+         id: groupConfig.id,
+         title: groupConfig.name, // Use the name from the config
+         description: groupConfig.description || `${groupConfig.name} data`,
@@ lines 1318-1324 @@
-     });
-   
-     const defaultVisibility: { [key:string]: boolean } = {};
-   Object.values(adaptedLayers).forEach(adaptedConfig => {
-     if (adaptedConfig) {
-       defaultVisibility[adaptedConfig.id] = false;
-     }
---
+     });
+   
+     const defaultVisibility: { [key:string]: boolean } = {};
+   Object.values(adaptedLayers).forEach(adaptedConfig: any => {
+     if (adaptedConfig) {
+       defaultVisibility[adaptedConfig.id] = false;
+     }
+   });
+ 
+     // Create dynamic default collapsed state based on the actual groups from the config
@@ lines 1326-1332 @@
- 
-     // Create dynamic default collapsed state based on the actual groups from the config
-     const defaultCollapsed: Record<string, boolean> = {};
-     projectConfig.groups.forEach(groupConfig => {
-       defaultCollapsed[groupConfig.id] = groupConfig.id !== 'nesto-group'; // Only nesto expanded by default
-     });
- 
---
+ 
+     // Create dynamic default collapsed state based on the actual groups from the config
+     const defaultCollapsed: Record<string, boolean> = {};
+     projectConfig.groups.forEach(groupConfig: any => {
+       defaultCollapsed[groupConfig.id] = groupConfig.id !== 'nesto-group'; // Only nesto expanded by default
+     });
+ 
+   return {
+     layers: adaptedLayers,
+       groups: groups,
@@ lines 1397-1405 @@
-         .toLowerCase();
-     };
- 
-     const layerIdArrays = Object.values(config.groups).map(group => {
-       const sanitizedGroupName = sanitizeVariableName(group.name);
-       const layerIds = group.layers.map(id => `'${id}'`).join(', ');
-       return `export const ${sanitizedGroupName}LayerIds = [${layerIds}];`;
-     }).join('\n');
- 
---
+         .toLowerCase();
+     };
+ 
+     const layerIdArrays = Object.values(config.groups).map(group: any => {
+       const sanitizedGroupName = sanitizeVariableName(group.name);
+       const layerIds = group.layers.map(id: any => `'${id}'`).join(', ');
+       return `export const ${sanitizedGroupName}LayerIds = [${layerIds}];`;
+     }).join('\n');
+ 
+     // Find and replace the layer ID arrays section
+     const layerArraysRegex = /export const \w+LayerIds = \[[\s\S]*?\];/g;
+     
@@ lines 1459-1467 @@
- 
-       // Analyze file dependencies
-       const dependencies = this.getDependenciesForChange(change);
-       dependencies.files.forEach(f => affectedFiles.add(f));
-       dependencies.components.forEach(c => affectedComponents.add(c));
-       dependencies.services.forEach(s => affectedServices.add(s));
-     }
- 
-     return {
---
+ 
+       // Analyze file dependencies
+       const dependencies = this.getDependenciesForChange(change);
+       dependencies.files.forEach(f: any => affectedFiles.add(f));
+       dependencies.components.forEach(c: any => affectedComponents.add(c));
+       dependencies.services.forEach(s: any => affectedServices.add(s));
+     }
+ 
+     return {
+       affectedFiles: Array.from(affectedFiles),
+       affectedComponents: Array.from(affectedComponents),
+       affectedServices: Array.from(affectedServices),
@@ lines 1511-1517 @@
-       ];
- 
-       if (category) {
-         return templates.filter(t => t.category === category);
-       }
-       
-       return templates;
---
+       ];
+ 
+       if (category) {
+         return templates.filter(t: any => t.category === category);
+       }
+       
+       return templates;
+     } catch (error) {
+       console.error('Error getting templates:', error);
+       return [];
@@ lines 1545-1551 @@
- 
-   async createConfigurationFromTemplate(templateId: string, projectName: string): Promise<ProjectConfiguration> {
-     const templates = await this.getTemplates();
-     const template = templates.find(t => t.id === templateId);
-     
-     if (!template) {
-       throw new Error(`Template ${templateId} not found`);
---
+ 
+   async createConfigurationFromTemplate(templateId: string, projectName: string): Promise<ProjectConfiguration> {
+     const templates = await this.getTemplates();
+     const template = templates.find(t: any => t.id === templateId);
+     
+     if (!template) {
+       throw new Error(`Template ${templateId} not found`);
+     }
+ 
+     // Clone and customize the configuration
@@ lines 1689-1696 @@
-   private generateDynamicLayersConfig(config: ProjectConfiguration): string {
-     // Generate dynamic layers configuration based on project config
-     const layerIds = Object.keys(config.layers);
-     const groupIds = config.groups.map(g => g.id);
-     const layersByGroup = config.groups.reduce((acc, group) => {
-       acc[group.id] = group.layers;
-       return acc;
-     }, {} as Record<string, string[]>);
---
+   private generateDynamicLayersConfig(config: ProjectConfiguration): string {
+     // Generate dynamic layers configuration based on project config
+     const layerIds = Object.keys(config.layers);
+     const groupIds = config.groups.map(g: any => g.id);
+     const layersByGroup = config.groups.reduce((acc: any, group: any) => {
+       acc[group.id] = group.layers;
+       return acc;
+     }, {} as Record<string, string[]>);
+ 
+     return `// Dynamic layers configuration
+ // Auto-generated from project configuration
@@ lines 1750-1756 @@
-     // Helper function to normalize field objects
-     const normalizeFields = (fields: any[]): any[] => {
-       if (!Array.isArray(fields)) return [];
-         return fields.map(field => ({
-           name: field.name || 'unknown',
-           type: field.type || 'string',
-           ...(field.alias && { alias: field.alias }),
---
+     // Helper function to normalize field objects
+     const normalizeFields = (fields: any[]): any[] => {
+       if (!Array.isArray(fields)) return [];
+         return fields.map(field: any => ({
+           name: field.name || 'unknown',
+           type: field.type || 'string',
+           ...(field.alias && { alias: field.alias }),
+           ...(field.label && { label: field.label }),
+           ...(field.description && { description: field.description }),
+           ...(field.alternateNames && { alternateNames: field.alternateNames })
@@ lines 1793-1799 @@
-       };
- 
-       // Generate the new baseLayerConfigs array content
-     const layersArray = Object.values(config.layers).map(layer => {
-       const layerAny = layer as any;
-       const normalizedFields = normalizeFields(layer.fields || []);
-       const normalizedMetadata = normalizeMetadata(layer.metadata);
---
+       };
+ 
+       // Generate the new baseLayerConfigs array content
+     const layersArray = Object.values(config.layers).map(layer: any => {
+       const layerAny = layer as any;
+       const normalizedFields = normalizeFields(layer.fields || []);
+       const normalizedMetadata = normalizeMetadata(layer.metadata);
+       
+       return `  {
+     id: '${layer.id}',
@@ lines 1849-1855 @@
- 
-   private generateBasicLayerConfigFile(config: ProjectConfiguration): string {
-     // Fallback basic generation - only used if structure preservation fails
-     const layersArray = Object.values(config.layers).map(layer => 
-       `  {
-     id: '${layer.id}',
-     name: '${layer.name}',
---
+ 
+   private generateBasicLayerConfigFile(config: ProjectConfiguration): string {
+     // Fallback basic generation - only used if structure preservation fails
+     const layersArray = Object.values(config.layers).map(layer: any => 
+       `  {
+     id: '${layer.id}',
+     name: '${layer.name}',
+     type: '${layer.type}',
+     url: '${layer.url}',
+     group: '${layer.group}',
@@ lines 1946-1954 @@
-     const aliases: Record<string, string> = {};
-     
-     // Extract aliases from layers
-     Object.values(config.layers).forEach(layer => {
-       if (layer.fields) {
-         layer.fields.forEach(field => {
-           if (field.alias && field.name) {
-             aliases[field.alias.toLowerCase()] = field.name;
-           }
---
+     const aliases: Record<string, string> = {};
+     
+     // Extract aliases from layers
+     Object.values(config.layers).forEach(layer: any => {
+       if (layer.fields) {
+         layer.fields.forEach(field: any => {
+           if (field.alias && field.name) {
+             aliases[field.alias.toLowerCase()] = field.name;
+           }
+         });
+       }
+     });
@@ lines 1968-1976 @@
-     const mappings: Record<string, string> = {};
-     
-     // Basic mappings based on configuration
-     Object.values(config.layers).forEach(layer => {
-       if (layer.fields) {
-         layer.fields.forEach(field => {
-           if (field.name) {
-             mappings[field.name] = field.name;
-           }
---
+     const mappings: Record<string, string> = {};
+     
+     // Basic mappings based on configuration
+     Object.values(config.layers).forEach(layer: any => {
+       if (layer.fields) {
+         layer.fields.forEach(field: any => {
+           if (field.name) {
+             mappings[field.name] = field.name;
+           }
+         });
+       }
+     });
@@ lines 2291-2297 @@
-     // Helper function to normalize field objects
-     const normalizeFields = (fields: any[]): any[] => {
-       if (!Array.isArray(fields)) return [];
-       return fields.map(field => {
-         const normalizedField: any = {
-           name: field.name || 'unknown',
-           type: mapFieldType(field.type || 'string')
---
+     // Helper function to normalize field objects
+     const normalizeFields = (fields: any[]): any[] => {
+       if (!Array.isArray(fields)) return [];
+       return fields.map(field: any => {
+         const normalizedField: any = {
+           name: field.name || 'unknown',
+           type: mapFieldType(field.type || 'string')
+         };
+         // Only include properties that exist in LayerField interface
+         if (field.alias) normalizedField.alias = field.alias;
@@ lines 2343-2349 @@
- 
-     // This generates a config that maintains the expected structure
-     // even without access to the original file
-     const layersArray = Object.values(config.layers).map(layer => {
-       const layerAny = layer as any;
-       const normalizedFields = normalizeFields(layer.fields || []);
-       const normalizedMetadata = normalizeMetadata(layer.metadata);
---
+ 
+     // This generates a config that maintains the expected structure
+     // even without access to the original file
+     const layersArray = Object.values(config.layers).map(layer: any => {
+       const layerAny = layer as any;
+       const normalizedFields = normalizeFields(layer.fields || []);
+       const normalizedMetadata = normalizeMetadata(layer.metadata);
+       const normalizedType = mapLayerType(layer.type);
+       
+       return `  {
@@ lines 2544-2550 @@
- 
-   // Preserve structure in existing layers config
-   private preserveStructureInLayersConfig(existingContent: string, config: ProjectConfiguration): string {
-     const layersArray = Object.values(config.layers).map(layer => {
-       const layerAny = layer as any;
-       return `  {
-     id: '${layer.id}',
---
+ 
+   // Preserve structure in existing layers config
+   private preserveStructureInLayersConfig(existingContent: string, config: ProjectConfiguration): string {
+     const layersArray = Object.values(config.layers).map(layer: any => {
+       const layerAny = layer as any;
+       return `  {
+     id: '${layer.id}',
+     name: '${layer.name}',
+     type: '${layer.type}',
+     url: '${layer.url}',
@@ lines 2650-2658 @@
-       console.log('⚙️ Testing Configuration Files...');
-       await this.testConfigurationFiles(config, results.configurationFiles, criticalFailures);
- 
-       const totalFiles = Object.values(results).reduce((sum, category) => sum + category.passed + category.failed, 0);
-       const passedFiles = Object.values(results).reduce((sum, category) => sum + category.passed, 0);
-       const failedFiles = Object.values(results).reduce((sum, category) => sum + category.failed, 0);
- 
-       console.log(`✅ Dependency testing complete: ${passedFiles}/${totalFiles} files passed`);
-       
---
+       console.log('⚙️ Testing Configuration Files...');
+       await this.testConfigurationFiles(config, results.configurationFiles, criticalFailures);
+ 
+       const totalFiles = Object.values(results).reduce((sum: any, category: any) => sum + category.passed + category.failed, 0);
+       const passedFiles = Object.values(results).reduce((sum: any, category: any) => sum + category.passed, 0);
+       const failedFiles = Object.values(results).reduce((sum: any, category: any) => sum + category.failed, 0);
+ 
+       console.log(`✅ Dependency testing complete: ${passedFiles}/${totalFiles} files passed`);
+       
+       if (criticalFailures.length > 0) {
+         console.error('🚨 CRITICAL FAILURES detected:', criticalFailures);
+       }
@@ lines 3235-3243 @@
-   private extractFieldsFromConfig(config: ProjectConfiguration): string[] {
-     const fields: string[] = [];
-     
-     Object.values(config.layers).forEach(layer => {
-       if (layer.fields) {
-         layer.fields.forEach(field => {
-           if (field.name) {
-             fields.push(field.name);
-           }
---
+   private extractFieldsFromConfig(config: ProjectConfiguration): string[] {
+     const fields: string[] = [];
+     
+     Object.values(config.layers).forEach(layer: any => {
+       if (layer.fields) {
+         layer.fields.forEach(field: any => {
+           if (field.name) {
+             fields.push(field.name);
+           }
+         });
+       }
+     });


*** FILE: utils/visualization-factory.ts
@@ lines 130-136 @@
-   }
- 
-   // Default to default for demographic data
-   const hasDemographicData = relevantLayers.some(layer => 
-     layer.layerId.startsWith('virtual')
-   );
- 
---
+   }
+ 
+   // Default to default for demographic data
+   const hasDemographicData = relevantLayers.some(layer: any => 
+     layer.layerId.startsWith('virtual')
+   );
+ 
+   if (hasDemographicData) {
+     return 'default';
+   }
@@ lines 229-235 @@
-     }
-     
-     // Transform layerResults to the expected LocalLayerResult format
-     const localLayerResults: LocalLayerResult[] = layerResults.map(lr => ({
-       layer: {
-         id: lr.layerId,
-         name: lr.layerName,
---
+     }
+     
+     // Transform layerResults to the expected LocalLayerResult format
+     const localLayerResults: LocalLayerResult[] = layerResults.map(lr: any => ({
+       layer: {
+         id: lr.layerId,
+         name: lr.layerName,
+         type: lr.layerType || 'polygon', // default to polygon
+         fields: lr.fields || []
+       },
@@ lines 336-342 @@
- 
-           // Build a map of normalised numeric field keys that actually exist in the data → original key
-           const numericFieldLookup: Record<string, string> = {};
-           numericFields.forEach((key) => {
-             const norm = normalise(key);
-             if (!(norm in numericFieldLookup)) numericFieldLookup[norm] = key;
-           });
---
+ 
+           // Build a map of normalised numeric field keys that actually exist in the data → original key
+           const numericFieldLookup: Record<string, string> = {};
+           numericFields.forEach((key: any) => {
+             const norm = normalise(key);
+             if (!(norm in numericFieldLookup)) numericFieldLookup[norm] = key;
+           });
+ 
+           // ----- ENSURE BRAND FIELDS PRESENT ---------------------------------
+           // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
@@ lines 345-354 @@
-           // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
-           // Force-add the two orderedCandidates (canonical + snake_case) to numericFieldLookup
-           const ensureCandidateFields = (candidates: string[]) => {
-             candidates.forEach(cand => {
-               if (!cand) return;
-               const variants = [cand, cand.toLowerCase().replace(/a_b$/, '_a_b')];
-               variants.forEach(variant => {
-                 const norm = normalise(variant);
-                 if (!(norm in numericFieldLookup)) {
-                   numericFieldLookup[norm] = variant;
---
+           // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
+           // Force-add the two orderedCandidates (canonical + snake_case) to numericFieldLookup
+           const ensureCandidateFields = (candidates: string[]) => {
+             candidates.forEach(cand: any => {
+               if (!cand) return;
+               const variants = [cand, cand.toLowerCase().replace(/a_b$/, '_a_b')];
+               variants.forEach(variant: any => {
+                 const norm = normalise(variant);
+                 if (!(norm in numericFieldLookup)) {
+                   numericFieldLookup[norm] = variant;
+                   if (!numericFields.includes(variant)) numericFields.push(variant);
+                 }
+               });
@@ lines 385-391 @@
-           const primaryFieldResolved = orderedCandidates.map(resolveCandidate).find(Boolean);
-           const comparisonFieldResolved = orderedCandidates
-             .map(resolveCandidate)
-             .find((f) => f && f !== primaryFieldResolved);
- 
-           // Enhanced debugging to understand the mismatch
-          /* console.log('[VisualizationFactory DEBUG] Field resolution details:', {
---
+           const primaryFieldResolved = orderedCandidates.map(resolveCandidate).find(Boolean);
+           const comparisonFieldResolved = orderedCandidates
+             .map(resolveCandidate)
+             .find((f: any) => f && f !== primaryFieldResolved);
+ 
+           // Enhanced debugging to understand the mismatch
+          /* console.log('[VisualizationFactory DEBUG] Field resolution details:', {
+             orderedCandidates,
+             numericFieldsSample: numericFields.slice(0, 20),
+             numericFieldLookup: Object.fromEntries(Object.entries(numericFieldLookup).slice(0, 10)),
@@ lines 423-431 @@
-             }
-             
-             // Check if this is a data join failure (analysis results missing from geographic features)
-             const hasAnalysisFields = numericFields.some(field => {
-               const norm = normalise(field);
-               return !['objectid', 'fid', 'creationdate', 'editdate', 'dguid', 'pruid', 'landarea', 'count'].some(pattern => norm.includes(pattern));
-             });
-             
-             if (!hasAnalysisFields) {
---
+             }
+             
+             // Check if this is a data join failure (analysis results missing from geographic features)
+             const hasAnalysisFields = numericFields.some(field: any => {
+               const norm = normalise(field);
+               return !['objectid', 'fid', 'creationdate', 'editdate', 'dguid', 'pruid', 'landarea', 'count'].some(pattern: any => norm.includes(pattern));
+             });
+             
+             if (!hasAnalysisFields) {
+               console.error('[VisualizationFactory] Analysis fields missing from joined data. This suggests the microservice results failed to join with geographic features.');
+               throw new Error(`Unable to create visualization: The requested fields (${orderedCandidates.join(', ')}) are not available in the analysis results. This may indicate a data processing issue.`);
+             }
@@ lines 641-650 @@
-             const sampleFeature = primaryLayer.features[0];
-             const availableFields = Object.keys(sampleFeature.properties || sampleFeature.attributes || {});
-             console.log('[VisualizationFactory] Available fields in features:', {
-               availableFields: availableFields.filter(f => f.includes('MP30')),
-               primaryFieldExists: availableFields.includes(primaryField),
-               secondaryFieldExists: availableFields.includes(secondaryField),
-               sampleData: availableFields.reduce((acc, field) => {
-                 if (field.includes('MP30')) {
-                   acc[field] = (sampleFeature.properties || sampleFeature.attributes || {})[field];
-                 }
---
+             const sampleFeature = primaryLayer.features[0];
+             const availableFields = Object.keys(sampleFeature.properties || sampleFeature.attributes || {});
+             console.log('[VisualizationFactory] Available fields in features:', {
+               availableFields: availableFields.filter(f: any => f.includes('MP30')),
+               primaryFieldExists: availableFields.includes(primaryField),
+               secondaryFieldExists: availableFields.includes(secondaryField),
+               sampleData: availableFields.reduce((acc: any, field: any) => {
+                 if (field.includes('MP30')) {
+                   acc[field] = (sampleFeature.properties || sampleFeature.attributes || {})[field];
+                 }
+                 return acc;
+               }, {} as any)
+             });
@@ lines 727-733 @@
-             return { layer: null, extent: null };
-           }
-           
-           if (featuresForViz.filter(f => f.geometry).length === 0) {
-             console.error('[VisualizationFactory ERROR] No features with geometry available for difference visualization');
-             return { layer: null, extent: null };
-           }
---
+             return { layer: null, extent: null };
+           }
+           
+           if (featuresForViz.filter(f: any => f.geometry).length === 0) {
+             console.error('[VisualizationFactory ERROR] No features with geometry available for difference visualization');
+             return { layer: null, extent: null };
+           }
+           
+           // Extract brand names from field codes
+           const getBrandFromField = (field: string): string => {
@@ lines 861-867 @@
- 
- 
-   private prepareCorrelationData(layerResults: any[], options: VisualizationOptions) {
-     const combinedFeatures = layerResults.flatMap(result => result.features || []);
-     const primaryLayerResult = layerResults[0];
-     if (!primaryLayerResult || combinedFeatures.length === 0) {
-       return null;
---
+ 
+ 
+   private prepareCorrelationData(layerResults: any[], options: VisualizationOptions) {
+     const combinedFeatures = layerResults.flatMap(result: any => result.features || []);
+     const primaryLayerResult = layerResults[0];
+     if (!primaryLayerResult || combinedFeatures.length === 0) {
+       return null;
+     }
+     const layerConfig = primaryLayerResult.layer || primaryLayerResult;
+ 
@@ lines 933-939 @@
- 
-       // Build a map of normalised numeric field keys that actually exist in the data → original key
-       const numericFieldLookup: Record<string, string> = {};
-       numericFields.forEach((key) => {
-         const norm = normalise(key);
-         if (!(norm in numericFieldLookup)) numericFieldLookup[norm] = key;
-       });
---
+ 
+       // Build a map of normalised numeric field keys that actually exist in the data → original key
+       const numericFieldLookup: Record<string, string> = {};
+       numericFields.forEach((key: any) => {
+         const norm = normalise(key);
+         if (!(norm in numericFieldLookup)) numericFieldLookup[norm] = key;
+       });
+ 
+       // ----- ENSURE BRAND FIELDS PRESENT ---------------------------------
+       // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
@@ lines 942-951 @@
-       // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
-       // Force-add the two orderedCandidates (canonical + snake_case) to numericFieldLookup
-       const ensureCandidateFields = (candidates: string[]) => {
-         candidates.forEach(cand => {
-           if (!cand) return;
-           const variants = [cand, cand.toLowerCase().replace(/a_b$/, '_a_b')];
-           variants.forEach(variant => {
-             const norm = normalise(variant);
-             if (!(norm in numericFieldLookup)) {
-               numericFieldLookup[norm] = variant;
---
+       // Some brand columns are sparse and may not appear in first SAMPLE_COUNT rows.
+       // Force-add the two orderedCandidates (canonical + snake_case) to numericFieldLookup
+       const ensureCandidateFields = (candidates: string[]) => {
+         candidates.forEach(cand: any => {
+           if (!cand) return;
+           const variants = [cand, cand.toLowerCase().replace(/a_b$/, '_a_b')];
+           variants.forEach(variant: any => {
+             const norm = normalise(variant);
+             if (!(norm in numericFieldLookup)) {
+               numericFieldLookup[norm] = variant;
+               if (!numericFields.includes(variant)) numericFields.push(variant);
+             }
+           });
@@ lines 984-997 @@
-       // CRITICAL FIX: For multi-layer correlations, resolve fields more intelligently
-       const resolvedFields = orderedCandidates.map(resolveCandidate).filter(Boolean);
-       const primaryField = resolvedFields[0];
-       let comparisonField = resolvedFields.find(f => f !== primaryField);
- 
-       // If we can't find the comparison field in the combined data, 
-       // check if it exists in the original relevantFields but just wasn't found in the data
-       if (!comparisonField && relevantFields.length >= 2) {
-         const secondCandidate = relevantFields[1];
-         // Try direct field name matching even if it wasn't in numericFieldLookup
-         const directMatch = featuresForViz.some(f => f?.properties?.[secondCandidate] !== undefined);
-         if (directMatch) {
-           comparisonField = secondCandidate;
-           //console.log('[VizFactory] Found comparison field via direct matching:', secondCandidate);
---
+       // CRITICAL FIX: For multi-layer correlations, resolve fields more intelligently
+       const resolvedFields = orderedCandidates.map(resolveCandidate).filter(Boolean);
+       const primaryField = resolvedFields[0];
+       let comparisonField = resolvedFields.find(f: any => f !== primaryField);
+ 
+       // If we can't find the comparison field in the combined data, 
+       // check if it exists in the original relevantFields but just wasn't found in the data
+       if (!comparisonField && relevantFields.length >= 2) {
+         const secondCandidate = relevantFields[1];
+         // Try direct field name matching even if it wasn't in numericFieldLookup
+         const directMatch = featuresForViz.some(f: any => f?.properties?.[secondCandidate] !== undefined);
+         if (directMatch) {
+           comparisonField = secondCandidate;
+           //console.log('[VizFactory] Found comparison field via direct matching:', secondCandidate);
+         }
+       }
+ 
@@ lines 1013-1021 @@
-     if (!primaryField) {
-       console.warn('[VisualizationFactory] No primary field found, using fallback');
-       // Use first available numeric field as fallback
-       const fallbackPrimary = numericFields.find(f => !placeholderFields.includes(f)) || 'OBJECTID';
-       const finalPrimaryField = fallbackPrimary;
-       const finalComparisonField = comparisonField || numericFields.find(f => f !== finalPrimaryField && !placeholderFields.includes(f)) || 'OBJECTID';
-       
-       /*console.log('[VisualizationFactory] Using fallback fields:', {
-         primary: finalPrimaryField,
---
+     if (!primaryField) {
+       console.warn('[VisualizationFactory] No primary field found, using fallback');
+       // Use first available numeric field as fallback
+       const fallbackPrimary = numericFields.find(f: any => !placeholderFields.includes(f)) || 'OBJECTID';
+       const finalPrimaryField = fallbackPrimary;
+       const finalComparisonField = comparisonField || numericFields.find(f: any => f !== finalPrimaryField && !placeholderFields.includes(f)) || 'OBJECTID';
+       
+       /*console.log('[VisualizationFactory] Using fallback fields:', {
+         primary: finalPrimaryField,
+         comparison: finalComparisonField,
+         availableFields: numericFields
+       });*/
@@ lines 1024-1030 @@
-       });*/
- 
-       return {
-         features: combinedFeatures.map((feature, index) => ({
-           geometry: feature.geometry,
-           attributes: {
-             OBJECTID: index + 1,
---
+       });*/
+ 
+       return {
+         features: combinedFeatures.map((feature: any, index: any) => ({
+           geometry: feature.geometry,
+           attributes: {
+             OBJECTID: index + 1,
+             primary_value: this.getNumericValue(feature.properties?.[finalPrimaryField] || feature.attributes?.[finalPrimaryField] || 0),
+             comparison_value: this.getNumericValue(feature.properties?.[finalComparisonField] || feature.attributes?.[finalComparisonField] || 0),
+             correlation_strength: 0,
@@ lines 1058-1064 @@
-     let finalComparisonField = comparisonField;
-     if (!finalComparisonField) {
-       // Find a different numeric field that's not the primary field
-       finalComparisonField = numericFields.find(f => f !== primaryField && !placeholderFields.includes(f));
-       if (!finalComparisonField) {
-         console.warn('[VisualizationFactory] No suitable comparison field found, using primary field as fallback');
-         finalComparisonField = primaryField;
---
+     let finalComparisonField = comparisonField;
+     if (!finalComparisonField) {
+       // Find a different numeric field that's not the primary field
+       finalComparisonField = numericFields.find(f: any => f !== primaryField && !placeholderFields.includes(f));
+       if (!finalComparisonField) {
+         console.warn('[VisualizationFactory] No suitable comparison field found, using primary field as fallback');
+         finalComparisonField = primaryField;
+       }
+     }
+ 
@@ lines 1202-1208 @@
-       'regions that have high.*and.*'
-     ];
-     
-     const hasJointHighPattern = jointHighKeywords.some(pattern => 
-       new RegExp(pattern, 'i').test(query)
-     );
-     
---
+       'regions that have high.*and.*'
+     ];
+     
+     const hasJointHighPattern = jointHighKeywords.some(pattern: any => 
+       new RegExp(pattern, 'i').test(query)
+     );
+     
+     // Additional check for "and" with superlative terms and multiple layer results
+     const hasSuperlativeAndMultipleVariables = (
+       (query.includes('highest') || query.includes('top') || query.includes('most')) &&
@@ lines 1240-1246 @@
-       'interest trends'
-     ];
-     
-     const hasTrendsKeyword = trendsKeywords.some(keyword => query.includes(keyword));
- 
-     // Enhanced correlation keyword detection
-     const correlationKeywords = [
---
+       'interest trends'
+     ];
+     
+     const hasTrendsKeyword = trendsKeywords.some(keyword: any => query.includes(keyword));
+ 
+     // Enhanced correlation keyword detection
+     const correlationKeywords = [
+       'compare',
+       'relationship',
+       'correlation',
@@ lines 1254-1260 @@
-       'connection'
-     ];
-     
-     const hasCorrelationKeyword = correlationKeywords.some(keyword => query.includes(keyword));
-     
-     // Check for trends-correlation queries (trends data combined with demographics)
-     const isTrendsCorrelationQuery = hasTrendsKeyword && 
---
+       'connection'
+     ];
+     
+     const hasCorrelationKeyword = correlationKeywords.some(keyword: any => query.includes(keyword));
+     
+     // Check for trends-correlation queries (trends data combined with demographics)
+     const isTrendsCorrelationQuery = hasTrendsKeyword && 
+                                      layerResults.length >= 2 && 
+                                      (hasCorrelationKeyword || query.includes('vs') || query.includes('versus') || query.includes('compare'));
+     
@@ lines 1282-1294 @@
-       'difference between'
-     ];
-     
-     const hasDifferenceKeyword = differenceKeywords.some(keyword => 
-       new RegExp(keyword, 'i').test(query)
-     );
-     
-     // Check for brand mentions in competitive context
-     const brandMentions = ['nike', 'adidas', 'jordan', 'puma', 'reebok', 'converse'];
-     const mentionedBrands = brandMentions.filter(brand => query.includes(brand));
-     
-     if (hasDifferenceKeyword && mentionedBrands.length >= 2) {
-       //  console.log('Detected difference/competitive analysis query');
---
+       'difference between'
+     ];
+     
+     const hasDifferenceKeyword = differenceKeywords.some(keyword: any => 
+       new RegExp(keyword, 'i').test(query)
+     );
+     
+     // Check for brand mentions in competitive context
+     const brandMentions = ['nike', 'adidas', 'jordan', 'puma', 'reebok', 'converse'];
+     const mentionedBrands = brandMentions.filter(brand: any => query.includes(brand));
+     
+     if (hasDifferenceKeyword && mentionedBrands.length >= 2) {
+       //  console.log('Detected difference/competitive analysis query');
+       return 'difference';
+     }
+ 
@@ lines 1297-1303 @@
- 
-     // Check for multiple numeric fields being referenced BEFORE general correlation keyword check
-     // This ensures that 3+ variable queries use multivariate analysis even if they contain correlation keywords
-     const numericFieldCount = layerResults.filter(lr => 
-       lr.layer.rendererField && 
-       lr.features[0]?.attributes?.[lr.layer.rendererField] !== undefined
-     ).length;
---
+ 
+     // Check for multiple numeric fields being referenced BEFORE general correlation keyword check
+     // This ensures that 3+ variable queries use multivariate analysis even if they contain correlation keywords
+     const numericFieldCount = layerResults.filter(lr: any => 
+       lr.layer.rendererField && 
+       lr.features[0]?.attributes?.[lr.layer.rendererField] !== undefined
+     ).length;
+ 
+     // For 3+ layers, use multivariate analysis instead of correlation
+     // Correlation is only meaningful for exactly 2 variables
@@ lines 1361-1367 @@
-           layerName: layerName,
-           rendererField: rendererField,
-           layerConfig: {
-             fields: (layerConfig.fields || []).map(field => ({
-               ...field,
-               type: field.type as FieldType
-             }))
---
+           layerName: layerName,
+           rendererField: rendererField,
+           layerConfig: {
+             fields: (layerConfig.fields || []).map(field: any => ({
+               ...field,
+               type: field.type as FieldType
+             }))
+           }
+         },
+         options
@@ lines 1494-1500 @@
-         const features = layerResults[0]?.features || [];
-         if (features.length > 0) {
-           const sampleProperties = features[0].properties || {};
-           const numericFields = Object.keys(sampleProperties).filter(key => {
-             const value = sampleProperties[key];
-             return typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)));
-           });
---
+         const features = layerResults[0]?.features || [];
+         if (features.length > 0) {
+           const sampleProperties = features[0].properties || {};
+           const numericFields = Object.keys(sampleProperties).filter(key: any => {
+             const value = sampleProperties[key];
+             return typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)));
+           });
+           
+           //console.log('[VisualizationFactory] Available numeric fields:', numericFields);
+           
@@ lines 1502-1508 @@
-           //console.log('[VisualizationFactory] Available numeric fields:', numericFields);
-           
-           if (!primaryField) {
-             primaryField = numericFields.find(field => 
-               field.includes('MP30034A_B') || // Nike (default)
-               field.includes('MEDDI_CY') ||   // Income
-               field.includes('TOTPOP_CY')     // Population
---
+           //console.log('[VisualizationFactory] Available numeric fields:', numericFields);
+           
+           if (!primaryField) {
+             primaryField = numericFields.find(field: any => 
+               field.includes('MP30034A_B') || // Nike (default)
+               field.includes('MEDDI_CY') ||   // Income
+               field.includes('TOTPOP_CY')     // Population
+             ) || numericFields[0] || 'thematic_value';
+           }
+           
@@ lines 1510-1516 @@
-           }
-           
-           if (!comparisonField) {
-             comparisonField = numericFields.find(field => 
-               field !== primaryField && (
-                 field.includes('MEDDI_CY') ||   // Income
-                 field.includes('TOTPOP_CY') ||  // Population
---
+           }
+           
+           if (!comparisonField) {
+             comparisonField = numericFields.find(field: any => 
+               field !== primaryField && (
+                 field.includes('MEDDI_CY') ||   // Income
+                 field.includes('TOTPOP_CY') ||  // Population
+                 field.includes('DIVINDX_CY') || // Diversity
+                 field.includes('MP30') ||       // Any brand field
+                 field.includes('GENZ_CY') ||    // Gen Z
@@ lines 1519-1525 @@
-                 field.includes('GENZ_CY') ||    // Gen Z
-                 field.includes('MILLENN_CY')    // Millennial
-               )
-             ) || numericFields.find(field => field !== primaryField) || primaryField;
-           }
-         }
-       }
---
+                 field.includes('GENZ_CY') ||    // Gen Z
+                 field.includes('MILLENN_CY')    // Millennial
+               )
+             ) || numericFields.find(field: any => field !== primaryField) || primaryField;
+           }
+         }
+       }
+       
+       // Fallback to default fields if still not found
+       primaryField = primaryField || 'MP30034A_B';
@@ lines 1637-1648 @@
- 
-       // Find fields to use for correlation with safe property access
-       const primaryField = primaryLayerConfig?.rendererField || 
-                            Object.keys(primaryLayer.features[0]?.attributes || {}).find(key => 
-                              typeof primaryLayer.features[0]?.attributes[key] === 'number'
-                            ) || 'value';
- 
-       const comparisonField = comparisonLayerConfig?.rendererField || 
-                               Object.keys(comparisonLayer.features[0]?.attributes || {}).find(key => 
-                                 typeof comparisonLayer.features[0]?.attributes[key] === 'number'
-                               ) || 'value';
- 
---
+ 
+       // Find fields to use for correlation with safe property access
+       const primaryField = primaryLayerConfig?.rendererField || 
+                            Object.keys(primaryLayer.features[0]?.attributes || {}).find(key: any => 
+                              typeof primaryLayer.features[0]?.attributes[key] === 'number'
+                            ) || 'value';
+ 
+       const comparisonField = comparisonLayerConfig?.rendererField || 
+                               Object.keys(comparisonLayer.features[0]?.attributes || {}).find(key: any => 
+                                 typeof comparisonLayer.features[0]?.attributes[key] === 'number'
+                               ) || 'value';
+ 
+       /*console.log('Creating trends correlation with:', {
+         primaryLayer: primaryLayerConfig?.name || 'Primary Layer',
+         primaryType,
@@ lines 1707-1713 @@
-       const multivariateViz = new MultivariateVisualization();
- 
-       // Combine features from all layers
-       const combinedFeatures = layerResults.flatMap(result => result.features || []);
-       
-       // Extract field names from layer results if not in enhanced analysis
-       let correlationFields: string[] = [];
---
+       const multivariateViz = new MultivariateVisualization();
+ 
+       // Combine features from all layers
+       const combinedFeatures = layerResults.flatMap(result: any => result.features || []);
+       
+       // Extract field names from layer results if not in enhanced analysis
+       let correlationFields: string[] = [];
+       
+       if (relevantFields.length >= 3) {
+         correlationFields = relevantFields.slice(0, 3);
@@ lines 1717-1724 @@
-       } else {
-         // Extract from layer renderer fields
-         const layerFields = layerResults.slice(0, 3)
-           .map(lr => lr.layer.rendererField)
-           .filter((field): field is string => Boolean(field));
-         if (layerFields.length >= 3) {
-           correlationFields = layerFields;
-         } else {
---
+       } else {
+         // Extract from layer renderer fields
+         const layerFields = layerResults.slice(0, 3)
+           .map(lr: any => lr.layer.rendererField)
+           .filter((field: any): field is string => Boolean(field));
+         if (layerFields.length >= 3) {
+           correlationFields = layerFields;
+         } else {
+           // Extract from actual feature data
+           const sampleFeature = combinedFeatures[0];
+           if (sampleFeature) {
@@ lines 1726-1732 @@
-           const sampleFeature = combinedFeatures[0];
-           if (sampleFeature) {
-             const allProps = { ...(sampleFeature.properties || {}), ...(sampleFeature.attributes || {}) };
-             const numericFields = Object.keys(allProps).filter(key => {
-               const value = allProps[key];
-               return typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)));
-             });
---
+           const sampleFeature = combinedFeatures[0];
+           if (sampleFeature) {
+             const allProps = { ...(sampleFeature.properties || {}), ...(sampleFeature.attributes || {}) };
+             const numericFields = Object.keys(allProps).filter(key: any => {
+               const value = allProps[key];
+               return typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)));
+             });
+             correlationFields = numericFields.slice(0, 3);
+           }
+         }
@@ lines 1763-1769 @@
-         };
- 
-         // Ensure correlationFields exist in attributes
-         const hasAllFields = correlationFields.every(field => 
-           attributes[field] !== undefined && attributes[field] !== null
-         );
- 
---
+         };
+ 
+         // Ensure correlationFields exist in attributes
+         const hasAllFields = correlationFields.every(field: any => 
+           attributes[field] !== undefined && attributes[field] !== null
+         );
+ 
+         if (!hasAllFields) {
+           /*console.warn('[MultivariateViz] Skipping feature missing required fields:', { 
+             index, 
@@ lines 1781-1787 @@
-           geometry: feature.geometry,
-           attributes
-         });
-       }).filter(g => g !== null) as __esri.Graphic[];
- 
-       /*console.log('[MultivariateViz] Processed graphics:', {
-         totalInput: combinedFeatures.length,
---
+           geometry: feature.geometry,
+           attributes
+         });
+       }).filter(g: any => g !== null) as __esri.Graphic[];
+ 
+       /*console.log('[MultivariateViz] Processed graphics:', {
+         totalInput: combinedFeatures.length,
+         validGraphics: graphics.length,
+         sampleFields: graphics[0]?.attributes ? Object.keys(graphics[0].attributes) : 'No graphics'
+       });*/
@@ lines 1890-1896 @@
-       
-       // Get features and ensure they have valid geometries
-       const features = layerResults[0]?.features || [];
-       const validFeatures = features.filter(feature => {
-         // Check if feature has geometry
-         if (!feature.geometry) {
-           /*console.warn('Feature missing geometry:', {
---
+       
+       // Get features and ensure they have valid geometries
+       const features = layerResults[0]?.features || [];
+       const validFeatures = features.filter(feature: any => {
+         // Check if feature has geometry
+         if (!feature.geometry) {
+           /*console.warn('Feature missing geometry:', {
+             featureId: feature.properties?.FSA_ID || feature.properties?.ID
+           });*/
+           return false;
@@ lines 1983-1991 @@
- 
-       // Sort features by ranking field and convert to ArcGIS Graphics
-       const topFeatures = validFeatures
-         .sort((a, b) => (b.properties[rankingField] || 0) - (a.properties[rankingField] || 0))
-         .slice(0, options.limit)
-         .map(feature => {
-           // Ensure proper geometry structure for ArcGIS
-           const geometry = feature.geometry.type.toUpperCase() === 'POLYGON' 
-             ? {
---
+ 
+       // Sort features by ranking field and convert to ArcGIS Graphics
+       const topFeatures = validFeatures
+         .sort((a: any, b: any) => (b.properties[rankingField] || 0) - (a.properties[rankingField] || 0))
+         .slice(0, options.limit)
+         .map(feature: any => {
+           // Ensure proper geometry structure for ArcGIS
+           const geometry = feature.geometry.type.toUpperCase() === 'POLYGON' 
+             ? {
+                 type: 'polygon',
+                 rings: feature.geometry.rings || feature.geometry.coordinates,
+                 spatialReference: feature.geometry.spatialReference || { wkid: 4326 }
@@ lines 2066-2072 @@
- 
-       // Convert features to Graphics format expected by FactorImportanceVisualization
-       const graphicsForViz = primaryLayer.features
-         .map((feature, index) => {
-           if (!feature || !feature.geometry) return null;
- 
-           // Create ArcGIS-compatible geometry
---
+ 
+       // Convert features to Graphics format expected by FactorImportanceVisualization
+       const graphicsForViz = primaryLayer.features
+         .map((feature: any, index: any) => {
+           if (!feature || !feature.geometry) return null;
+ 
+           // Create ArcGIS-compatible geometry
+           const geometry = feature.geometry.type?.toUpperCase() === 'POLYGON' 
+             ? {
+                 type: 'polygon',
@@ lines 2088-2094 @@
-             }
-           };
-         })
-         .filter((g): g is any => g !== null);
- 
-       // Extract factor importance from enhanced analysis or generate placeholder data
-       const { enhancedAnalysis } = this.visualizationIntegration;
---
+             }
+           };
+         })
+         .filter((g: any): g is any => g !== null);
+ 
+       // Extract factor importance from enhanced analysis or generate placeholder data
+       const { enhancedAnalysis } = this.visualizationIntegration;
+       const factorData = {
+         factors: this.extractFactorImportance(layerResults, enhancedAnalysis, primaryField),
+         features: graphicsForViz,
@@ lines 2180-2194 @@
-     
-     if (firstFeature?.properties) {
-       // Look for numeric fields that could be target variables
-       const numericFields = Object.keys(firstFeature.properties).filter(key => {
-         const value = firstFeature.properties[key];
-         return typeof value === 'number' || !isNaN(parseFloat(value));
-       });
-       
-       // Prefer fields that might be target variables
-       const targetKeywords = ['rate', 'score', 'index', 'value', 'count', 'total'];
-       const targetField = numericFields.find(field => 
-         targetKeywords.some(keyword => field.toLowerCase().includes(keyword))
-       );
-       
-       return targetField || numericFields[0] || 'thematic_value';
---
+     
+     if (firstFeature?.properties) {
+       // Look for numeric fields that could be target variables
+       const numericFields = Object.keys(firstFeature.properties).filter(key: any => {
+         const value = firstFeature.properties[key];
+         return typeof value === 'number' || !isNaN(parseFloat(value));
+       });
+       
+       // Prefer fields that might be target variables
+       const targetKeywords = ['rate', 'score', 'index', 'value', 'count', 'total'];
+       const targetField = numericFields.find(field: any => 
+         targetKeywords.some(keyword: any => field.toLowerCase().includes(keyword))
+       );
+       
+       return targetField || numericFields[0] || 'thematic_value';
+     }
+     
+     return 'thematic_value';
@@ lines 2241-2247 @@
-     'against'
-   ];
-   
-   return correlationKeywords.some(keyword => 
-     query.toLowerCase().includes(keyword)
-   );
- };
---
+     'against'
+   ];
+   
+   return correlationKeywords.some(keyword: any => 
+     query.toLowerCase().includes(keyword)
+   );
+ };
+ 
+ export const is3DVisualizationQuery = (query: string): boolean => {
+   const threeDKeywords = [
@@ lines 2257-2263 @@
-     'skyline'
-   ];
-   
-   return threeDKeywords.some(keyword => 
-     query.toLowerCase().includes(keyword)
-   );
- };
---
+     'skyline'
+   ];
+   
+   return threeDKeywords.some(keyword: any => 
+     query.toLowerCase().includes(keyword)
+   );
+ };
+ 
+ export const isSimpleDisplayQuery = (query: string): boolean => {
+   const displayKeywords = [
@@ lines 2271-2277 @@
-     '^where'
-   ];
-   
-   return displayKeywords.some(keyword => 
-     new RegExp(keyword, 'i').test(query)
-   );
- };
---
+     '^where'
+   ];
+   
+   return displayKeywords.some(keyword: any => 
+     new RegExp(keyword, 'i').test(query)
+   );
+ };
+ 
+ // Update the isTopNQuery function to handle more cases
+ export const isTopNQuery = (query: string): boolean => {
@@ lines 2301-2307 @@
-     /^areas?\s+(?:with|having)\s+(?:the\s+)?most\s+applications?/i
-   ];
-   
-   const isTopN = topNPatterns.some(pattern => pattern.test(query));
-   //  console.log('TopN query detection:', { query, isTopN });
-   return isTopN;
- };
---
+     /^areas?\s+(?:with|having)\s+(?:the\s+)?most\s+applications?/i
+   ];
+   
+   const isTopN = topNPatterns.some(pattern: any => pattern.test(query));
+   //  console.log('TopN query detection:', { query, isTopN });
+   return isTopN;
+ };
+ 
+ // Helper function to determine type from results
+ 
@@ lines 2314-2320 @@
-   primaryField: string,
-   comparisonField: string
- ): CorrelationData {
-   const processedFeatures = features.map((feature, index) => ({
-     attributes: {
-       OBJECTID: index + 1,
-       primary_value: feature.attributes?.[primaryField] || 0,
---
+   primaryField: string,
+   comparisonField: string
+ ): CorrelationData {
+   const processedFeatures = features.map((feature: any, index: any) => ({
+     attributes: {
+       OBJECTID: index + 1,
+       primary_value: feature.attributes?.[primaryField] || 0,
+       comparison_value: feature.attributes?.[comparisonField] || 0,
+       correlation_strength: 0
+     },


*** FILE: components/popup/CustomPopupManager.tsx
@@ lines 84-90 @@
-         // For point layers, only show address field in content
-         // First try exact field names for known layers like H&R Block
-         const addressFields: string[] = [];
-         const availableFieldNames = featureLayer.fields?.map(f => f.name) || [];
-         
-         console.log('[CustomPopupManager] 🔍 Available fields for point layer:', availableFieldNames);
-         
---
+         // For point layers, only show address field in content
+         // First try exact field names for known layers like H&R Block
+         const addressFields: string[] = [];
+         const availableFieldNames = featureLayer.fields?.map(f: any => f.name) || [];
+         
+         console.log('[CustomPopupManager] 🔍 Available fields for point layer:', availableFieldNames);
+         
+         // Check for exact 'address' field first (like in H&R Block)
+         if (availableFieldNames.includes('address')) {
+           addressFields.push('address');
@@ lines 94-100 @@
-         } else {
-           // Fall back to pattern matching if exact field not found
-           const matchedFields = featureLayer.fields
-             ?.filter(field => {
-               const fieldName = field.name.toLowerCase();
-               const fieldAlias = (field.alias || '').toLowerCase();
-               
---
+         } else {
+           // Fall back to pattern matching if exact field not found
+           const matchedFields = featureLayer.fields
+             ?.filter(field: any => {
+               const fieldName = field.name.toLowerCase();
+               const fieldAlias = (field.alias || '').toLowerCase();
+               
+               // Include address-related fields
+               return (fieldName.includes('address') || fieldAlias.includes('address') ||
+                      fieldName.includes('addr') || fieldAlias.includes('addr')) &&
@@ lines 103-109 @@
-                      fieldName.includes('addr') || fieldAlias.includes('addr')) &&
-                      !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name);
-             })
-             .map(field => field.name) || [];
-           
-           addressFields.push(...matchedFields);
-           
---
+                      fieldName.includes('addr') || fieldAlias.includes('addr')) &&
+                      !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name);
+             })
+             .map(field: any => field.name) || [];
+           
+           addressFields.push(...matchedFields);
+           
+           // If no address fields found, try common address field names
+           if (addressFields.length === 0) {
+             const commonAddressFields = ['ADDRESS', 'ADDR', 'STREET_ADDRESS', 'FULL_ADDRESS'];
@@ lines 111-117 @@
-           if (addressFields.length === 0) {
-             const commonAddressFields = ['ADDRESS', 'ADDR', 'STREET_ADDRESS', 'FULL_ADDRESS'];
-             for (const fieldName of commonAddressFields) {
-               if (featureLayer.fields?.find(f => f.name === fieldName)) {
-                 addressFields.push(fieldName);
-                 break; // Only take the first match
-               }
---
+           if (addressFields.length === 0) {
+             const commonAddressFields = ['ADDRESS', 'ADDR', 'STREET_ADDRESS', 'FULL_ADDRESS'];
+             for (const fieldName of commonAddressFields) {
+               if (featureLayer.fields?.find(f: any => f.name === fieldName)) {
+                 addressFields.push(fieldName);
+                 break; // Only take the first match
+               }
+             }
+           }
+         }
@@ lines 131-137 @@
-         
-         console.log('[CustomPopupManager] ✅ Applied simplified popup for point layer', {
-           addressFields,
-           availableFields: featureLayer.fields?.map(f => f.name)
-         });
-       } else {
-         // Regular behavior for polygon/other layers
---
+         
+         console.log('[CustomPopupManager] ✅ Applied simplified popup for point layer', {
+           addressFields,
+           availableFields: featureLayer.fields?.map(f: any => f.name)
+         });
+       } else {
+         // Regular behavior for polygon/other layers
+         console.log('[CustomPopupManager] Configuring standard popup with value bars');
+         
+         // Get numeric fields for bar chart display - prioritize analysis score fields
@@ lines 139-145 @@
-         
-         // Get numeric fields for bar chart display - prioritize analysis score fields
-         const allNumericFields = featureLayer.fields
-           ?.filter(field => 
-             ['double', 'single', 'integer', 'small-integer'].includes(field.type) &&
-             !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name)
-           ) || [];
---
+         
+         // Get numeric fields for bar chart display - prioritize analysis score fields
+         const allNumericFields = featureLayer.fields
+           ?.filter(field: any => 
+             ['double', 'single', 'integer', 'small-integer'].includes(field.type) &&
+             !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name)
+           ) || [];
+ 
+         // For analysis layers, prioritize primary score fields and avoid showing multiple scores
+         const isAnalysisLayer = featureLayer.title?.includes('AnalysisEngine') || 
@@ lines 153-160 @@
-         if (isAnalysisLayer) {
-           // For analysis layers, only show the primary score field to avoid confusion
-           const scoreFields = ['strategic_analysis_score', 'strategic_score', 'strategic_value_score', 'target_value', 'value', 'score'];
-           const primaryScoreField = scoreFields.find(field => 
-             allNumericFields.some(f => f.name === field)
-           );
-           
-           if (primaryScoreField) {
---
+         if (isAnalysisLayer) {
+           // For analysis layers, only show the primary score field to avoid confusion
+           const scoreFields = ['strategic_analysis_score', 'strategic_score', 'strategic_value_score', 'target_value', 'value', 'score'];
+           const primaryScoreField = scoreFields.find(field: any => 
+             allNumericFields.some(f: any => f.name === field)
+           );
+           
+           if (primaryScoreField) {
+             barChartFields = [primaryScoreField];
+             console.log('[CustomPopupManager] 🎯 Analysis layer: showing only primary score field:', primaryScoreField);
+           } else {
@@ lines 162-181 @@
-             console.log('[CustomPopupManager] 🎯 Analysis layer: showing only primary score field:', primaryScoreField);
-           } else {
-             // Fallback: show first numeric field only
-             barChartFields = allNumericFields.slice(0, 1).map(f => f.name);
-           }
-         } else {
-           // For non-analysis layers, show multiple fields as before
-           barChartFields = allNumericFields.map(field => field.name).slice(0, 5);
-         }
- 
-         // Get all other fields for list display
-         const listFields = featureLayer.fields
-           ?.filter(field => 
-             !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name) &&
-             !barChartFields.includes(field.name)
-           )
-           .map(field => field.name)
-           .slice(0, 8) || []; // Limit to 8 additional fields
- 
-         const config: StandardizedPopupConfig = {
---
+             console.log('[CustomPopupManager] 🎯 Analysis layer: showing only primary score field:', primaryScoreField);
+           } else {
+             // Fallback: show first numeric field only
+             barChartFields = allNumericFields.slice(0, 1).map(f: any => f.name);
+           }
+         } else {
+           // For non-analysis layers, show multiple fields as before
+           barChartFields = allNumericFields.map(field: any => field.name).slice(0, 5);
+         }
+ 
+         // Get all other fields for list display
+         const listFields = featureLayer.fields
+           ?.filter(field: any => 
+             !['OBJECTID', 'FID', 'Shape__Area', 'Shape__Length'].includes(field.name) &&
+             !barChartFields.includes(field.name)
+           )
+           .map(field: any => field.name)
+           .slice(0, 8) || []; // Limit to 8 additional fields
+ 
+         const config: StandardizedPopupConfig = {
+           titleFields: ['DESCRIPTION', 'ID', 'FSA_ID', 'NAME', 'OBJECTID'],
+           barChartFields,
+           listFields,
@@ lines 233-239 @@
-         // Set up popup event handlers using reactiveUtils.watch
-         const popupWatchHandle = reactiveUtils.watch(
-           () => mapView.popup?.visible,
-           (newValue) => {
-           if (newValue && mapView.popup?.selectedFeature) {
-             onPopupOpen?.(mapView.popup.selectedFeature);
-           } else {
---
+         // Set up popup event handlers using reactiveUtils.watch
+         const popupWatchHandle = reactiveUtils.watch(
+           () => mapView.popup?.visible,
+           (newValue: any) => {
+           if (newValue && mapView.popup?.selectedFeature) {
+             onPopupOpen?.(mapView.popup.selectedFeature);
+           } else {
+             onPopupClose?.();
+           }
+           }
@@ lines 258-275 @@
-       visibilityHandleRef.current = visibilityHandle;
- 
-       // Setup popup observer
-       const popupRemoverObserver = new MutationObserver((mutations) => {
-         mutations.forEach((mutation) => {
-           if (mutation.type !== 'childList' || !mutation.addedNodes.length) {
-             return;
-           }
- 
-           mutation.addedNodes.forEach((node) => {
-             if (!(node instanceof HTMLElement)) {
-               return;
-             }
- 
-             const isPopupElement = popupClassNames.some(className => 
-               node.className && node.className.includes(className)
-             );
- 
---
+       visibilityHandleRef.current = visibilityHandle;
+ 
+       // Setup popup observer
+       const popupRemoverObserver = new MutationObserver((mutations: any) => {
+         mutations.forEach((mutation: any) => {
+           if (mutation.type !== 'childList' || !mutation.addedNodes.length) {
+             return;
+           }
+ 
+           mutation.addedNodes.forEach((node: any) => {
+             if (!(node instanceof HTMLElement)) {
+               return;
+             }
+ 
+             const isPopupElement = popupClassNames.some(className: any => 
+               node.className && node.className.includes(className)
+             );
+ 
+             if (isPopupElement && !hasProtectedParentClass(node)) {
+               if (featureLayerRef.current && viewRef.current) {
+                 const popup = viewRef.current.popup;
@@ lines 339-345 @@
-   // 4. Disable native popups on all feature layers
-   useEffect(() => {
-     if (mapView.map) {
-       mapView.map.allLayers.forEach(layer => {
-         if (layer.type === 'feature') {
-           (layer as __esri.FeatureLayer).popupEnabled = false;
-         }
---
+   // 4. Disable native popups on all feature layers
+   useEffect(() => {
+     if (mapView.map) {
+       mapView.map.allLayers.forEach(layer: any => {
+         if (layer.type === 'feature') {
+           (layer as __esri.FeatureLayer).popupEnabled = false;
+         }
+       });
+     }
+   }, [mapView]);
@@ lines 412-418 @@
-   const clickHandler = mapView.on('click', (event: __esri.ViewClickEvent) => {
-     // Remove any existing popups first
-     const existingPopups = document.querySelectorAll('.custom-popup');
-     existingPopups.forEach(el => {
-       // Check if the element is still in the DOM before trying to remove it
-       if (el.parentNode) {
-         el.parentNode.removeChild(el);
---
+   const clickHandler = mapView.on('click', (event: __esri.ViewClickEvent) => {
+     // Remove any existing popups first
+     const existingPopups = document.querySelectorAll('.custom-popup');
+     existingPopups.forEach(el: any => {
+       // Check if the element is still in the DOM before trying to remove it
+       if (el.parentNode) {
+         el.parentNode.removeChild(el);
+       }
+     });
+ 
@@ lines 616-622 @@
-       
-       // If there's a custom zoom action defined in config, also call that
-       if (config?.actions) {
-         const zoomAction = config.actions.find(a => a.label === 'Zoom to');
-         if (zoomAction) {
-           zoomAction.onClick(feature);
-         }
---
+       
+       // If there's a custom zoom action defined in config, also call that
+       if (config?.actions) {
+         const zoomAction = config.actions.find(a: any => a.label === 'Zoom to');
+         if (zoomAction) {
+           zoomAction.onClick(feature);
+         }
+       }
+     };
+     
@@ lines 689-695 @@
-         
-         // 3. Call original configured action if exists
-         if (config?.actions) {
-           const infoAction = config.actions.find(a => a.label === 'Infographics');
-           if (infoAction) {
-             infoAction.onClick(feature); 
-           }
---
+         
+         // 3. Call original configured action if exists
+         if (config?.actions) {
+           const infoAction = config.actions.find(a: any => a.label === 'Infographics');
+           if (infoAction) {
+             infoAction.onClick(feature); 
+           }
+         }
+       };
+     } else {
@@ lines 734-740 @@
-       
-       // Show any additional relevant fields for points
-       const relevantFields = ['locality', 'region', 'postcode'];
-       relevantFields.forEach(fieldName => {
-         if (attrs[fieldName]) {
-           const fieldDiv = document.createElement('div');
-           fieldDiv.style.fontSize = '12px';
---
+       
+       // Show any additional relevant fields for points
+       const relevantFields = ['locality', 'region', 'postcode'];
+       relevantFields.forEach(fieldName: any => {
+         if (attrs[fieldName]) {
+           const fieldDiv = document.createElement('div');
+           fieldDiv.style.fontSize = '12px';
+           fieldDiv.style.color = 'var(--theme-text-secondary)';
+           fieldDiv.style.marginBottom = '4px';
+           fieldDiv.innerHTML = `<strong>${fieldName}:</strong> ${attrs[fieldName]}`;
@@ lines 769-779 @@
-       shapContainer.appendChild(shapHeader);
- 
-       const topItems = [...shapImportanceData]
-         .sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance))
-         .slice(0, 5);
-       const maxVal = Math.max(...topItems.map(i => Math.abs(i.importance)));
- 
-       topItems.forEach(item => {
-         const row = document.createElement('div');
-         row.style.display = 'flex';
-         row.style.alignItems = 'center';
---
+       shapContainer.appendChild(shapHeader);
+ 
+       const topItems = [...shapImportanceData]
+         .sort((a: any, b: any) => Math.abs(b.importance) - Math.abs(a.importance))
+         .slice(0, 5);
+       const maxVal = Math.max(...topItems.map(i: any => Math.abs(i.importance)));
+ 
+       topItems.forEach(item: any => {
+         const row = document.createElement('div');
+         row.style.display = 'flex';
+         row.style.alignItems = 'center';
+         row.style.gap = '6px';
+         row.style.marginBottom = '4px';
+ 
@@ lines 904-910 @@
- const applyCustomPopupTemplates = (view: __esri.MapView, config?: PopupConfig) => {
-   if (!view || !view.map) return;
-   
-   view.map.allLayers.forEach(layer => {
-     if (layer.type === 'feature') {
-       const featureLayer = layer as __esri.FeatureLayer;
-     //  console.log(`[CustomPopupManager] Configuring custom popup for layer: ${featureLayer.title}`);
---
+ const applyCustomPopupTemplates = (view: __esri.MapView, config?: PopupConfig) => {
+   if (!view || !view.map) return;
+   
+   view.map.allLayers.forEach(layer: any => {
+     if (layer.type === 'feature') {
+       const featureLayer = layer as __esri.FeatureLayer;
+     //  console.log(`[CustomPopupManager] Configuring custom popup for layer: ${featureLayer.title}`);
+       
+       // Use the provided config title or generate a default one
+       const title = config?.title ? 
@@ lines 968-974 @@
-               // Add event listeners to buttons
-               zoomButton.addEventListener("click", () => {
-                 if (config?.actions && config.actions.length > 0 && graphic) {
-                   const zoomAction = config.actions.find(a => a.label === 'Zoom to');
-                   if (zoomAction) {
-                     zoomAction.onClick(graphic);
-                   }
---
+               // Add event listeners to buttons
+               zoomButton.addEventListener("click", () => {
+                 if (config?.actions && config.actions.length > 0 && graphic) {
+                   const zoomAction = config.actions.find(a: any => a.label === 'Zoom to');
+                   if (zoomAction) {
+                     zoomAction.onClick(graphic);
+                   }
+                 }
+               });
+               
@@ lines 977-983 @@
-               
-               infoButton.addEventListener("click", () => {
-                 if (config?.actions && config.actions.length > 1 && graphic) {
-                   const infoAction = config.actions.find(a => a.label === 'Infographics');
-                   if (infoAction) {
-                     infoAction.onClick(graphic);
-                   }
---
+               
+               infoButton.addEventListener("click", () => {
+                 if (config?.actions && config.actions.length > 1 && graphic) {
+                   const infoAction = config.actions.find(a: any => a.label === 'Infographics');
+                   if (infoAction) {
+                     infoAction.onClick(graphic);
+                   }
+                 }
+               });
+               
@@ lines 1055-1061 @@
-       attributeValues: attrs,
-   nonZeroValues: Object.entries(attrs).filter(([, value]) => typeof value === 'number' && value !== 0),
-   allNumericValues: Object.entries(attrs).filter(([, value]) => typeof value === 'number'),
-       brandFields: brandFields.map(bf => ({ field: bf.fieldName, brand: (bf as any).brandName, value: bf.value })),
-       isBrandAnalysis: isBrandAnalysis
-     });
-     
---
+       attributeValues: attrs,
+   nonZeroValues: Object.entries(attrs).filter(([, value]) => typeof value === 'number' && value !== 0),
+   allNumericValues: Object.entries(attrs).filter(([, value]) => typeof value === 'number'),
+       brandFields: brandFields.map(bf: any => ({ field: bf.fieldName, brand: (bf as any).brandName, value: bf.value })),
+       isBrandAnalysis: isBrandAnalysis
+     });
+     
+   const metrics: Metric[] = [];
+     
+   // Prefer the renderer's active field when available
@@ lines 1122-1135 @@
-           allFeatures = (sourceUnknown as { items?: Array<{ attributes?: Record<string, unknown> }> }).items ?? [];
-         }
-         const allValues = allFeatures
-           .map((f) => {
-             const v = f.attributes?.[(mainScoreField as string)];
-             return typeof v === 'number' ? v : NaN;
-           })
-           .filter((v) => typeof v === 'number');
-         const maxValue = Math.max(...allValues);
-         const minValue = Math.min(...allValues);
-         const sortedValues = [...allValues].sort((a, b) => a - b);
-         const medianValue = sortedValues.length > 0 ? sortedValues[Math.floor(sortedValues.length / 2)] : 0;
-         
-         metrics.push({
---
+           allFeatures = (sourceUnknown as { items?: Array<{ attributes?: Record<string, unknown> }> }).items ?? [];
+         }
+         const allValues = allFeatures
+           .map((f: any) => {
+             const v = f.attributes?.[(mainScoreField as string)];
+             return typeof v === 'number' ? v : NaN;
+           })
+           .filter((v: any) => typeof v === 'number');
+         const maxValue = Math.max(...allValues);
+         const minValue = Math.min(...allValues);
+         const sortedValues = [...allValues].sort((a: any, b: any) => a - b);
+         const medianValue = sortedValues.length > 0 ? sortedValues[Math.floor(sortedValues.length / 2)] : 0;
+         
+         metrics.push({
+           label: FieldMappingHelper.getFriendlyFieldName(mainScoreField),
+           value: mainScoreValue,
+           color: 'var(--theme-accent-primary)',
@@ lines 1166-1172 @@
-     
-     // Add brand fields first if this is a brand analysis
-     if (isBrandAnalysis && brandFields.length > 0) {
-       brandFields.forEach(brandField => {
-         if (brandField.fieldName !== mainScoreField && brandField.value !== 0) {
-           metrics.push({
-             label: FieldMappingHelper.getFriendlyFieldName(brandField.fieldName) || `${(brandField as any).brandName} Market Share`,
---
+     
+     // Add brand fields first if this is a brand analysis
+     if (isBrandAnalysis && brandFields.length > 0) {
+       brandFields.forEach(brandField: any => {
+         if (brandField.fieldName !== mainScoreField && brandField.value !== 0) {
+           metrics.push({
+             label: FieldMappingHelper.getFriendlyFieldName(brandField.fieldName) || `${(brandField as any).brandName} Market Share`,
+             value: brandField.value,
+             color: 'var(--firefly-8)', // Blue for brand metrics
+             isPercent: true
@@ lines 1179-1186 @@
-     }
-     
-     // Get all available numeric fields that could be contributing factors
-     const brandFieldNames = brandFields.map(bf => bf.fieldName);
-     Object.keys(attrs).forEach(key => {
-       if (key !== mainScoreField && 
-           !excludedFields.includes(key) && 
-           !excludedProjectFields.includes(key) && 
---
+     }
+     
+     // Get all available numeric fields that could be contributing factors
+     const brandFieldNames = brandFields.map(bf: any => bf.fieldName);
+     Object.keys(attrs).forEach(key: any => {
+       if (key !== mainScoreField && 
+           !excludedFields.includes(key) && 
+           !excludedProjectFields.includes(key) && 
+           !brandFieldNames.includes(key) && // Skip brand fields as we handled them above
+           typeof attrs[key] === 'number' && 
+           attrs[key] !== 0) { // Show fields with non-zero values (including negative for brand differences)
@@ lines 1216-1222 @@
-       chartTitle.style.color = 'var(--theme-text-primary)';
-       container.appendChild(chartTitle);
-       
-       metrics.forEach(metric => {
-         const row = document.createElement('div');
-         row.style.display = 'flex';
-         row.style.alignItems = 'center';
---
+       chartTitle.style.color = 'var(--theme-text-primary)';
+       container.appendChild(chartTitle);
+       
+       metrics.forEach(metric: any => {
+         const row = document.createElement('div');
+         row.style.display = 'flex';
+         row.style.alignItems = 'center';
+         row.style.marginBottom = '8px';
+         row.style.padding = '4px 0';
+         
@@ lines 1279-1285 @@
-       });
-       
-       // Add statistics summary if we have main score statistics
-       const mainMetric = metrics.find(m => m.statistics);
-       if (mainMetric && mainMetric.statistics) {
-         const statsContainer = document.createElement('div');
-         statsContainer.style.marginTop = '12px';
---
+       });
+       
+       // Add statistics summary if we have main score statistics
+       const mainMetric = metrics.find(m: any => m.statistics);
+       if (mainMetric && mainMetric.statistics) {
+         const statsContainer = document.createElement('div');
+         statsContainer.style.marginTop = '12px';
+         statsContainer.style.padding = '8px';
+         statsContainer.style.backgroundColor = 'var(--theme-bg-secondary)';
+         statsContainer.style.borderRadius = '4px';
@@ lines 1351-1357 @@
-     }
- 
-     // Render each metric as a bar row
-     metrics.forEach(metric => {
-       const row = document.createElement('div');
-       row.style.display = 'flex';
-       row.style.alignItems = 'center';
---
+     }
+ 
+     // Render each metric as a bar row
+     metrics.forEach(metric: any => {
+       const row = document.createElement('div');
+       row.style.display = 'flex';
+       row.style.alignItems = 'center';
+       row.style.marginBottom = '8px';
+       row.style.padding = '6px 8px';
+       row.style.background = 'var(--theme-bg-secondary)';
@@ lines 1414-1420 @@
- 
-   // Get visible feature layers
-   const visibleLayers = view.map.allLayers
-     .filter(layer => layer.type === 'feature' && layer.visible && layer.listMode !== 'hide')
-     .toArray() as __esri.FeatureLayer[];
-   if (visibleLayers.length === 0) {
-     container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--theme-text-muted);">No visible layers to display</div>';
---
+ 
+   // Get visible feature layers
+   const visibleLayers = view.map.allLayers
+     .filter(layer: any => layer.type === 'feature' && layer.visible && layer.listMode !== 'hide')
+     .toArray() as __esri.FeatureLayer[];
+   if (visibleLayers.length === 0) {
+     container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--theme-text-muted);">No visible layers to display</div>';
+     return;
+   }
+ 
@@ lines 1430-1436 @@
-     try {
-       type LayerStat = { id: string; name: string; value: number; min: number; max: number; median: number; color: string };
-       const stats: LayerStat[] = await Promise.all(
-         visibleLayers.map(async (layer, idx) => {
-           // Get the application's layer configuration to access custom properties
-           const layerConfig = getLayerConfigById(layer.id);
- 
---
+     try {
+       type LayerStat = { id: string; name: string; value: number; min: number; max: number; median: number; color: string };
+       const stats: LayerStat[] = await Promise.all(
+         visibleLayers.map(async (layer: any, idx: any) => {
+           // Get the application's layer configuration to access custom properties
+           const layerConfig = getLayerConfigById(layer.id);
+ 
+           // Find a numeric field (exclude the object ID field)
+           const oidField = layer.objectIdField;
+           
@@ lines 1445-1459 @@
-           }
-           const configRendererField: string | undefined = layerConfig?.rendererField;
-           let numericFieldInfo = activeRendererField
-             ? layer.fields?.find(f => f.name === activeRendererField)
-             : undefined;
- 
-           if (!numericFieldInfo && configRendererField) {
-             numericFieldInfo = layer.fields?.find(f => f.name === configRendererField);
-           }
- 
-           if (!numericFieldInfo) {
-             numericFieldInfo = layer.fields?.find(f =>
-               ['small-integer','integer','single','double'].includes(f.type) &&
-               f.name !== oidField
-             );
---
+           }
+           const configRendererField: string | undefined = layerConfig?.rendererField;
+           let numericFieldInfo = activeRendererField
+             ? layer.fields?.find(f: any => f.name === activeRendererField)
+             : undefined;
+ 
+           if (!numericFieldInfo && configRendererField) {
+             numericFieldInfo = layer.fields?.find(f: any => f.name === configRendererField);
+           }
+ 
+           if (!numericFieldInfo) {
+             numericFieldInfo = layer.fields?.find(f: any =>
+               ['small-integer','integer','single','double'].includes(f.type) &&
+               f.name !== oidField
+             );
+           }
+           
+           if (!numericFieldInfo || !numericFieldInfo.name) {
@@ lines 1473-1481 @@
-           q.returnGeometry = false;
-           const result = await layer.queryFeatures(q);
-           const values = result.features
-             .map(f => f.attributes[numericField])
-             .filter(v => typeof v === 'number') as number[];
-           const sorted = [...values].sort((a, b) => a - b);
-           const min = sorted[0] ?? 0;
-           const max = sorted[sorted.length - 1] ?? 0;
-           const median = sorted.length ? sorted[Math.floor(sorted.length / 2)] : 0;
---
+           q.returnGeometry = false;
+           const result = await layer.queryFeatures(q);
+           const values = result.features
+             .map(f: any => f.attributes[numericField])
+             .filter(v: any => typeof v === 'number') as number[];
+           const sorted = [...values].sort((a: any, b: any) => a - b);
+           const min = sorted[0] ?? 0;
+           const max = sorted[sorted.length - 1] ?? 0;
+           const median = sorted.length ? sorted[Math.floor(sorted.length / 2)] : 0;
+           
+           // Determine this feature's value using a spatial query on its geometry
+           let featureValue = NaN;
@@ lines 1501-1510 @@
-       );
-       // Separate selected layer first
-       const selId = feature.layer?.id;
-       const selStat = stats.find(s => s.id === selId);
-       const otherStats = stats.filter(s => s.id !== selId).sort((a, b) => (b.value - b.min) - (a.value - a.min));
-       const finalStats = selStat ? [selStat, ...otherStats] : otherStats;
-       finalStats.forEach(stat => {
-         let displayName = stat.name;
-         if (stat.id === 'applications') {
-           displayName = 'Applications';
---
+       );
+       // Separate selected layer first
+       const selId = feature.layer?.id;
+       const selStat = stats.find(s: any => s.id === selId);
+       const otherStats = stats.filter(s: any => s.id !== selId).sort((a: any, b: any) => (b.value - b.min) - (a.value - a.min));
+       const finalStats = selStat ? [selStat, ...otherStats] : otherStats;
+       finalStats.forEach(stat: any => {
+         let displayName = stat.name;
+         if (stat.id === 'applications') {
+           displayName = 'Applications';
+         } else if (stat.id === 'conversions') {
+           displayName = 'Conversions';
+         } else if (stat.id === 'conversionRate') {


*** FILE: lib/analysis/strategies/processors/CoreAnalysisProcessor.ts
@@ lines 257-263 @@
-   // ============================================================================
- 
-   protected processRecords(rawRecords: Array<Record<string, unknown>>): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       // Extract core identifiers
-       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
-       const area_name = (record as any).area_name || (record as any).name || (record as any).NAME || 
---
+   // ============================================================================
+ 
+   protected processRecords(rawRecords: Array<Record<string, unknown>>): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       // Extract core identifiers
+       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
+       const area_name = (record as any).area_name || (record as any).name || (record as any).NAME || 
+                        (record as any).area_id || `Area ${index + 1}`;
+       
+       // Extract value - try multiple field names
@@ lines 418-427 @@
-    * Enhanced processing that ensures meaningful analysis even with zero SHAP
-    */
-   protected determineCategory(value: number, allRecords: Array<Record<string, unknown>>): string {
-     const values = allRecords.map(r => this.extractValue(r)).filter(v => !isNaN(v));
-     if (values.length === 0) return 'unknown';
-     
-     values.sort((a, b) => a - b);
-     const p25 = values[Math.floor(values.length * 0.25)];
-     const p75 = values[Math.floor(values.length * 0.75)];
-     
---
+    * Enhanced processing that ensures meaningful analysis even with zero SHAP
+    */
+   protected determineCategory(value: number, allRecords: Array<Record<string, unknown>>): string {
+     const values = allRecords.map(r: any => this.extractValue(r)).filter(v: any => !isNaN(v));
+     if (values.length === 0) return 'unknown';
+     
+     values.sort((a: any, b: any) => a - b);
+     const p25 = values[Math.floor(values.length * 0.25)];
+     const p75 = values[Math.floor(values.length * 0.75)];
+     
+     if (value >= p75) return 'high';
+     if (value <= p25) return 'low';
+     return 'medium';
@@ lines 432-451 @@
- 
-   protected rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
-     // Sort by value descending and assign ranks
-     const sorted = [...records].sort((a, b) => b.value - a.value);
-     
-     return sorted.map((record, index) => ({
-       ...record,
-       rank: index + 1
-     }));
-   }
- 
-   protected processFeatureImportance(rawFeatureImportance: Array<Record<string, unknown>>): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getFeatureDescription((item as any).feature || (item as any).name)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   protected getFeatureDescription(featureName: string): string {
---
+ 
+   protected rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
+     // Sort by value descending and assign ranks
+     const sorted = [...records].sort((a: any, b: any) => b.value - a.value);
+     
+     return sorted.map((record: any, index: any) => ({
+       ...record,
+       rank: index + 1
+     }));
+   }
+ 
+   protected processFeatureImportance(rawFeatureImportance: Array<Record<string, unknown>>): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getFeatureDescription((item as any).feature || (item as any).name)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   protected getFeatureDescription(featureName: string): string {
+     // Map common feature names to human-readable descriptions
+     const descriptions: Record<string, string> = {
+       'income': 'Household income levels',
@@ lines 472-478 @@
-   }
- 
-   private calculateAdvancedStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const values = records.map(r => r.value).filter(v => !isNaN(v));
-     
-     if (values.length === 0) {
-       return {
---
+   }
+ 
+   private calculateAdvancedStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v));
+     
+     if (values.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         percentile25: 0, percentile75: 0, iqr: 0, outlierCount: 0
+       };
@@ lines 481-489 @@
-       };
-     }
-     
-     const sorted = [...values].sort((a, b) => a - b);
-     const total = values.length;
-     const sum = values.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     // Calculate percentiles
---
+       };
+     }
+     
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const total = values.length;
+     const sum = values.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     // Calculate percentiles
+     const p25Index = Math.floor(total * 0.25);
+     const p75Index = Math.floor(total * 0.75);
+     const medianIndex = Math.floor(total * 0.5);
@@ lines 498-511 @@
-       : sorted[medianIndex];
-     
-     // Calculate standard deviation
-     const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Calculate IQR and outliers
-     const iqr = percentile75 - percentile25;
-     const lowerBound = percentile25 - 1.5 * iqr;
-     const upperBound = percentile75 + 1.5 * iqr;
-     const outlierCount = values.filter(v => v < lowerBound || v > upperBound).length;
-     
-     return {
-       total,
---
+       : sorted[medianIndex];
+     
+     // Calculate standard deviation
+     const variance = values.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Calculate IQR and outliers
+     const iqr = percentile75 - percentile25;
+     const lowerBound = percentile25 - 1.5 * iqr;
+     const upperBound = percentile75 + 1.5 * iqr;
+     const outlierCount = values.filter(v: any => v < lowerBound || v > upperBound).length;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 536-551 @@
-     summary += `Market average opportunity score: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
-     
-           // Calculate and show demographic baselines using dynamic brand detection
-       const avgTargetShare = records.reduce((sum, r) => sum + ((r.properties as any).target_brand_share || 0), 0) / records.length;
-       const avgCompetitorShare = records.reduce((sum, r) => sum + ((r.properties as any).competitor_brand_share || 0), 0) / records.length;
-       const avgMarketGap = records.reduce((sum, r) => sum + ((r.properties as any).market_gap || 0), 0) / records.length;
-       const avgWealthIndex = records.reduce((sum, r) => sum + ((r.properties as any).value_WLTHINDXCY || 100), 0) / records.length;
-               const avgIncome = records.reduce((sum, r) => {
-           const wealth = (r.properties as any).value_WLTHINDXCY || 100;
-           const income = (r.properties as any).avg_income || (r.properties as any).value_AVGHINC_CY || (wealth * 500);
-           return sum + income;
-         }, 0) / records.length;
-       const avgPopulation = records.reduce((sum, r) => sum + ((r.properties as any).total_population || (r.properties as any).value_TOTPOP_CY || 0), 0) / records.length;
-     
-       // Get brand names from the first record
-   const targetBrandName = records[0]?.properties?.target_brand_name || (this.brandResolver.getTargetBrandName?.() ?? '');
---
+     summary += `Market average opportunity score: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
+     
+           // Calculate and show demographic baselines using dynamic brand detection
+       const avgTargetShare = records.reduce((sum: any, r: any) => sum + ((r.properties as any).target_brand_share || 0), 0) / records.length;
+       const avgCompetitorShare = records.reduce((sum: any, r: any) => sum + ((r.properties as any).competitor_brand_share || 0), 0) / records.length;
+       const avgMarketGap = records.reduce((sum: any, r: any) => sum + ((r.properties as any).market_gap || 0), 0) / records.length;
+       const avgWealthIndex = records.reduce((sum: any, r: any) => sum + ((r.properties as any).value_WLTHINDXCY || 100), 0) / records.length;
+               const avgIncome = records.reduce((sum: any, r: any) => {
+           const wealth = (r.properties as any).value_WLTHINDXCY || 100;
+           const income = (r.properties as any).avg_income || (r.properties as any).value_AVGHINC_CY || (wealth * 500);
+           return sum + income;
+         }, 0) / records.length;
+       const avgPopulation = records.reduce((sum: any, r: any) => sum + ((r.properties as any).total_population || (r.properties as any).value_TOTPOP_CY || 0), 0) / records.length;
+     
+       // Get brand names from the first record
+   const targetBrandName = records[0]?.properties?.target_brand_name || (this.brandResolver.getTargetBrandName?.() ?? '');
+       const competitorBrandName = records[0]?.properties?.competitor_brand_name || 'Competitor';
+       
+           summary += `Average ${targetBrandName} presence: ${avgTargetShare.toFixed(1)}%, ${competitorBrandName} presence: ${avgCompetitorShare.toFixed(1)}%, market gap: ${avgMarketGap.toFixed(1)}%. `;
@@ lines 555-563 @@
-       summary += `Demographic baseline: wealth index ${avgWealthIndex.toFixed(0)}, $${(avgIncome/1000).toFixed(0)}K estimated income, ${(avgPopulation/1000).toFixed(0)}K average population. `;
-     
-     // Performance distribution context
-     const above70 = records.filter(r => r.value >= 70).length;
-     const above50 = records.filter(r => r.value >= 50).length;
-     const above30 = records.filter(r => r.value >= 30).length;
-     
-     summary += `Performance distribution: ${above70} markets (${(above70/records.length*100).toFixed(1)}%) score 70+, ${above50} (${(above50/records.length*100).toFixed(1)}%) score 50+, ${above30} (${(above30/records.length*100).toFixed(1)}%) score 30+.
- 
---
+       summary += `Demographic baseline: wealth index ${avgWealthIndex.toFixed(0)}, $${(avgIncome/1000).toFixed(0)}K estimated income, ${(avgPopulation/1000).toFixed(0)}K average population. `;
+     
+     // Performance distribution context
+     const above70 = records.filter(r: any => r.value >= 70).length;
+     const above50 = records.filter(r: any => r.value >= 50).length;
+     const above30 = records.filter(r: any => r.value >= 30).length;
+     
+     summary += `Performance distribution: ${above70} markets (${(above70/records.length*100).toFixed(1)}%) score 70+, ${above50} (${(above50/records.length*100).toFixed(1)}%) score 50+, ${above30} (${(above30/records.length*100).toFixed(1)}%) score 30+.
+ 
+ `;
+     
+     summary += `**Market Analysis Complete:** ${statistics.total} geographic areas analyzed across key performance indicators. `;
@@ lines 568-599 @@
-     // Enhanced top performers section (5-8 areas)
-     const topPerformers = records.slice(0, 8);
-     if (topPerformers.length > 0) {
-       const topTier = topPerformers.filter(r => r.value >= 70);
-       if (topTier.length > 0) {
-         summary += `**Top Performers** (Scores 70+): `;
-         const topNames = topTier.slice(0, 10).map(r => `${r.area_name} (${r.value.toFixed(1)})`);
-         summary += `${topNames.join(', ')}. `;
-         
-         // Add insights about top performers
-         const avgTopScore = topTier.reduce((sum, r) => sum + r.value, 0) / topTier.length;
-         summary += `These areas achieve exceptional performance with average score ${avgTopScore.toFixed(1)}. `;
-       }
-     }
-     
-     // Enhanced emerging opportunities section (3-5 areas)
-     const emergingOpportunities = records.filter(r => r.value >= 50 && r.value < 70).slice(0, 5);
-     if (emergingOpportunities.length > 0) {
-       summary += `**Emerging Opportunities** (Scores 50-70): `;
-       const emergingNames = emergingOpportunities.map(r => `${r.area_name} (${r.value.toFixed(1)})`);
-       summary += `${emergingNames.join(', ')}. `;
-       summary += `These areas show strong growth potential with developing market conditions. `;
-     }
-     
-     // Investment targets section (3-5 areas)
-     const investmentTargets = records.filter(r => r.value >= 30 && r.value < 50).slice(0, 5);
-     if (investmentTargets.length > 0) {
-       summary += `**Investment Targets** (Scores 30-50): `;
-       const targetNames = investmentTargets.map(r => `${r.area_name} (${r.value.toFixed(1)})`);
-       summary += `${targetNames.join(', ')}. `;
-       summary += `These areas present strategic value despite lower current performance. `;
-     }
---
+     // Enhanced top performers section (5-8 areas)
+     const topPerformers = records.slice(0, 8);
+     if (topPerformers.length > 0) {
+       const topTier = topPerformers.filter(r: any => r.value >= 70);
+       if (topTier.length > 0) {
+         summary += `**Top Performers** (Scores 70+): `;
+         const topNames = topTier.slice(0, 10).map(r: any => `${r.area_name} (${r.value.toFixed(1)})`);
+         summary += `${topNames.join(', ')}. `;
+         
+         // Add insights about top performers
+         const avgTopScore = topTier.reduce((sum: any, r: any) => sum + r.value, 0) / topTier.length;
+         summary += `These areas achieve exceptional performance with average score ${avgTopScore.toFixed(1)}. `;
+       }
+     }
+     
+     // Enhanced emerging opportunities section (3-5 areas)
+     const emergingOpportunities = records.filter(r: any => r.value >= 50 && r.value < 70).slice(0, 5);
+     if (emergingOpportunities.length > 0) {
+       summary += `**Emerging Opportunities** (Scores 50-70): `;
+       const emergingNames = emergingOpportunities.map(r: any => `${r.area_name} (${r.value.toFixed(1)})`);
+       summary += `${emergingNames.join(', ')}. `;
+       summary += `These areas show strong growth potential with developing market conditions. `;
+     }
+     
+     // Investment targets section (3-5 areas)
+     const investmentTargets = records.filter(r: any => r.value >= 30 && r.value < 50).slice(0, 5);
+     if (investmentTargets.length > 0) {
+       summary += `**Investment Targets** (Scores 30-50): `;
+       const targetNames = investmentTargets.map(r: any => `${r.area_name} (${r.value.toFixed(1)})`);
+       summary += `${targetNames.join(', ')}. `;
+       summary += `These areas present strategic value despite lower current performance. `;
+     }
+     
+     // Enhanced performance distribution with context
+     summary += `**Market Structure:** ${categoryBreakdown.high} high-performance markets (${(categoryBreakdown.high / statistics.total * 100).toFixed(1)}%), `;
@@ lines 605-617 @@
-     
-     // Strategic insights based on data patterns
-     const avgScore = statistics.mean;
-     const highPerformers = records.filter(r => r.value > avgScore * 1.2).length;
-     summary += `**Strategic Insights:** Market average performance is ${avgScore.toFixed(1)}. `;
-     summary += `${highPerformers} areas significantly outperform market average (20%+ above mean). `;
-     
-     // Add demographic insights if available
-     const hasIncomeData = records.some(r => (r.properties as any).avg_income || (r.properties as any).value_AVGHINC_CY);
-     const hasPopulationData = records.some(r => (r.properties as any).total_population || (r.properties as any).value_TOTPOP_CY);
-     
-     if (hasIncomeData || hasPopulationData) {
-       summary += `Performance correlates with `;
---
+     
+     // Strategic insights based on data patterns
+     const avgScore = statistics.mean;
+     const highPerformers = records.filter(r: any => r.value > avgScore * 1.2).length;
+     summary += `**Strategic Insights:** Market average performance is ${avgScore.toFixed(1)}. `;
+     summary += `${highPerformers} areas significantly outperform market average (20%+ above mean). `;
+     
+     // Add demographic insights if available
+     const hasIncomeData = records.some(r: any => (r.properties as any).avg_income || (r.properties as any).value_AVGHINC_CY);
+     const hasPopulationData = records.some(r: any => (r.properties as any).total_population || (r.properties as any).value_TOTPOP_CY);
+     
+     if (hasIncomeData || hasPopulationData) {
+       summary += `Performance correlates with `;
+       const factors = [];
+       if (hasIncomeData) factors.push('income levels');
+       if (hasPopulationData) factors.push('population density');
@@ lines 646-652 @@
-   }
- 
-   protected getCategoryBreakdown(records: GeographicDataPoint[]) {
-     return records.reduce((acc, record) => {
-       acc[(record as any).category!] = (acc[(record as any).category!] || 0) + 1;
-       return acc;
-     }, {} as Record<string, number>);
---
+   }
+ 
+   protected getCategoryBreakdown(records: GeographicDataPoint[]) {
+     return records.reduce((acc: any, record: any) => {
+       acc[(record as any).category!] = (acc[(record as any).category!] || 0) + 1;
+       return acc;
+     }, {} as Record<string, number>);
+   }
+ 
+   /**
@@ lines 664-670 @@
-   const fieldDefinitions = getTopFieldDefinitions('core_analysis');
-   console.log(`[CoreAnalysisProcessor] Using hardcoded top field definitions for core_analysis`);
-     
-     fieldDefinitions.forEach(fieldDef => {
-       let value = 0;
-       const sources = Array.isArray(fieldDef.source) ? fieldDef.source : [fieldDef.source];
-       
---
+   const fieldDefinitions = getTopFieldDefinitions('core_analysis');
+   console.log(`[CoreAnalysisProcessor] Using hardcoded top field definitions for core_analysis`);
+     
+     fieldDefinitions.forEach(fieldDef: any => {
+       let value = 0;
+       const sources = Array.isArray(fieldDef.source) ? fieldDef.source : [fieldDef.source];
+       
+       // Find the first available source field
+       for (const source of sources) {
+         if (record[source] !== undefined && record[source] !== null) {
@@ lines 698-706 @@
-     
-     // Sort by importance and take top 5
-     const topFields = contributingFields
-       .sort((a, b) => b.importance - a.importance)
-       .slice(0, 5)
-       .reduce((acc, item) => {
-         acc[(item as any).field] = (item as any).value;
-         return acc;
-       }, {} as Record<string, number>);
---
+     
+     // Sort by importance and take top 5
+     const topFields = contributingFields
+       .sort((a: any, b: any) => b.importance - a.importance)
+       .slice(0, 5)
+       .reduce((acc: any, item: any) => {
+         acc[(item as any).field] = (item as any).value;
+         return acc;
+       }, {} as Record<string, number>);
+     
+     console.log(`[CoreAnalysisProcessor] Top contributing fields for ${(record as any).ID}:`, topFields);
+     return topFields;


*** FILE: lib/analysis/strategies/processors/TrendDataProcessor.ts
@@ lines 23-29 @@
-     
-     // Validate trend-specific fields
-     const hasTrendFields = rawData.results.length === 0 || 
-       rawData.results.some(record => 
-         record && 
-         // Check for trend-related fields
-         ((record as any).trend_score !== undefined ||      // Trend score
---
+     
+     // Validate trend-specific fields
+     const hasTrendFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => 
+         record && 
+         // Check for trend-related fields
+         ((record as any).trend_score !== undefined ||      // Trend score
+          (record as any).growth_rate !== undefined ||      // Growth rate
+          (record as any).momentum !== undefined ||         // Momentum indicator
+          (record as any).trend_direction !== undefined ||  // Trend direction
@@ lines 78-84 @@
-   // ============================================================================
- 
-   private processTrendRecords(rawRecords: any[], primaryField: string): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       // Use BaseProcessor methods for area identification
-       const area_id = this.extractGeographicId(record) || `area_${index}`;
-       const area_name = this.generateAreaName(record);
---
+   // ============================================================================
+ 
+   private processTrendRecords(rawRecords: any[], primaryField: string): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       // Use BaseProcessor methods for area identification
+       const area_id = this.extractGeographicId(record) || `area_${index}`;
+       const area_name = this.generateAreaName(record);
+       
+       // Extract trend score using configuration-driven approach
+       const trendScore = this.extractPrimaryMetric(record);
@@ lines 124-131 @@
-   properties,
-         shapValues
-       };
-     }).sort((a, b) => b.value - a.value) // Sort by trend score
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
- 
---
+   properties,
+         shapValues
+       };
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by trend score
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+ 
+   private calculateForecastConfidence(record: any): number {
+     // Calculate confidence in trend forecasting
+     const volatility = (record as any).volatility || 0.5;
@@ lines 213-221 @@
-   }
- 
-   private calculateTrendStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const scores = records.map(r => r.value);
-     const growthRates = records.map(r => (r.properties as any).growth_rate || 0);
-     const momentums = records.map(r => (r.properties as any).momentum || 0);
-     
-     if (scores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateTrendStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const scores = records.map(r: any => r.value);
+     const growthRates = records.map(r: any => (r.properties as any).growth_rate || 0);
+     const momentums = records.map(r: any => (r.properties as any).momentum || 0);
+     
+     if (scores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         avgGrowthRate: 0, avgMomentum: 0, trendVolatility: 0
+       };
@@ lines 224-245 @@
-       };
-     }
-     
-     const sorted = [...scores].sort((a, b) => a - b);
-     const total = scores.length;
-     const sum = scores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Trend-specific metrics
-     const avgGrowthRate = growthRates.reduce((a, b) => a + b, 0) / total;
-     const avgMomentum = momentums.reduce((a, b) => a + b, 0) / total;
-     const trendVolatility = records.reduce((sum, r) => sum + ((r.properties as any).volatility || 0), 0) / total;
-     
-     return {
-       total,
---
+       };
+     }
+     
+     const sorted = [...scores].sort((a: any, b: any) => a - b);
+     const total = scores.length;
+     const sum = scores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Trend-specific metrics
+     const avgGrowthRate = growthRates.reduce((a: any, b: any) => a + b, 0) / total;
+     const avgMomentum = momentums.reduce((a: any, b: any) => a + b, 0) / total;
+     const trendVolatility = records.reduce((sum: any, r: any) => sum + ((r.properties as any).volatility || 0), 0) / total;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 258-264 @@
-     // Group by trend categories
-     const categoryMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const category = (record as any).category!;
-       if (!categoryMap.has(category)) {
-         categoryMap.set(category, []);
---
+     // Group by trend categories
+     const categoryMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const category = (record as any).category!;
+       if (!categoryMap.has(category)) {
+         categoryMap.set(category, []);
+       }
+       categoryMap.get(category)!.push(record);
+     });
@@ lines 268-275 @@
-     
-     // Analyze each category
-     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
-       const avgScore = categoryRecords.reduce((sum, r) => sum + r.value, 0) / categoryRecords.length;
-       const avgGrowthRate = categoryRecords.reduce((sum, r) => sum + ((r.properties as any).growth_rate || 0), 0) / categoryRecords.length;
-       
-       return {
-         category,
---
+     
+     // Analyze each category
+     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
+       const avgScore = categoryRecords.reduce((sum: any, r: any) => sum + r.value, 0) / categoryRecords.length;
+       const avgGrowthRate = categoryRecords.reduce((sum: any, r: any) => sum + ((r.properties as any).growth_rate || 0), 0) / categoryRecords.length;
+       
+       return {
+         category,
+         size: categoryRecords.length,
+         percentage: (categoryRecords.length / records.length) * 100,
+         avgTrendScore: avgScore,
@@ lines 278-286 @@
-         avgTrendScore: avgScore,
-         avgGrowthRate,
-         topAreas: categoryRecords
-           .sort((a, b) => b.value - a.value)
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             score: r.value,
-             growthRate: (r.properties as any).growth_rate,
---
+         avgTrendScore: avgScore,
+         avgGrowthRate,
+         topAreas: categoryRecords
+           .sort((a: any, b: any) => b.value - a.value)
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             score: r.value,
+             growthRate: (r.properties as any).growth_rate,
+             momentum: (r.properties as any).momentum
+           }))
+       };
@@ lines 291-315 @@
-     
-     // Identify trend leaders and accelerating markets
-     const trendLeaders = records
-       .filter(r => r.category === 'strong_positive_trend')
-       .sort((a, b) => b.value - a.value)
-       .slice(0, 5);
-     
-     const acceleratingMarkets = records
-       .filter(r => (r.properties as any).momentum > 0.5)
-       .sort((a, b) => (b.properties as any).momentum - (a.properties as any).momentum)
-       .slice(0, 5);
-     
-     return {
-       categories: categoryAnalysis,
-       trendLeaders: trendLeaders.map(r => ({
-         area: r.area_name,
-         score: r.value,
-         growthRate: (r.properties as any).growth_rate,
-         momentum: (r.properties as any).momentum,
-         stability: (r.properties as any).stability_index
-       })),
-       acceleratingMarkets: acceleratingMarkets.map(r => ({
-         area: r.area_name,
-         momentum: (r.properties as any).momentum,
-         growthRate: (r.properties as any).growth_rate,
---
+     
+     // Identify trend leaders and accelerating markets
+     const trendLeaders = records
+       .filter(r: any => r.category === 'strong_positive_trend')
+       .sort((a: any, b: any) => b.value - a.value)
+       .slice(0, 5);
+     
+     const acceleratingMarkets = records
+       .filter(r: any => (r.properties as any).momentum > 0.5)
+       .sort((a: any, b: any) => (b.properties as any).momentum - (a.properties as any).momentum)
+       .slice(0, 5);
+     
+     return {
+       categories: categoryAnalysis,
+       trendLeaders: trendLeaders.map(r: any => ({
+         area: r.area_name,
+         score: r.value,
+         growthRate: (r.properties as any).growth_rate,
+         momentum: (r.properties as any).momentum,
+         stability: (r.properties as any).stability_index
+       })),
+       acceleratingMarkets: acceleratingMarkets.map(r: any => ({
+         area: r.area_name,
+         momentum: (r.properties as any).momentum,
+         growthRate: (r.properties as any).growth_rate,
+         trend: 'accelerating'
+       })),
+       marketMomentum: this.analyzeMarketMomentum(categoryAnalysis)
@@ lines 320-327 @@
-   }
- 
-   private analyzeMarketMomentum(categoryAnalysis: any[]): string {
-     const strongTrendPercentage = categoryAnalysis.find(c => c.category === 'strong_positive_trend')?.percentage || 0;
-     const moderateTrendPercentage = categoryAnalysis.find(c => c.category === 'moderate_positive_trend')?.percentage || 0;
-     
-     if (strongTrendPercentage > 40) return 'strong_market_momentum';
-     if (strongTrendPercentage + moderateTrendPercentage > 60) return 'positive_market_momentum';
---
+   }
+ 
+   private analyzeMarketMomentum(categoryAnalysis: any[]): string {
+     const strongTrendPercentage = categoryAnalysis.find(c: any => c.category === 'strong_positive_trend')?.percentage || 0;
+     const moderateTrendPercentage = categoryAnalysis.find(c: any => c.category === 'moderate_positive_trend')?.percentage || 0;
+     
+     if (strongTrendPercentage > 40) return 'strong_market_momentum';
+     if (strongTrendPercentage + moderateTrendPercentage > 60) return 'positive_market_momentum';
+     if (moderateTrendPercentage > 40) return 'moderate_market_momentum';
+     return 'mixed_market_momentum';
+   }
@@ lines 330-341 @@
-   }
- 
-   private processTrendFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getTrendFeatureDescription((item as any).feature || (item as any).name),
-       trendImpact: this.assessTrendImpact((item as any).importance || 0)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getTrendFeatureDescription(featureName: string): string {
---
+   }
+ 
+   private processTrendFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getTrendFeatureDescription((item as any).feature || (item as any).name),
+       trendImpact: this.assessTrendImpact((item as any).importance || 0)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getTrendFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'growth': 'Growth rate and expansion patterns',
+       'momentum': 'Market momentum and acceleration indicators',
@@ lines 384-403 @@
- `;
-     
-     // Enhanced baseline and trend metrics section
-     const avgScore = records.reduce((sum, r) => sum + r.value, 0) / records.length;
-     const avgGrowthRate = records.reduce((sum, r) => sum + ((r.properties as any).growth_rate || 0), 0) / records.length;
-     const avgMomentum = records.reduce((sum, r) => sum + ((r.properties as any).momentum || 0), 0) / records.length;
-     const avgTrendStrength = records.reduce((sum, r) => sum + ((r.properties as any).trend_strength || 0), 0) / records.length;
-     
-     summary += `**📈 Trend Baseline & Market Averages:** `;
-     summary += `Market average trend score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
-     summary += `Trend baseline: ${(avgGrowthRate * 100).toFixed(1)}% growth rate, ${(avgMomentum * 100).toFixed(1)}% momentum, ${(avgTrendStrength * 100).toFixed(1)}% trend strength. `;
-     
-     // Trend direction distribution
-     const strongUptrend = records.filter(r => r.value >= 70).length;
-     const moderateUptrend = records.filter(r => r.value >= 50).length;
-     const stableTrend = records.filter(r => r.value >= 30).length;
-     const decliningTrend = records.filter(r => r.value < 30).length;
-     
-     summary += `Trend distribution: ${strongUptrend} strong uptrends (${(strongUptrend/totalAreas*100).toFixed(1)}%), ${moderateUptrend} moderate+ trends (${(moderateUptrend/totalAreas*100).toFixed(1)}%), ${stableTrend} stable+ (${(stableTrend/totalAreas*100).toFixed(1)}%), ${decliningTrend} declining (${(decliningTrend/totalAreas*100).toFixed(1)}%).
- 
---
+ `;
+     
+     // Enhanced baseline and trend metrics section
+     const avgScore = records.reduce((sum: any, r: any) => sum + r.value, 0) / records.length;
+     const avgGrowthRate = records.reduce((sum: any, r: any) => sum + ((r.properties as any).growth_rate || 0), 0) / records.length;
+     const avgMomentum = records.reduce((sum: any, r: any) => sum + ((r.properties as any).momentum || 0), 0) / records.length;
+     const avgTrendStrength = records.reduce((sum: any, r: any) => sum + ((r.properties as any).trend_strength || 0), 0) / records.length;
+     
+     summary += `**📈 Trend Baseline & Market Averages:** `;
+     summary += `Market average trend score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
+     summary += `Trend baseline: ${(avgGrowthRate * 100).toFixed(1)}% growth rate, ${(avgMomentum * 100).toFixed(1)}% momentum, ${(avgTrendStrength * 100).toFixed(1)}% trend strength. `;
+     
+     // Trend direction distribution
+     const strongUptrend = records.filter(r: any => r.value >= 70).length;
+     const moderateUptrend = records.filter(r: any => r.value >= 50).length;
+     const stableTrend = records.filter(r: any => r.value >= 30).length;
+     const decliningTrend = records.filter(r: any => r.value < 30).length;
+     
+     summary += `Trend distribution: ${strongUptrend} strong uptrends (${(strongUptrend/totalAreas*100).toFixed(1)}%), ${moderateUptrend} moderate+ trends (${(moderateUptrend/totalAreas*100).toFixed(1)}%), ${stableTrend} stable+ (${(stableTrend/totalAreas*100).toFixed(1)}%), ${decliningTrend} declining (${(decliningTrend/totalAreas*100).toFixed(1)}%).
+ 
+ `;
+     
+     summary += `**Trend Analysis Complete:** ${totalAreas} geographic markets analyzed across key trend indicators. `;


*** FILE: lib/analysis/strategies/processors/RiskDataProcessor.ts
@@ lines 23-29 @@
-     
-     // Validate risk-specific fields
-     const hasRiskFields = rawData.results.length === 0 || 
-       rawData.results.some(record => 
-         record && 
-         // Check for risk-related fields
-         ((record as any).risk_score !== undefined ||       // Risk score
---
+     
+     // Validate risk-specific fields
+     const hasRiskFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => 
+         record && 
+         // Check for risk-related fields
+         ((record as any).risk_score !== undefined ||       // Risk score
+          (record as any).volatility !== undefined ||       // Volatility measure
+          (record as any).uncertainty !== undefined ||      // Uncertainty level
+          (record as any).stability !== undefined ||        // Stability indicator
@@ lines 78-84 @@
-   // ============================================================================
- 
-   private processRiskRecords(rawRecords: any[], primaryField: string): GeographicDataPoint[] {
-     return rawRecords.map((record, index) => {
-       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || (record as any).ID || `area_${index}`;
-       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
-       
---
+   // ============================================================================
+ 
+   private processRiskRecords(rawRecords: any[], primaryField: string): GeographicDataPoint[] {
+     return rawRecords.map((record: any, index: any) => {
+       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || (record as any).ID || `area_${index}`;
+       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
+       
+       // Extract risk-adjusted score (higher is better - lower risk, higher opportunity)
+       const riskScore = this.extractRiskScore(record);
+       
@@ lines 121-128 @@
-         properties,
-         shapValues
-       };
-     }).sort((a, b) => b.value - a.value) // Sort by risk-adjusted score (higher = better)
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
-   private extractRiskScore(record: any): number {
---
+         properties,
+         shapValues
+       };
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by risk-adjusted score (higher = better)
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+   private extractRiskScore(record: any): number {
+     // Calculate risk-adjusted score (higher is better)
+     const baseValue = (record as any).base_value || (record as any).opportunity_score || 50;
+     const volatility = (record as any).volatility || 0.3;
@@ lines 243-251 @@
-   }
- 
-   private calculateRiskStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const scores = records.map(r => r.value);
-     const volatilities = records.map(r => (r.properties as any).volatility || 0);
-     const uncertainties = records.map(r => (r.properties as any).uncertainty || 0);
-     
-     if (scores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateRiskStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const scores = records.map(r: any => r.value);
+     const volatilities = records.map(r: any => (r.properties as any).volatility || 0);
+     const uncertainties = records.map(r: any => (r.properties as any).uncertainty || 0);
+     
+     if (scores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         avgVolatility: 0, avgUncertainty: 0, riskLevel: 'medium'
+       };
@@ lines 254-274 @@
-       };
-     }
-     
-     const sorted = [...scores].sort((a, b) => a - b);
-     const total = scores.length;
-     const sum = scores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Risk-specific metrics
-     const avgVolatility = volatilities.reduce((a, b) => a + b, 0) / total;
-     const avgUncertainty = uncertainties.reduce((a, b) => a + b, 0) / total;
-     
-     // Determine overall risk level
-     let riskLevel: 'low' | 'medium' | 'high' = 'medium';
---
+       };
+     }
+     
+     const sorted = [...scores].sort((a: any, b: any) => a - b);
+     const total = scores.length;
+     const sum = scores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = scores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Risk-specific metrics
+     const avgVolatility = volatilities.reduce((a: any, b: any) => a + b, 0) / total;
+     const avgUncertainty = uncertainties.reduce((a: any, b: any) => a + b, 0) / total;
+     
+     // Determine overall risk level
+     let riskLevel: 'low' | 'medium' | 'high' = 'medium';
+     if (avgVolatility > 0.6 || avgUncertainty > 0.6) riskLevel = 'high';
+     else if (avgVolatility < 0.3 && avgUncertainty < 0.3) riskLevel = 'low';
+     
@@ lines 292-298 @@
-     // Group by risk categories
-     const categoryMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const category = (record as any).category!;
-       if (!categoryMap.has(category)) {
-         categoryMap.set(category, []);
---
+     // Group by risk categories
+     const categoryMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const category = (record as any).category!;
+       if (!categoryMap.has(category)) {
+         categoryMap.set(category, []);
+       }
+       categoryMap.get(category)!.push(record);
+     });
@@ lines 302-309 @@
-     
-     // Analyze each category
-     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
-       const avgScore = categoryRecords.reduce((sum, r) => sum + r.value, 0) / categoryRecords.length;
-       const avgVolatility = categoryRecords.reduce((sum, r) => sum + ((r.properties as any).volatility || 0), 0) / categoryRecords.length;
-       
-       return {
-         category,
---
+     
+     // Analyze each category
+     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
+       const avgScore = categoryRecords.reduce((sum: any, r: any) => sum + r.value, 0) / categoryRecords.length;
+       const avgVolatility = categoryRecords.reduce((sum: any, r: any) => sum + ((r.properties as any).volatility || 0), 0) / categoryRecords.length;
+       
+       return {
+         category,
+         size: categoryRecords.length,
+         percentage: (categoryRecords.length / records.length) * 100,
+         avgRiskScore: avgScore,
@@ lines 312-320 @@
-         avgRiskScore: avgScore,
-         avgVolatility,
-         topAreas: categoryRecords
-           .sort((a, b) => b.value - a.value)
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             score: r.value,
-             volatility: (r.properties as any).volatility,
---
+         avgRiskScore: avgScore,
+         avgVolatility,
+         topAreas: categoryRecords
+           .sort((a: any, b: any) => b.value - a.value)
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             score: r.value,
+             volatility: (r.properties as any).volatility,
+             uncertainty: (r.properties as any).uncertainty
+           }))
+       };
@@ lines 325-349 @@
-     
-     // Identify safe havens and high-risk areas
-     const safeHavens = records
-       .filter(r => r.category === 'low_risk_high_reward')
-       .sort((a, b) => b.value - a.value)
-       .slice(0, 5);
-     
-     const highRiskAreas = records
-       .filter(r => (r.properties as any).volatility > 0.6)
-       .sort((a, b) => (b.properties as any).volatility - (a.properties as any).volatility)
-       .slice(0, 5);
-     
-     return {
-       categories: categoryAnalysis,
-       safeHavens: safeHavens.map(r => ({
-         area: r.area_name,
-         score: r.value,
-         volatility: (r.properties as any).volatility,
-         uncertainty: (r.properties as any).uncertainty,
-         confidence: (r.properties as any).risk_confidence
-       })),
-       highRiskAreas: highRiskAreas.map(r => ({
-         area: r.area_name,
-         volatility: (r.properties as any).volatility,
-         uncertainty: (r.properties as any).uncertainty,
---
+     
+     // Identify safe havens and high-risk areas
+     const safeHavens = records
+       .filter(r: any => r.category === 'low_risk_high_reward')
+       .sort((a: any, b: any) => b.value - a.value)
+       .slice(0, 5);
+     
+     const highRiskAreas = records
+       .filter(r: any => (r.properties as any).volatility > 0.6)
+       .sort((a: any, b: any) => (b.properties as any).volatility - (a.properties as any).volatility)
+       .slice(0, 5);
+     
+     return {
+       categories: categoryAnalysis,
+       safeHavens: safeHavens.map(r: any => ({
+         area: r.area_name,
+         score: r.value,
+         volatility: (r.properties as any).volatility,
+         uncertainty: (r.properties as any).uncertainty,
+         confidence: (r.properties as any).risk_confidence
+       })),
+       highRiskAreas: highRiskAreas.map(r: any => ({
+         area: r.area_name,
+         volatility: (r.properties as any).volatility,
+         uncertainty: (r.properties as any).uncertainty,
+         mitigation: (r.properties as any).mitigation_potential,
+         status: 'high_risk'
+       })),
@@ lines 355-362 @@
-   }
- 
-   private analyzeRiskProfile(categoryAnalysis: any[]): string {
-     const lowRiskPercentage = categoryAnalysis.find(c => c.category === 'low_risk_high_reward')?.percentage || 0;
-     const highRiskPercentage = categoryAnalysis.filter(c => c.category.includes('high_risk')).reduce((sum, c) => sum + c.percentage, 0);
-     
-     if (lowRiskPercentage > 40) return 'conservative_risk_profile';
-     if (highRiskPercentage > 40) return 'aggressive_risk_profile';
---
+   }
+ 
+   private analyzeRiskProfile(categoryAnalysis: any[]): string {
+     const lowRiskPercentage = categoryAnalysis.find(c: any => c.category === 'low_risk_high_reward')?.percentage || 0;
+     const highRiskPercentage = categoryAnalysis.filter(c: any => c.category.includes('high_risk')).reduce((sum: any, c: any) => sum + c.percentage, 0);
+     
+     if (lowRiskPercentage > 40) return 'conservative_risk_profile';
+     if (highRiskPercentage > 40) return 'aggressive_risk_profile';
+     if (lowRiskPercentage + highRiskPercentage < 60) return 'balanced_risk_profile';
+     return 'mixed_risk_profile';
+   }
@@ lines 365-376 @@
-   }
- 
-   private processRiskFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getRiskFeatureDescription((item as any).feature || (item as any).name),
-       riskImpact: this.assessRiskImpact((item as any).importance || 0)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getRiskFeatureDescription(featureName: string): string {
---
+   }
+ 
+   private processRiskFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getRiskFeatureDescription((item as any).feature || (item as any).name),
+       riskImpact: this.assessRiskImpact((item as any).importance || 0)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getRiskFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'volatility': 'Market volatility and price fluctuation patterns',
+       'uncertainty': 'Uncertainty levels and predictability measures',
@@ lines 419-437 @@
- `;
-     
-     // Enhanced baseline and risk metrics section
-     const avgScore = records.reduce((sum, r) => sum + r.value, 0) / records.length;
-     const avgVolatility = records.reduce((sum, r) => sum + ((r.properties as any).volatility || 0), 0) / records.length;
-     const avgUncertainty = records.reduce((sum, r) => sum + ((r.properties as any).uncertainty || 0), 0) / records.length;
-     const avgStability = records.reduce((sum, r) => sum + ((r.properties as any).stability || 0), 0) / records.length;
-     
-     summary += `**⚖️ Risk Baseline & Market Averages:** `;
-     summary += `Market average risk-adjusted score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
-     summary += `Risk baseline: ${(avgVolatility * 100).toFixed(1)}% volatility, ${(avgUncertainty * 100).toFixed(1)}% uncertainty, ${(avgStability * 100).toFixed(1)}% stability. `;
-     
-     // Risk distribution analysis
-     const lowRisk = records.filter(r => ((r.properties as any).volatility || 0) < 0.3).length;
-     const moderateRisk = records.filter(r => ((r.properties as any).volatility || 0) >= 0.3 && ((r.properties as any).volatility || 0) < 0.6).length;
-     const highRisk = records.filter(r => ((r.properties as any).volatility || 0) >= 0.6).length;
-     
-     summary += `Risk distribution: ${lowRisk} low-risk markets (${(lowRisk/totalAreas*100).toFixed(1)}%), ${moderateRisk} moderate-risk (${(moderateRisk/totalAreas*100).toFixed(1)}%), ${highRisk} high-risk (${(highRisk/totalAreas*100).toFixed(1)}%).
- 
---
+ `;
+     
+     // Enhanced baseline and risk metrics section
+     const avgScore = records.reduce((sum: any, r: any) => sum + r.value, 0) / records.length;
+     const avgVolatility = records.reduce((sum: any, r: any) => sum + ((r.properties as any).volatility || 0), 0) / records.length;
+     const avgUncertainty = records.reduce((sum: any, r: any) => sum + ((r.properties as any).uncertainty || 0), 0) / records.length;
+     const avgStability = records.reduce((sum: any, r: any) => sum + ((r.properties as any).stability || 0), 0) / records.length;
+     
+     summary += `**⚖️ Risk Baseline & Market Averages:** `;
+     summary += `Market average risk-adjusted score: ${avgScore.toFixed(1)} (range: ${records[records.length - 1]?.value.toFixed(1) || '0'}-${records[0]?.value.toFixed(1) || '0'}). `;
+     summary += `Risk baseline: ${(avgVolatility * 100).toFixed(1)}% volatility, ${(avgUncertainty * 100).toFixed(1)}% uncertainty, ${(avgStability * 100).toFixed(1)}% stability. `;
+     
+     // Risk distribution analysis
+     const lowRisk = records.filter(r: any => ((r.properties as any).volatility || 0) < 0.3).length;
+     const moderateRisk = records.filter(r: any => ((r.properties as any).volatility || 0) >= 0.3 && ((r.properties as any).volatility || 0) < 0.6).length;
+     const highRisk = records.filter(r: any => ((r.properties as any).volatility || 0) >= 0.6).length;
+     
+     summary += `Risk distribution: ${lowRisk} low-risk markets (${(lowRisk/totalAreas*100).toFixed(1)}%), ${moderateRisk} moderate-risk (${(moderateRisk/totalAreas*100).toFixed(1)}%), ${highRisk} high-risk (${(highRisk/totalAreas*100).toFixed(1)}%).
+ 
+ `;
+     
+     summary += `**Risk Analysis Complete:** ${totalAreas} geographic markets analyzed across key risk indicators. `;


*** FILE: lib/geo/GeoAwarenessEngine.ts
@@ lines 184-191 @@
-     
-     // Method 1: Direct entity matching with hierarchy (most reliable)
-     const directMatches = this.findDirectMatches(queryLower);
-     console.log(`🔍 [GEO DEBUG] Direct matches:`, directMatches.map(e => ({ name: e.name, type: e.type })));
-     console.log(`🔍 [GEO DEBUG] Direct match details:`, directMatches.map(e => ({ 
-       name: e.name, 
-       type: e.type, 
-       parentEntity: e.parentEntity,
---
+     
+     // Method 1: Direct entity matching with hierarchy (most reliable)
+     const directMatches = this.findDirectMatches(queryLower);
+     console.log(`🔍 [GEO DEBUG] Direct matches:`, directMatches.map(e: any => ({ name: e.name, type: e.type })));
+     console.log(`🔍 [GEO DEBUG] Direct match details:`, directMatches.map(e: any => ({ 
+       name: e.name, 
+       type: e.type, 
+       parentEntity: e.parentEntity,
+       zipCodesCount: e.zipCodes?.length || 0
+     })));
+     entities.push(...directMatches);
@@ lines 195-212 @@
-     
-     // Method 2: ZIP code pattern matching (very reliable)
-     const zipMatches = this.findZipCodeMatches(query);
-     console.log(`🔍 [GEO DEBUG] ZIP matches:`, zipMatches.map(e => ({ name: e.name, type: e.type })));
-     entities.push(...zipMatches);
-     
-     // Method 3: Regional pattern matching (reliable)
-     const regionalMatches = this.findRegionalMatches(queryLower);
-     console.log(`🔍 [GEO DEBUG] Regional matches:`, regionalMatches.map(e => ({ name: e.name, type: e.type })));
-     entities.push(...regionalMatches);
-     
-     // Method 4: Fuzzy matching ONLY if we already have strong geographic intent and no matches yet
-     if (entities.length === 0 && this.hasStrongGeographicSignals(queryLower)) {
-       const fuzzyMatches = this.findFuzzyMatches(queryLower);
-       console.log(`🔍 [GEO DEBUG] Fuzzy matches (with strong signals):`, fuzzyMatches.map(e => ({ name: e.name, type: e.type })));
-       entities.push(...fuzzyMatches);
-     } else if (entities.length === 0) {
-       console.log(`🚫 [GEO DEBUG] No geographic entities found and no strong geographic signals - treating as non-geographic query`);
---
+     
+     // Method 2: ZIP code pattern matching (very reliable)
+     const zipMatches = this.findZipCodeMatches(query);
+     console.log(`🔍 [GEO DEBUG] ZIP matches:`, zipMatches.map(e: any => ({ name: e.name, type: e.type })));
+     entities.push(...zipMatches);
+     
+     // Method 3: Regional pattern matching (reliable)
+     const regionalMatches = this.findRegionalMatches(queryLower);
+     console.log(`🔍 [GEO DEBUG] Regional matches:`, regionalMatches.map(e: any => ({ name: e.name, type: e.type })));
+     entities.push(...regionalMatches);
+     
+     // Method 4: Fuzzy matching ONLY if we already have strong geographic intent and no matches yet
+     if (entities.length === 0 && this.hasStrongGeographicSignals(queryLower)) {
+       const fuzzyMatches = this.findFuzzyMatches(queryLower);
+       console.log(`🔍 [GEO DEBUG] Fuzzy matches (with strong signals):`, fuzzyMatches.map(e: any => ({ name: e.name, type: e.type })));
+       entities.push(...fuzzyMatches);
+     } else if (entities.length === 0) {
+       console.log(`🚫 [GEO DEBUG] No geographic entities found and no strong geographic signals - treating as non-geographic query`);
+     }
+     
+     // Determine query type
@@ lines 334-353 @@
-       'shop', 'mall', 'center', 'hotel', 'motel', 'inn', 'club', 'gym', 'spa'
-     ];
- 
-     return records.filter(record => {
-       const areaName = (record.area_name || '').toLowerCase();
-       const description = (record.DESCRIPTION || '').toLowerCase();
-       const fullText = `${areaName} ${description}`.toLowerCase();
- 
-       // Check for street suffixes in the area name or description
-       const hasStreetSuffix = streetSuffixes.some(suffix => {
-         // Match street suffix as whole word or at end of phrase
-         const streetPattern = new RegExp(`\\b${suffix}\\b|${suffix}$`, 'i');
-         return streetPattern.test(fullText);
-       });
- 
-       // Check for business names
-       const isBusinessName = businessKeywords.some(keyword => {
-         const businessPattern = new RegExp(`\\b${keyword}\\b`, 'i');
-         return businessPattern.test(fullText);
-       });
---
+       'shop', 'mall', 'center', 'hotel', 'motel', 'inn', 'club', 'gym', 'spa'
+     ];
+ 
+     return records.filter(record: any => {
+       const areaName = (record.area_name || '').toLowerCase();
+       const description = (record.DESCRIPTION || '').toLowerCase();
+       const fullText = `${areaName} ${description}`.toLowerCase();
+ 
+       // Check for street suffixes in the area name or description
+       const hasStreetSuffix = streetSuffixes.some(suffix: any => {
+         // Match street suffix as whole word or at end of phrase
+         const streetPattern = new RegExp(`\\b${suffix}\\b|${suffix}$`, 'i');
+         return streetPattern.test(fullText);
+       });
+ 
+       // Check for business names
+       const isBusinessName = businessKeywords.some(keyword: any => {
+         const businessPattern = new RegExp(`\\b${keyword}\\b`, 'i');
+         return businessPattern.test(fullText);
+       });
+ 
+       // Keep record only if it's NOT a street name and NOT a business
+       return !hasStreetSuffix && !isBusinessName;
@@ lines 375-381 @@
-       for (const record of records) {
-         if (this.recordMatchesEntity(record, targetEntities)) {
-           matchedRecords.push(record);
-           if (!matchedEntities.find(e => e.name === entity.name)) {
-             matchedEntities.push(entity);
-           }
-         }
---
+       for (const record of records) {
+         if (this.recordMatchesEntity(record, targetEntities)) {
+           matchedRecords.push(record);
+           if (!matchedEntities.find(e: any => e.name === entity.name)) {
+             matchedEntities.push(entity);
+           }
+         }
+       }
+     }
+ 
@@ lines 411-419 @@
-       for (const record of records) {
-         const description = this.extractDescription(record);
-         
-         if (patterns.some(pattern => pattern.test(description))) {
-           matchedRecords.push(record);
-           if (!matchedEntities.find(e => e.name === entity.name)) {
-             matchedEntities.push(entity);
-           }
-         }
---
+       for (const record of records) {
+         const description = this.extractDescription(record);
+         
+         if (patterns.some(pattern: any => pattern.test(description))) {
+           matchedRecords.push(record);
+           if (!matchedEntities.find(e: any => e.name === entity.name)) {
+             matchedEntities.push(entity);
+           }
+         }
+       }
+     }
+ 
@@ lines 449-459 @@
-     for (const entity of geoQuery.entities) {
-       // For cities, only use their direct ZIP codes (not expanded regions)
-       if (entity.type === 'city' || entity.type === 'borough' || entity.type === 'neighborhood') {
-         entity.zipCodes?.forEach(zip => targetZipCodes.add(zip));
-         console.log(`[GeoAwarenessEngine] Adding ${entity.zipCodes?.length || 0} ZIP codes for city: ${entity.name}`);
-       }
-       // Only expand ZIP codes for broader entities if no specific cities were mentioned
-       else if (geoQuery.entities.every(e => e.type !== 'city' && e.type !== 'borough')) {
-         // Phase 1: Multi-level ZIP code mapping for broader entities
-         const entityName = entity.name.toLowerCase();
-         
---
+     for (const entity of geoQuery.entities) {
+       // For cities, only use their direct ZIP codes (not expanded regions)
+       if (entity.type === 'city' || entity.type === 'borough' || entity.type === 'neighborhood') {
+         entity.zipCodes?.forEach(zip: any => targetZipCodes.add(zip));
+         console.log(`[GeoAwarenessEngine] Adding ${entity.zipCodes?.length || 0} ZIP codes for city: ${entity.name}`);
+       }
+       // Only expand ZIP codes for broader entities if no specific cities were mentioned
+       else if (geoQuery.entities.every(e: any => e.type !== 'city' && e.type !== 'borough')) {
+         // Phase 1: Multi-level ZIP code mapping for broader entities
+         const entityName = entity.name.toLowerCase();
+         
+         // If this is a county, get all ZIP codes for that county
+         if (entity.type === 'county') {
+           const zipToCountyArr = Array.from(this.zipCodeToCounty.entries());
@@ lines 493-499 @@
-     }
-     
-     console.log(`[GeoAwarenessEngine] Phase 1 ZIP filtering: Found ${targetZipCodes.size} target ZIP codes for entities:`, 
-                 geoQuery.entities.map(e => `${e.name} (${e.type})`));
- 
-     if (targetZipCodes.size === 0) {
-       return {
---
+     }
+     
+     console.log(`[GeoAwarenessEngine] Phase 1 ZIP filtering: Found ${targetZipCodes.size} target ZIP codes for entities:`, 
+                 geoQuery.entities.map(e: any => `${e.name} (${e.type})`));
+ 
+     if (targetZipCodes.size === 0) {
+       return {
+         filteredRecords: [],
+         matchedEntities: [],
+         filterStats: {
@@ lines 540-553 @@
-     const matchedEntities: GeographicEntity[] = [];
- 
-     for (const entity of geoQuery.entities) {
-       const searchTerms = [entity.name, ...entity.aliases].map(term => term.toLowerCase());
-       
-       for (const record of records) {
-         const recordText = this.extractAllTextFields(record).toLowerCase();
-         
-         if (searchTerms.some(term => recordText.includes(term))) {
-           matchedRecords.push(record);
-           if (!matchedEntities.find(e => e.name === entity.name)) {
-             matchedEntities.push(entity);
-           }
-         }
---
+     const matchedEntities: GeographicEntity[] = [];
+ 
+     for (const entity of geoQuery.entities) {
+       const searchTerms = [entity.name, ...entity.aliases].map(term: any => term.toLowerCase());
+       
+       for (const record of records) {
+         const recordText = this.extractAllTextFields(record).toLowerCase();
+         
+         if (searchTerms.some(term: any => recordText.includes(term))) {
+           matchedRecords.push(record);
+           if (!matchedEntities.find(e: any => e.name === entity.name)) {
+             matchedEntities.push(entity);
+           }
+         }
+       }
+     }
+ 
@@ lines 581-587 @@
-       for (const record of records) {
-         if (this.fuzzyMatchRecord(record, entity)) {
-           matchedRecords.push(record);
-           if (!matchedEntities.find(e => e.name === entity.name)) {
-             matchedEntities.push(entity);
-           }
-         }
---
+       for (const record of records) {
+         if (this.fuzzyMatchRecord(record, entity)) {
+           matchedRecords.push(record);
+           if (!matchedEntities.find(e: any => e.name === entity.name)) {
+             matchedEntities.push(entity);
+           }
+         }
+       }
+     }
+ 
@@ lines 704-710 @@
-     ];
-     
-     // If query has business context, require much stronger geographic indicators
-     const hasBusinessContext = businessContextPatterns.some(pattern => pattern.test(query));
-     
-     const allPatterns = [
-       ...geoPrepositions,
---
+     ];
+     
+     // If query has business context, require much stronger geographic indicators
+     const hasBusinessContext = businessContextPatterns.some(pattern: any => pattern.test(query));
+     
+     const allPatterns = [
+       ...geoPrepositions,
+       ...geoComparisons, 
+       ...locationCodes,
+       ...geoAnalysisTerms,
@@ lines 714-727 @@
-       ...locationTerms
-     ];
-     
-     const hasGeographicPatterns = allPatterns.some(pattern => pattern.test(query));
-     
-     // If business context detected, only allow geographic filtering with explicit geographic patterns
-     if (hasBusinessContext) {
-       console.log(`🚫 [GEO DEBUG] Business context detected - requiring explicit geographic indicators`);
-       // For business queries, require explicit geographic prepositions or location codes
-       const explicitGeoPatterns = [...geoPrepositions, ...locationCodes];
-       const hasExplicitGeo = explicitGeoPatterns.some(pattern => pattern.test(query));
-       console.log(`🚫 [GEO DEBUG] Explicit geographic patterns found: ${hasExplicitGeo}`);
-       return hasExplicitGeo;
-     }
---
+       ...locationTerms
+     ];
+     
+     const hasGeographicPatterns = allPatterns.some(pattern: any => pattern.test(query));
+     
+     // If business context detected, only allow geographic filtering with explicit geographic patterns
+     if (hasBusinessContext) {
+       console.log(`🚫 [GEO DEBUG] Business context detected - requiring explicit geographic indicators`);
+       // For business queries, require explicit geographic prepositions or location codes
+       const explicitGeoPatterns = [...geoPrepositions, ...locationCodes];
+       const hasExplicitGeo = explicitGeoPatterns.some(pattern: any => pattern.test(query));
+       console.log(`🚫 [GEO DEBUG] Explicit geographic patterns found: ${hasExplicitGeo}`);
+       return hasExplicitGeo;
+     }
+     
+     console.log(`✅ [GEO DEBUG] No business context - using standard geographic detection`);
+     console.log(`✅ [GEO DEBUG] Geographic patterns: ${hasGeographicPatterns}, Known entities: ${hasKnownGeographicEntity}`);
@@ lines 793-799 @@
-       /\b(northern|southern|eastern|western)\s+[a-z]+/i
-     ];
-     
-     return strongSignals.some(pattern => pattern.test(query));
-   }
- 
-   /**
---
+       /\b(northern|southern|eastern|western)\s+[a-z]+/i
+     ];
+     
+     return strongSignals.some(pattern: any => pattern.test(query));
+   }
+ 
+   /**
+    * Find direct matches in geographic hierarchy
+    */
+   private findDirectMatches(query: string): GeographicEntity[] {
@@ lines 847-864 @@
-     if (matches.length <= 1) return matches;
-     
-     // Remove exact duplicates
-     const uniqueMatches = matches.filter((match, index, self) => 
-       index === self.findIndex(m => m.name === match.name && m.type === match.type)
-     );
-     
-     // For Quebec/Quebec City case, prioritize the more specific match
-     const cityMatches = uniqueMatches.filter(m => m.type === 'city');
-     const stateMatches = uniqueMatches.filter(m => m.type === 'state');
-     
-     // If we have both "Quebec City" (city) and "Quebec" (state), prefer the city
-     if (cityMatches.some(m => m.name.toLowerCase().includes('quebec')) && 
-         stateMatches.some(m => m.name.toLowerCase() === 'quebec')) {
-       return uniqueMatches.filter(m => !(m.type === 'state' && m.name.toLowerCase() === 'quebec'));
-     }
-     
-     return uniqueMatches;
---
+     if (matches.length <= 1) return matches;
+     
+     // Remove exact duplicates
+     const uniqueMatches = matches.filter((match: any, index: any, self: any) => 
+       index === self.findIndex(m: any => m.name === match.name && m.type === match.type)
+     );
+     
+     // For Quebec/Quebec City case, prioritize the more specific match
+     const cityMatches = uniqueMatches.filter(m: any => m.type === 'city');
+     const stateMatches = uniqueMatches.filter(m: any => m.type === 'state');
+     
+     // If we have both "Quebec City" (city) and "Quebec" (state), prefer the city
+     if (cityMatches.some(m: any => m.name.toLowerCase().includes('quebec')) && 
+         stateMatches.some(m: any => m.name.toLowerCase() === 'quebec')) {
+       return uniqueMatches.filter(m: any => !(m.type === 'state' && m.name.toLowerCase() === 'quebec'));
+     }
+     
+     return uniqueMatches;
+   }
+ 
+   /**
@@ lines 974-980 @@
-     ];
-     
-     const lowerQuery = query.toLowerCase();
-     return regionalKeywords.some(keyword => lowerQuery.includes(keyword));
-   }
- 
-   /**
---
+     ];
+     
+     const lowerQuery = query.toLowerCase();
+     return regionalKeywords.some(keyword: any => lowerQuery.includes(keyword));
+   }
+ 
+   /**
+    * Check if query is about proximity
+    */
+   private isProximityQuery(query: string): boolean {
@@ lines 983-989 @@
-   private isProximityQuery(query: string): boolean {
-     const proximityKeywords = ['near', 'around', 'close to', 'within', 'nearby', 'radius'];
-     const lowerQuery = query.toLowerCase();
-     return proximityKeywords.some(keyword => lowerQuery.includes(keyword));
-   }
- 
-   /**
---
+   private isProximityQuery(query: string): boolean {
+     const proximityKeywords = ['near', 'around', 'close to', 'within', 'nearby', 'radius'];
+     const lowerQuery = query.toLowerCase();
+     return proximityKeywords.some(keyword: any => lowerQuery.includes(keyword));
+   }
+ 
+   /**
+    * Determine spatial relationship from query
+    */
+   private determineSpatialRelation(query: string): 'within' | 'near' | 'contains' | 'intersects' | undefined {
@@ lines 1026-1032 @@
-    */
-   private deduplicateEntities(entities: GeographicEntity[]): GeographicEntity[] {
-     const seen = new Set<string>();
-     const filtered = entities.filter(entity => {
-       const key = entity.name.toLowerCase();
-       if (seen.has(key)) {
-         return false;
---
+    */
+   private deduplicateEntities(entities: GeographicEntity[]): GeographicEntity[] {
+     const seen = new Set<string>();
+     const filtered = entities.filter(entity: any => {
+       const key = entity.name.toLowerCase();
+       if (seen.has(key)) {
+         return false;
+       }
+       seen.add(key);
+       return true;
@@ lines 1037-1046 @@
-     
-     // Additional filtering: if we have both a city and its parent region, keep only the city
-     // This prevents matching both "Montreal" city and "Montréal" region
-   const cityNames = new Set(filtered.filter(e => e.type === 'city').map(e => e.name.toLowerCase()));
-   const cityNamesArr = Array.from(cityNames);
- 
-   return filtered.filter(entity => {
-       // If this is a region/county and we have a city with a similar name, exclude the region
-       if (entity.type === 'county' || entity.type === 'state') {
-         const entityNameBase = entity.name.toLowerCase().replace(/[éèêë]/g, 'e').replace(/[àâä]/g, 'a');
---
+     
+     // Additional filtering: if we have both a city and its parent region, keep only the city
+     // This prevents matching both "Montreal" city and "Montréal" region
+   const cityNames = new Set(filtered.filter(e: any => e.type === 'city').map(e: any => e.name.toLowerCase()));
+   const cityNamesArr = Array.from(cityNames);
+ 
+   return filtered.filter(entity: any => {
+       // If this is a region/county and we have a city with a similar name, exclude the region
+       if (entity.type === 'county' || entity.type === 'state') {
+         const entityNameBase = entity.name.toLowerCase().replace(/[éèêë]/g, 'e').replace(/[àâä]/g, 'a');
+         for (const cityName of cityNamesArr) {
+           const cityNameBase = cityName.replace(/[éèêë]/g, 'e').replace(/[àâä]/g, 'a');
+           // If the city and region names are similar (e.g., "Montreal" and "Montréal"), keep only the city
@@ lines 1089-1095 @@
-       // Check description match with validation
-       const description = this.extractDescription(record);
-       const patterns = this.createDescriptionPatterns(entity);
-       if (patterns.some(pattern => pattern.test(description))) {
-         // Additional validation for description matches
-         if (this.isValidLocationMatch(description, entity.name, entity)) {
-           return true;
---
+       // Check description match with validation
+       const description = this.extractDescription(record);
+       const patterns = this.createDescriptionPatterns(entity);
+       if (patterns.some(pattern: any => pattern.test(description))) {
+         // Additional validation for description matches
+         if (this.isValidLocationMatch(description, entity.name, entity)) {
+           return true;
+         }
+       }
+       
@@ lines 1125-1143 @@
-     
-     // Get state information for this entity
-     const stateInfo = this.getStateInfo(entity);
-     const validStates = [...stateInfo.abbreviations, ...stateInfo.fullNames].map(s => s.toLowerCase());
-     
-     // Reject if it's clearly a street name or other geographic false positive
-     const streetSuffixes = ['avenue', 'street', 'road', 'boulevard', 'drive', 'lane', 'way', 'court', 'place'];
-     const rejectPatterns = streetSuffixes.map(suffix => 
-       new RegExp(`\\b${locationLower}\\s+${suffix}\\b`, 'i')
-     );
-     
-     // Also reject if it's the same city name in a different state or business name
-     const otherStateAbbrevs = ['al', 'ak', 'az', 'ar', 'ca', 'co', 'ct', 'de', 'fl', 'ga', 'hi', 'id', 'il', 'in', 'ia', 'ks', 'ky', 'la', 'me', 'md', 'ma', 'mi', 'mn', 'ms', 'mo', 'mt', 'ne', 'nv', 'nh', 'nm', 'nc', 'nd', 'oh', 'ok', 'or', 'ri', 'sc', 'sd', 'tn', 'tx', 'ut', 'vt', 'va', 'wa', 'wv', 'wi', 'wy'];
-     const invalidStatePatterns = otherStateAbbrevs
-       .filter(state => !validStates.includes(state))
-       .map(state => new RegExp(`\\b${locationLower}\\s*,\\s*(${state})\\b`, 'i'));
-     
-     // Reject business/restaurant names that just happen to include city names
-     const businessPatterns = [
---
+     
+     // Get state information for this entity
+     const stateInfo = this.getStateInfo(entity);
+     const validStates = [...stateInfo.abbreviations, ...stateInfo.fullNames].map(s: any => s.toLowerCase());
+     
+     // Reject if it's clearly a street name or other geographic false positive
+     const streetSuffixes = ['avenue', 'street', 'road', 'boulevard', 'drive', 'lane', 'way', 'court', 'place'];
+     const rejectPatterns = streetSuffixes.map(suffix: any => 
+       new RegExp(`\\b${locationLower}\\s+${suffix}\\b`, 'i')
+     );
+     
+     // Also reject if it's the same city name in a different state or business name
+     const otherStateAbbrevs = ['al', 'ak', 'az', 'ar', 'ca', 'co', 'ct', 'de', 'fl', 'ga', 'hi', 'id', 'il', 'in', 'ia', 'ks', 'ky', 'la', 'me', 'md', 'ma', 'mi', 'mn', 'ms', 'mo', 'mt', 'ne', 'nv', 'nh', 'nm', 'nc', 'nd', 'oh', 'ok', 'or', 'ri', 'sc', 'sd', 'tn', 'tx', 'ut', 'vt', 'va', 'wa', 'wv', 'wi', 'wy'];
+     const invalidStatePatterns = otherStateAbbrevs
+       .filter(state: any => !validStates.includes(state))
+       .map(state: any => new RegExp(`\\b${locationLower}\\s*,\\s*(${state})\\b`, 'i'));
+     
+     // Reject business/restaurant names that just happen to include city names
+     const businessPatterns = [
+       new RegExp(`\\b${locationLower}\\s+(restaurant|diner|cafe|bar|grill|wild wings|pizza|burger|wings)\\b`, 'i'),
+       new RegExp(`\\b${locationLower}\\s+(hotel|motel|inn|lodge|resort)\\b`, 'i'),
+       new RegExp(`\\b${locationLower}\\s+(mall|shopping|outlet|center|plaza)\\b`, 'i')
@@ lines 1147-1164 @@
-     ];
-     
-     // Check for obvious false positives
-     if (rejectPatterns.some(pattern => pattern.test(textLower)) ||
-         invalidStatePatterns.some(pattern => pattern.test(textLower)) ||
-         businessPatterns.some(pattern => pattern.test(textLower))) {
-       return false;
-     }
-     
-     // Accept if it has proper state context
-     const validStatePatterns = validStates.map(state => 
-       new RegExp(`\\b${locationLower}\\s*,\\s*${state}\\b`, 'i')
-     );
-     
-     if (validStatePatterns.some(pattern => pattern.test(textLower))) {
-       return true;
-     }
-     
---
+     ];
+     
+     // Check for obvious false positives
+     if (rejectPatterns.some(pattern: any => pattern.test(textLower)) ||
+         invalidStatePatterns.some(pattern: any => pattern.test(textLower)) ||
+         businessPatterns.some(pattern: any => pattern.test(textLower))) {
+       return false;
+     }
+     
+     // Accept if it has proper state context
+     const validStatePatterns = validStates.map(state: any => 
+       new RegExp(`\\b${locationLower}\\s*,\\s*${state}\\b`, 'i')
+     );
+     
+     if (validStatePatterns.some(pattern: any => pattern.test(textLower))) {
+       return true;
+     }
+     
+     // Accept if it appears with parenthetical or comma context indicating it's a place
+     const contextPatterns = [
+       new RegExp(`\\(${locationLower}\\)`, 'i'),  // (CityName)
@@ lines 1169-1175 @@
-       new RegExp(`\\b${locationLower}\\)`, 'i'),  // CityName)
-     ];
-     
-     if (contextPatterns.some(pattern => pattern.test(textLower))) {
-       return true;
-     }
-     
---
+       new RegExp(`\\b${locationLower}\\)`, 'i'),  // CityName)
+     ];
+     
+     if (contextPatterns.some(pattern: any => pattern.test(textLower))) {
+       return true;
+     }
+     
+     // For cities/boroughs, also check for neighborhood context
+     if (entity.type === 'city' || entity.type === 'borough') {
+       const neighborhoodContext = this.hasNeighborhoodContext(textLower, locationLower);
@@ lines 1193-1199 @@
-     const neighborhoodWords = ['downtown', 'uptown', 'midtown', 'center city', 'old city', 'university city', 
-                                'heights', 'village', 'district', 'neighborhood', 'area'];
-     
-     return neighborhoodWords.some(word => 
-       text.includes(`${word} ${cityName}`) || 
-       text.includes(`${cityName} ${word}`) ||
-       text.includes(`${word}, ${cityName}`) ||
---
+     const neighborhoodWords = ['downtown', 'uptown', 'midtown', 'center city', 'old city', 'university city', 
+                                'heights', 'village', 'district', 'neighborhood', 'area'];
+     
+     return neighborhoodWords.some(word: any => 
+       text.includes(`${word} ${cityName}`) || 
+       text.includes(`${cityName} ${word}`) ||
+       text.includes(`${word}, ${cityName}`) ||
+       text.includes(`${cityName}, ${word}`)
+     );
+   }
@@ lines 1206-1212 @@
-    */
-   private deduplicateRecords(records: any[]): any[] {
-     const seen = new Set<string>();
-     return records.filter(record => {
-       const key = record.area_id || record.id || JSON.stringify(record);
-       if (seen.has(key)) {
-         return false;
---
+    */
+   private deduplicateRecords(records: any[]): any[] {
+     const seen = new Set<string>();
+     return records.filter(record: any => {
+       const key = record.area_id || record.id || JSON.stringify(record);
+       if (seen.has(key)) {
+         return false;
+       }
+       seen.add(key);
+       return true;
@@ lines 1264-1270 @@
-         patterns.push(new RegExp(`\\b${this.escapeRegex(entity.name)}\\b`, 'i'));
-         
-         // Alias patterns
-         entity.aliases.forEach(alias => {
-           patterns.push(new RegExp(`\\b${this.escapeRegex(alias)}\\b`, 'i'));
-         });
-       } else {
---
+         patterns.push(new RegExp(`\\b${this.escapeRegex(entity.name)}\\b`, 'i'));
+         
+         // Alias patterns
+         entity.aliases.forEach(alias: any => {
+           patterns.push(new RegExp(`\\b${this.escapeRegex(alias)}\\b`, 'i'));
+         });
+       } else {
+         // For cities/boroughs without specific patterns, require stricter context
+         patterns.push(new RegExp(`\\b${this.escapeRegex(entity.name)}\\s*,\\s*[A-Z]{2}\\b`, 'i'));  // "City, ST"
+         patterns.push(new RegExp(`\\(${this.escapeRegex(entity.name)}\\)`, 'i'));  // "(City)"
@@ lines 1358-1364 @@
-     
-     const neighborhoods = cityNeighborhoods[entity.name.toLowerCase()];
-     if (neighborhoods) {
-       neighborhoods.forEach(neighborhood => {
-         patterns.push(new RegExp(`\\b${neighborhood}.*${entityName}\\b`, 'i'));
-         patterns.push(new RegExp(`\\b${entityName}.*${neighborhood}\\b`, 'i'));
-       });
---
+     
+     const neighborhoods = cityNeighborhoods[entity.name.toLowerCase()];
+     if (neighborhoods) {
+       neighborhoods.forEach(neighborhood: any => {
+         patterns.push(new RegExp(`\\b${neighborhood}.*${entityName}\\b`, 'i'));
+         patterns.push(new RegExp(`\\b${entityName}.*${neighborhood}\\b`, 'i'));
+       });
+     }
+     
+     return patterns;
@@ lines 1425-1431 @@
-    */
-   private fuzzyMatchRecord(record: any, entity: GeographicEntity): boolean {
-     const allText = this.extractAllTextFields(record).toLowerCase();
-     const searchTerms = [entity.name, ...entity.aliases].map(term => term.toLowerCase());
-     
-     for (const term of searchTerms) {
-       // Check for partial matches with edit distance
---
+    */
+   private fuzzyMatchRecord(record: any, entity: GeographicEntity): boolean {
+     const allText = this.extractAllTextFields(record).toLowerCase();
+     const searchTerms = [entity.name, ...entity.aliases].map(term: any => term.toLowerCase());
+     
+     for (const term of searchTerms) {
+       // Check for partial matches with edit distance
+       const words = allText.split(/\s+/);
+       for (const word of words) {
+         if (word.length >= 3 && term.length >= 3) {


*** FILE: utils/visualizations/correlation-visualization.ts
@@ lines 201-207 @@
-     errorMessage += `Available fields: ${availableFields.join(', ')}\n`;
-     
-     // Add suggestions if there are similar field names
-     const similarFields = availableFields.filter(field => 
-       field.toLowerCase().includes(fieldName.toLowerCase()) || 
-       fieldName.toLowerCase().includes(field.toLowerCase())
-     );
---
+     errorMessage += `Available fields: ${availableFields.join(', ')}\n`;
+     
+     // Add suggestions if there are similar field names
+     const similarFields = availableFields.filter(field: any => 
+       field.toLowerCase().includes(fieldName.toLowerCase()) || 
+       fieldName.toLowerCase().includes(field.toLowerCase())
+     );
+     if (similarFields.length > 0) {
+       errorMessage += `\nSimilar fields found: ${similarFields.join(', ')}`;
+       errorMessage += `\nPlease verify the correct field name in your layer configuration.`;
@@ lines 244-250 @@
-     });
- 
-     // Validate that fields exist in features
-     const primaryExists = data.features.some(f => {
-       const attrs = f.attributes || {};
-       const exists = attrs[data.rendererField] != null;
-       if (!exists) {
---
+     });
+ 
+     // Validate that fields exist in features
+     const primaryExists = data.features.some(f: any => {
+       const attrs = f.attributes || {};
+       const exists = attrs[data.rendererField] != null;
+       if (!exists) {
+         console.warn(`[CorrViz ValidateData] Primary field "${data.rendererField}" not found in feature. Available fields:`, Object.keys(attrs));
+       }
+       return exists;
@@ lines 253-259 @@
-       return exists;
-     });
- 
-     const comparisonExists = data.features.some(f => {
-       const attrs = f.attributes || {};
-       const exists = attrs[data.rendererField] != null;
-       if (!exists) {
---
+       return exists;
+     });
+ 
+     const comparisonExists = data.features.some(f: any => {
+       const attrs = f.attributes || {};
+       const exists = attrs[data.rendererField] != null;
+       if (!exists) {
+         console.warn(`[CorrViz ValidateData] Comparison field "${data.rendererField}" not found in feature. Available fields:`, Object.keys(attrs));
+       }
+       return exists;
@@ lines 318-332 @@
- 
-   private normalizeFeatures(features: any[], fields: string[]): NormalizedData {
-     // First pass: collect min/max values for each field
-     const minMaxValues = fields.reduce((acc, field) => {
-       acc[field] = { min: Infinity, max: -Infinity };
-       return acc;
-     }, {} as Record<string, { min: number; max: number }>);
- 
-     // Collect valid values for each field
-     features.forEach(feature => {
-       const values = feature.properties || feature.attributes || {};
-       fields.forEach(field => {
-         const value = this.parseNumericValue(values[field]);
-         if (value !== null) {
-           minMaxValues[field].min = Math.min(minMaxValues[field].min, value);
---
+ 
+   private normalizeFeatures(features: any[], fields: string[]): NormalizedData {
+     // First pass: collect min/max values for each field
+     const minMaxValues = fields.reduce((acc: any, field: any) => {
+       acc[field] = { min: Infinity, max: -Infinity };
+       return acc;
+     }, {} as Record<string, { min: number; max: number }>);
+ 
+     // Collect valid values for each field
+     features.forEach(feature: any => {
+       const values = feature.properties || feature.attributes || {};
+       fields.forEach(field: any => {
+         const value = this.parseNumericValue(values[field]);
+         if (value !== null) {
+           minMaxValues[field].min = Math.min(minMaxValues[field].min, value);
+           minMaxValues[field].max = Math.max(minMaxValues[field].max, value);
+         }
+       });
@@ lines 336-346 @@
-     });
- 
-     // Second pass: normalize values
-     const normalizedFeatures: NormalizedFeature[] = features.map(feature => {
-       const values = feature.properties || feature.attributes || {};
-       const normalizedProps: Record<string, any> = { ...values };
- 
-       fields.forEach(field => {
-         const value = this.parseNumericValue(values[field]);
-         if (value !== null) {
-           normalizedProps[`${field}_normalized`] = this.normalizeValue(
---
+     });
+ 
+     // Second pass: normalize values
+     const normalizedFeatures: NormalizedFeature[] = features.map(feature: any => {
+       const values = feature.properties || feature.attributes || {};
+       const normalizedProps: Record<string, any> = { ...values };
+ 
+       fields.forEach(field: any => {
+         const value = this.parseNumericValue(values[field]);
+         if (value !== null) {
+           normalizedProps[`${field}_normalized`] = this.normalizeValue(
+             value,
+             minMaxValues[field].min,
+             minMaxValues[field].max
@@ lines 391-397 @@
-     const comparisonField = 'comparison_value';
- 
-     // Filter out features that do not contain both numeric values
-     const validFeatures = features.filter(feature => {
-       const attrs = feature.attributes;
-       if (!attrs) return false;
-       const pVal = this.parseNumericValue(attrs[primaryField]);
---
+     const comparisonField = 'comparison_value';
+ 
+     // Filter out features that do not contain both numeric values
+     const validFeatures = features.filter(feature: any => {
+       const attrs = feature.attributes;
+       if (!attrs) return false;
+       const pVal = this.parseNumericValue(attrs[primaryField]);
+       const cVal = this.parseNumericValue(attrs[comparisonField]);
+       return pVal !== null && cVal !== null;
+     });
@@ lines 405-411 @@
-     }
- 
-     // First convert all valid input features to ArcGIS Graphics (without correlation score)
-     const graphics: Graphic[] = validFeatures.map((feature, idx) => {
-       let geometry = feature.geometry;
- 
-       // Skip if no geometry
---
+     }
+ 
+     // First convert all valid input features to ArcGIS Graphics (without correlation score)
+     const graphics: Graphic[] = validFeatures.map((feature: any, idx: any) => {
+       let geometry = feature.geometry;
+ 
+       // Skip if no geometry
+       if (!geometry) return null as unknown as Graphic;
+ 
+       // Reproject to WebMercator if required
@@ lines 437-443 @@
-     const scores = this.calculateCorrelationScores(graphics, primaryField, comparisonField);
- 
-     // Attach correlation_score attribute to each graphic (fallback to 0 if null/undefined)
-     graphics.forEach((g, i) => {
-       const score = scores[i];
-       g.attributes.correlation_score = (score === null || score === undefined || isNaN(score)) ? 0 : score;
-     });
---
+     const scores = this.calculateCorrelationScores(graphics, primaryField, comparisonField);
+ 
+     // Attach correlation_score attribute to each graphic (fallback to 0 if null/undefined)
+     graphics.forEach((g: any, i: any) => {
+       const score = scores[i];
+       g.attributes.correlation_score = (score === null || score === undefined || isNaN(score)) ? 0 : score;
+     });
+ 
+     console.log(`[CorrViz] Processed ${graphics.length} graphics with correlation scores.`);
+ 
@@ lines 457-464 @@
-       return [];
-     }
- 
-     const values1 = features.map(f => this.parseNumericValue(f.attributes?.[field1])).filter(v => v !== null) as number[];
-     const values2 = features.map(f => this.parseNumericValue(f.attributes?.[field2])).filter(v => v !== null) as number[];
- 
-     if (values1.length !== values2.length || values1.length < 2) {
-       console.warn('[CorrViz] Not enough data to calculate correlation scores reliably.');
---
+       return [];
+     }
+ 
+     const values1 = features.map(f: any => this.parseNumericValue(f.attributes?.[field1])).filter(v: any => v !== null) as number[];
+     const values2 = features.map(f: any => this.parseNumericValue(f.attributes?.[field2])).filter(v: any => v !== null) as number[];
+ 
+     if (values1.length !== values2.length || values1.length < 2) {
+       console.warn('[CorrViz] Not enough data to calculate correlation scores reliably.');
+       return features.map(() => 0.5); // Return a neutral score
+     }
+ 
@@ lines 473-479 @@
-     const pearson = this.calculatePearsonCorrelation(values1, values2);
-     console.log(`[CorrViz] Pearson correlation coefficient: ${pearson}`);
- 
-     return features.map(feature => {
-       const val1 = this.parseNumericValue(feature.attributes?.[field1]);
-       const val2 = this.parseNumericValue(feature.attributes?.[field2]);
- 
---
+     const pearson = this.calculatePearsonCorrelation(values1, values2);
+     console.log(`[CorrViz] Pearson correlation coefficient: ${pearson}`);
+ 
+     return features.map(feature: any => {
+       const val1 = this.parseNumericValue(feature.attributes?.[field1]);
+       const val2 = this.parseNumericValue(feature.attributes?.[field2]);
+ 
+       if (val1 === null || val2 === null) return null;
+ 
+       // Normalize values to a 0-1 range
@@ lines 499-509 @@
-     }
- 
-     const n = x.length;
-     const sumX = x.reduce((a, b) => a + b, 0);
-     const sumY = y.reduce((a, b) => a + b, 0);
-     const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
-     const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
-     const sumY2 = y.reduce((sum, val) => sum + val * val, 0);
- 
-     const numerator = n * sumXY - sumX * sumY;
-     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
---
+     }
+ 
+     const n = x.length;
+     const sumX = x.reduce((a: any, b: any) => a + b, 0);
+     const sumY = y.reduce((a: any, b: any) => a + b, 0);
+     const sumXY = x.reduce((sum: any, val: any, i: any) => sum + val * y[i], 0);
+     const sumX2 = x.reduce((sum: any, val: any) => sum + val * val, 0);
+     const sumY2 = y.reduce((sum: any, val: any) => sum + val * val, 0);
+ 
+     const numerator = n * sumXY - sumX * sumY;
+     const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
+ 
+     return denominator === 0 ? 0 : numerator / denominator;
+   }
@@ lines 577-586 @@
-     const inputRecords = (response as any).inputRecords || (response as any).records || (response as any).data || [];
- 
-     // Create features array from predictions and SHAP values
-     const features = data.predictions.map((prediction, index) => {
-       const record = inputRecords[index] || {};
-       const shapValues = data.shapValues[index] || [];
-       const totalImpact = shapValues.reduce((sum, val) => sum + Math.abs(val), 0);
-       return {
-         attributes: {
-           ID: record.ID, // <-- Add ID from the microservice data
---
+     const inputRecords = (response as any).inputRecords || (response as any).records || (response as any).data || [];
+ 
+     // Create features array from predictions and SHAP values
+     const features = data.predictions.map((prediction: any, index: any) => {
+       const record = inputRecords[index] || {};
+       const shapValues = data.shapValues[index] || [];
+       const totalImpact = shapValues.reduce((sum: any, val: any) => sum + Math.abs(val), 0);
+       return {
+         attributes: {
+           ID: record.ID, // <-- Add ID from the microservice data
+           OBJECTID: index + 1,
+           primary_value: prediction,
+           comparison_value: totalImpact,
@@ lines 590-596 @@
-           correlation_strength: Math.abs(prediction - totalImpact),
-           // Add SHAP values as additional attributes
-           ...Object.fromEntries(
-             data.featureNames.map((name, i) => [
-               `shap_${name}`,
-               shapValues[i] || 0
-             ])
---
+           correlation_strength: Math.abs(prediction - totalImpact),
+           // Add SHAP values as additional attributes
+           ...Object.fromEntries(
+             data.featureNames.map((name: any, i: any) => [
+               `shap_${name}`,
+               shapValues[i] || 0
+             ])
+           ),
+           ...record // Optionally include all other fields from the record
+         }
@@ lines 615-621 @@
-           { name: 'primary_value', type: 'double' as FieldType },
-           { name: 'comparison_value', type: 'double' as FieldType },
-           { name: 'correlation_strength', type: 'double' as FieldType },
-           ...data.featureNames.map(name => ({
-             name: `shap_${name}`,
-             type: 'double' as FieldType
-           })),
---
+           { name: 'primary_value', type: 'double' as FieldType },
+           { name: 'comparison_value', type: 'double' as FieldType },
+           { name: 'correlation_strength', type: 'double' as FieldType },
+           ...data.featureNames.map(name: any => ({
+             name: `shap_${name}`,
+             type: 'double' as FieldType
+           })),
+           { name: 'ID', type: 'string' as FieldType },
+         ]
+       }
@@ lines 750-762 @@
- 
-     // Get all correlation scores and sort them
-     const scores = graphics
-       .map(g => g.attributes.correlation_score)
-       .filter((score): score is number => typeof score === 'number' && !isNaN(score))
-       .sort((a, b) => a - b);
- 
-     // Recompute quartile breaks using unique score values to prevent duplicate class ranges
-     const uniq = Array.from(new Set(scores));
-     uniq.sort((a,b)=>a-b);
- 
-     const pickPercentile = (p:number) => {
-       if (uniq.length===0) return 0;
---
+ 
+     // Get all correlation scores and sort them
+     const scores = graphics
+       .map(g: any => g.attributes.correlation_score)
+       .filter((score: any): score is number => typeof score === 'number' && !isNaN(score))
+       .sort((a: any, b: any) => a - b);
+ 
+     // Recompute quartile breaks using unique score values to prevent duplicate class ranges
+     const uniq = Array.from(new Set(scores));
+     uniq.sort((a: any,b: any)=>a-b);
+ 
+     const pickPercentile = (p:number) => {
+       if (uniq.length===0) return 0;
+       const idx = (uniq.length - 1) * p;
+       const lower = Math.floor(idx);
+       const upper = Math.ceil(idx);
@@ lines 772-779 @@
-     let q3 = pickPercentile(0.75);
- 
-     // Ensure strictly increasing break values to avoid 0-width classes
-     if (q2 <= q1) q2 = uniq.find(v=>v>q1) ?? q1;
-     if (q3 <= q2) q3 = uniq.find(v=>v>q2) ?? q2;
- 
-     const minScore = uniq[0] ?? 0;
-     const maxScore = uniq[uniq.length-1] ?? 1;
---
+     let q3 = pickPercentile(0.75);
+ 
+     // Ensure strictly increasing break values to avoid 0-width classes
+     if (q2 <= q1) q2 = uniq.find(v: any=>v>q1) ?? q1;
+     if (q3 <= q2) q3 = uniq.find(v: any=>v>q2) ?? q2;
+ 
+     const minScore = uniq[0] ?? 0;
+     const maxScore = uniq[uniq.length-1] ?? 1;
+       
+     console.log('[CorrelationVisualization] Quartile breaks:', { q1, q2, q3, minScore, maxScore });
+ 
@@ lines 781-787 @@
-     console.log('[CorrelationVisualization] Quartile breaks:', { q1, q2, q3, minScore, maxScore });
- 
-     // Ensure each graphic has a unique OBJECTID
-     const graphicsWithIds = graphics.map((graphic, index) => {
-         return new Graphic({
-           geometry: graphic.geometry,
-           attributes: {
---
+     console.log('[CorrelationVisualization] Quartile breaks:', { q1, q2, q3, minScore, maxScore });
+ 
+     // Ensure each graphic has a unique OBJECTID
+     const graphicsWithIds = graphics.map((graphic: any, index: any) => {
+         return new Graphic({
+           geometry: graphic.geometry,
+           attributes: {
+             ...graphic.attributes,
+           OBJECTID: index + 1
+           }
@@ lines 865-871 @@
-     this.applyCorrelationPopupTemplate(layer);
-       
-     // Calculate extent from graphics
-     const geometries = graphicsWithIds.map(g => g.geometry).filter(g => g != null);
-     if (geometries.length > 0) {
-       try {
-         const extent = await geometryEngineAsync.union(geometries as any[]);
---
+     this.applyCorrelationPopupTemplate(layer);
+       
+     // Calculate extent from graphics
+     const geometries = graphicsWithIds.map(g: any => g.geometry).filter(g: any => g != null);
+     if (geometries.length > 0) {
+       try {
+         const extent = await geometryEngineAsync.union(geometries as any[]);
+         this.extent = extent?.extent || null;
+       } catch (error) {
+         console.warn('[CorrelationVisualization] Error calculating extent:', error);
@@ lines 903-909 @@
-         title: `${primaryFieldName} vs ${comparisonFieldName}`,
-         type: 'class-breaks',
-         description: 'Correlation strength between metrics',
-         items: classBreaksRenderer.classBreakInfos.map(info => ({
-           label: info.label ?? '',
-           color: `rgba(${(info.symbol as SimpleFillSymbol).color.toRgba().join(',')})`
-         }))
---
+         title: `${primaryFieldName} vs ${comparisonFieldName}`,
+         type: 'class-breaks',
+         description: 'Correlation strength between metrics',
+         items: classBreaksRenderer.classBreakInfos.map(info: any => ({
+           label: info.label ?? '',
+           color: `rgba(${(info.symbol as SimpleFillSymbol).color.toRgba().join(',')})`
+         }))
+       };
+     }
+ 
@@ lines 947-953 @@
-     // Fallback: attempt to locate a layer that contains the field
-     if (fieldName) {
-       for (const cfg of Object.values(layers)) {
-         if (cfg.fields?.some(f => f.name === fieldName)) {
-           return cfg.name;
-         }
-       }
---
+     // Fallback: attempt to locate a layer that contains the field
+     if (fieldName) {
+       for (const cfg of Object.values(layers)) {
+         if (cfg.fields?.some(f: any => f.name === fieldName)) {
+           return cfg.name;
+         }
+       }
+ 
+       // If still not found, prettify the field name
+       const formatted = fieldName
@@ lines 955-961 @@
-       // If still not found, prettify the field name
-       const formatted = fieldName
-         .replace(/_/g, ' ')
-         .replace(/\b\w/g, l => l.toUpperCase())
-         .trim();
-       return formatted.replace('Fsa', 'FSA').replace('Id', 'ID');
-     }
---
+       // If still not found, prettify the field name
+       const formatted = fieldName
+         .replace(/_/g, ' ')
+         .replace(/\b\w/g, l: any => l.toUpperCase())
+         .trim();
+       return formatted.replace('Fsa', 'FSA').replace('Id', 'ID');
+     }
+ 
+     return null;
+   }
@@ lines 992-998 @@
-     return name
-       .replace(/_/g, ' ')
-       .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
-       .replace(/\b\w/g, l => l.toUpperCase())
-       .trim();
-   }
- 
---
+     return name
+       .replace(/_/g, ' ')
+       .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
+       .replace(/\b\w/g, l: any => l.toUpperCase())
+       .trim();
+   }
+ 
+   /** Lookup label/alias for a field, fall back to prettified name */
+   private _getFriendlyFieldName(layerId: string, fieldName: string): string {
+     return FieldMappingHelper.getFriendlyFieldName(fieldName, layerId);


*** FILE: lib/analysis/strategies/processors/BrandDifferenceProcessor.ts
@@ lines 43-52 @@
-     
-     // Brand difference analysis requires brand market share data OR direct brand-difference fields
-     const hasBrandFields = rawData.results.length === 0 || 
-       rawData.results.some(record => {
-         const hasIdField = record && ((record as any).area_id || (record as any).id || (record as any).ID);
-         const recordKeys = record ? Object.keys(record as any) : [];
-         const brandFields = recordKeys.filter(key => (key.includes('MP122') || key.includes('MP101')) && key.endsWith('A_B_P'));
-         // Accept simple pre-computed brand difference fields used in tests/data
-         const hasSimpleDifference = record && ((record as any).brand_difference_score !== undefined || (record as any).comparison_score !== undefined);
-         
---
+     
+     // Brand difference analysis requires brand market share data OR direct brand-difference fields
+     const hasBrandFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => {
+         const hasIdField = record && ((record as any).area_id || (record as any).id || (record as any).ID);
+         const recordKeys = record ? Object.keys(record as any) : [];
+         const brandFields = recordKeys.filter(key: any => (key.includes('MP122') || key.includes('MP101')) && key.endsWith('A_B_P'));
+         // Accept simple pre-computed brand difference fields used in tests/data
+         const hasSimpleDifference = record && ((record as any).brand_difference_score !== undefined || (record as any).comparison_score !== undefined);
+         
+         console.log('🔍 [BrandDifferenceProcessor] Validation debug for record:', {
+           hasRecord: !!record,
+           hasIdField,
@@ lines 83-89 @@
-     // Debug: Show available fields in first record
-     if (rawData.results && rawData.results.length > 0) {
-       const firstRecord = rawData.results[0];
-   const brandFields = Object.keys(firstRecord as any).filter(key => (key.includes('MP122') || key.includes('MP101')) && key.includes('_P'));
-       console.log(`[BrandDifferenceProcessor] Available brand fields in data:`, brandFields);
-     }
-     
---
+     // Debug: Show available fields in first record
+     if (rawData.results && rawData.results.length > 0) {
+       const firstRecord = rawData.results[0];
+   const brandFields = Object.keys(firstRecord as any).filter(key: any => (key.includes('MP122') || key.includes('MP101')) && key.includes('_P'));
+       console.log(`[BrandDifferenceProcessor] Available brand fields in data:`, brandFields);
+     }
+     
+     if (!this.validate(rawData)) {
+       throw new Error('Invalid data format for BrandDifferenceProcessor');
+     }
@@ lines 316-322 @@
-     
-     console.log(`[BrandDifferenceProcessor] Using fields: ${brand1Field} vs ${brand2Field}`);
- 
-     return rawRecords.map((record, index) => {
-       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
-       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
-       
---
+     
+     console.log(`[BrandDifferenceProcessor] Using fields: ${brand1Field} vs ${brand2Field}`);
+ 
+     return rawRecords.map((record: any, index: any) => {
+       const area_id = (record as any).area_id || (record as any).id || (record as any).GEOID || `area_${index}`;
+       const area_name = (record as any).value_DESCRIPTION || (record as any).DESCRIPTION || (record as any).area_name || (record as any).name || (record as any).NAME || `Area ${index + 1}`;
+       
+       // Extract brand market shares
+       const brand1Share = Number(record[brand1Field]) || 0; // Already in percentage format
+       const brand2Share = Number(record[brand2Field]) || 0; // Already in percentage format
@@ lines 366-373 @@
-         properties,
-         shapValues
-       };
-     }).sort((a, b) => b.value - a.value) // Sort by difference (brand1 advantage first)
-       .map((record, index) => ({ ...record, rank: index + 1 })); // Assign ranks
-   }
- 
-   private extractProperties(record: any): Record<string, any> {
---
+         properties,
+         shapValues
+       };
+     }).sort((a: any, b: any) => b.value - a.value) // Sort by difference (brand1 advantage first)
+       .map((record: any, index: any) => ({ ...record, rank: index + 1 })); // Assign ranks
+   }
+ 
+   private extractProperties(record: any): Record<string, any> {
+     const internalFields = new Set([
+       'area_id', 'id', 'area_name', 'name', 'coordinates', 'shap_values', 'brand_difference_score'
+     ]);
@@ lines 436-442 @@
-   }
- 
-   private calculateDifferenceStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const differences = records.map(r => r.value).filter(v => !isNaN(v));
-     
-     if (differences.length === 0) {
-       return {
---
+   }
+ 
+   private calculateDifferenceStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const differences = records.map(r: any => r.value).filter(v: any => !isNaN(v));
+     
+     if (differences.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         quintiles: { differences: [] } as any
+       };
@@ lines 445-460 @@
-       };
-     }
-     
-     const sorted = [...differences].sort((a, b) => a - b);
-     const total = differences.length;
-     const sum = differences.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = differences.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Calculate quintiles for differences
---
+       };
+     }
+     
+     const sorted = [...differences].sort((a: any, b: any) => a - b);
+     const total = differences.length;
+     const sum = differences.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = differences.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Calculate quintiles for differences
+     const quintileResult = calculateEqualCountQuintiles(sorted);
+     
+     console.log('[BrandDifferenceProcessor] Difference quintiles calculated:', quintileResult.quintiles);
@@ lines 479-485 @@
-     // Group by difference categories
-     const categoryMap = new Map<string, GeographicDataPoint[]>();
-     
-     records.forEach(record => {
-       const category = (record as any).category!;
-       if (!categoryMap.has(category)) {
-         categoryMap.set(category, []);
---
+     // Group by difference categories
+     const categoryMap = new Map<string, GeographicDataPoint[]>();
+     
+     records.forEach(record: any => {
+       const category = (record as any).category!;
+       if (!categoryMap.has(category)) {
+         categoryMap.set(category, []);
+       }
+       categoryMap.get(category)!.push(record);
+     });
@@ lines 489-497 @@
-     
-     // Analyze each category
-     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
-       const avgDifference = categoryRecords.reduce((sum, r) => sum + r.value, 0) / categoryRecords.length;
-       const avgBrand1Share = categoryRecords.reduce((sum, r) => sum + ((r.properties as any)[`${brand1}_market_share`] || 0), 0) / categoryRecords.length;
-       const avgBrand2Share = categoryRecords.reduce((sum, r) => sum + ((r.properties as any)[`${brand2}_market_share`] || 0), 0) / categoryRecords.length;
-       
-       return {
-         category,
---
+     
+     // Analyze each category
+     const categoryAnalysis = Array.from(categoryMap.entries()).map(([category, categoryRecords]) => {
+       const avgDifference = categoryRecords.reduce((sum: any, r: any) => sum + r.value, 0) / categoryRecords.length;
+       const avgBrand1Share = categoryRecords.reduce((sum: any, r: any) => sum + ((r.properties as any)[`${brand1}_market_share`] || 0), 0) / categoryRecords.length;
+       const avgBrand2Share = categoryRecords.reduce((sum: any, r: any) => sum + ((r.properties as any)[`${brand2}_market_share`] || 0), 0) / categoryRecords.length;
+       
+       return {
+         category,
+         size: categoryRecords.length,
+         percentage: (categoryRecords.length / records.length) * 100,
+         avgDifference,
@@ lines 501-509 @@
-         avgBrand1Share,
-         avgBrand2Share,
-         topAreas: categoryRecords
-           .sort((a, b) => Math.abs(b.value) - Math.abs(a.value))
-           .slice(0, 3)
-           .map(r => ({
-             name: r.area_name,
-             difference: r.value,
-             brand1Share: r.properties[`${brand1}_market_share`],
---
+         avgBrand1Share,
+         avgBrand2Share,
+         topAreas: categoryRecords
+           .sort((a: any, b: any) => Math.abs(b.value) - Math.abs(a.value))
+           .slice(0, 3)
+           .map(r: any => ({
+             name: r.area_name,
+             difference: r.value,
+             brand1Share: r.properties[`${brand1}_market_share`],
+             brand2Share: r.properties[`${brand2}_market_share`]
+           }))
+       };
@@ lines 521-529 @@
- 
-   // eslint-disable-next-line @typescript-eslint/no-unused-vars
-   private assessBrandLeadership(records: GeographicDataPoint[], brand1: string, brand2: string): any {
-     const brand1Leading = records.filter(r => r.value > 0).length;
-     const brand2Leading = records.filter(r => r.value < 0).length;
-     const competitive = records.filter(r => Math.abs(r.value) <= 5).length;
-     
-     return {
-       brand1Leading,
---
+ 
+   // eslint-disable-next-line @typescript-eslint/no-unused-vars
+   private assessBrandLeadership(records: GeographicDataPoint[], brand1: string, brand2: string): any {
+     const brand1Leading = records.filter(r: any => r.value > 0).length;
+     const brand2Leading = records.filter(r: any => r.value < 0).length;
+     const competitive = records.filter(r: any => Math.abs(r.value) <= 5).length;
+     
+     return {
+       brand1Leading,
+       brand2Leading,
+       competitive,
+       brand1LeadingPct: (brand1Leading / records.length) * 100,
@@ lines 536-543 @@
-   }
- 
-   private assessCompetitiveBalance(categoryAnalysis: any[]): string {
-     const strongBrand1 = categoryAnalysis.find(c => c.category === 'strong_brand1')?.percentage || 0;
-     const strongBrand2 = categoryAnalysis.find(c => c.category === 'strong_brand2')?.percentage || 0;
-     
-     if (strongBrand1 > 40) return 'brand1_dominance';
-     if (strongBrand2 > 40) return 'brand2_dominance';
---
+   }
+ 
+   private assessCompetitiveBalance(categoryAnalysis: any[]): string {
+     const strongBrand1 = categoryAnalysis.find(c: any => c.category === 'strong_brand1')?.percentage || 0;
+     const strongBrand2 = categoryAnalysis.find(c: any => c.category === 'strong_brand2')?.percentage || 0;
+     
+     if (strongBrand1 > 40) return 'brand1_dominance';
+     if (strongBrand2 > 40) return 'brand2_dominance';
+     if (Math.abs(strongBrand1 - strongBrand2) < 10) return 'balanced_competition';
+     return 'fragmented_market';
+   }
@@ lines 546-557 @@
-   }
- 
-   private processBrandFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getBrandFeatureDescription((item as any).feature || (item as any).name),
-       brandImpact: this.assessBrandImpact((item as any).importance || 0)
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getBrandFeatureDescription(featureName: string): string {
---
+   }
+ 
+   private processBrandFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getBrandFeatureDescription((item as any).feature || (item as any).name),
+       brandImpact: this.assessBrandImpact((item as any).importance || 0)
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getBrandFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'population': 'Market size and demographic density',
+       'income': 'Income levels affecting brand preference',
@@ lines 592-598 @@
-   ): string {
-     
-     const recordCount = records.length;
-     const avgDifference = records.reduce((sum, r) => sum + r.value, 0) / recordCount;
-     const brand1Name = brand1.charAt(0).toUpperCase() + brand1.slice(1);
-     const brand2Name = brand2.charAt(0).toUpperCase() + brand2.slice(1);
-     
---
+   ): string {
+     
+     const recordCount = records.length;
+     const avgDifference = records.reduce((sum: any, r: any) => sum + r.value, 0) / recordCount;
+     const brand1Name = brand1.charAt(0).toUpperCase() + brand1.slice(1);
+     const brand2Name = brand2.charAt(0).toUpperCase() + brand2.slice(1);
+     
+     let summary = `**📊 ${brand1Name} vs ${brand2Name} Market Share Difference Analysis**\n\n`;
+     
+     summary += `**Methodology:** Calculated market share difference between ${brand1Name} and ${brand2Name} across ${recordCount} markets (${brand1Name} % - ${brand2Name} %). `;
@@ lines 620-631 @@
-     summary += `with ${leadership.competitive} competitive markets (${leadership.competitivePct.toFixed(1)}%).\n\n`;
-     
-     // Top performance areas
-     const topBrand1Markets = records.filter(r => r.value > 20).slice(0, 5);
-     const topBrand2Markets = records.filter(r => r.value < -20).slice(0, 5);
-     
-     if (topBrand1Markets.length > 0) {
-       summary += `**${brand1Name} Strongholds** (>20% advantage): `;
-   topBrand1Markets.forEach((record) => {
-         const brand1Share = (record as any).properties[`${brand1}_market_share`];
-         const brand2Share = (record as any).properties[`${brand2}_market_share`];
-         summary += `${(record as any).area_name} (${brand1Share.toFixed(1)}% vs ${brand2Share.toFixed(1)}%), `;
---
+     summary += `with ${leadership.competitive} competitive markets (${leadership.competitivePct.toFixed(1)}%).\n\n`;
+     
+     // Top performance areas
+     const topBrand1Markets = records.filter(r: any => r.value > 20).slice(0, 5);
+     const topBrand2Markets = records.filter(r: any => r.value < -20).slice(0, 5);
+     
+     if (topBrand1Markets.length > 0) {
+       summary += `**${brand1Name} Strongholds** (>20% advantage): `;
+   topBrand1Markets.forEach((record: any) => {
+         const brand1Share = (record as any).properties[`${brand1}_market_share`];
+         const brand2Share = (record as any).properties[`${brand2}_market_share`];
+         summary += `${(record as any).area_name} (${brand1Share.toFixed(1)}% vs ${brand2Share.toFixed(1)}%), `;
+       });
+       summary = summary.slice(0, -2) + '.\n\n';
+     }
@@ lines 635-641 @@
-     
-     if (topBrand2Markets.length > 0) {
-       summary += `**${brand2Name} Strongholds** (>20% advantage): `;
-   topBrand2Markets.forEach((record) => {
-         const brand1Share = (record as any).properties[`${brand1}_market_share`];
-         const brand2Share = (record as any).properties[`${brand2}_market_share`];
-         summary += `${(record as any).area_name} (${brand2Share.toFixed(1)}% vs ${brand1Share.toFixed(1)}%), `;
---
+     
+     if (topBrand2Markets.length > 0) {
+       summary += `**${brand2Name} Strongholds** (>20% advantage): `;
+   topBrand2Markets.forEach((record: any) => {
+         const brand1Share = (record as any).properties[`${brand1}_market_share`];
+         const brand2Share = (record as any).properties[`${brand2}_market_share`];
+         summary += `${(record as any).area_name} (${brand2Share.toFixed(1)}% vs ${brand1Share.toFixed(1)}%), `;
+       });
+       summary = summary.slice(0, -2) + '.\n\n';
+     }
@@ lines 664-670 @@
-   // ============================================================================
- 
-   private createBrandDifferenceRenderer(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use diverging color scheme: red (brand2 advantage) -> green (brand1 advantage)
---
+   // ============================================================================
+ 
+   private createBrandDifferenceRenderer(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use diverging color scheme: red (brand2 advantage) -> green (brand1 advantage)
+     // Use standard 4-color quartile scheme like other processors
+     const differenceColors = [
+       [215, 48, 39, 0.6],   // #d73027 - Red (Strong brand2 advantage)
@@ lines 679-685 @@
-     return {
-       type: 'class-breaks',
-       field: 'brand_difference_score',
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+       field: 'brand_difference_score',
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: differenceColors[i],
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 698-704 @@
-   }
- 
-   private createBrandDifferenceLegend(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use standard 4-color quartile scheme in rgba format
---
+   }
+ 
+   private createBrandDifferenceLegend(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use standard 4-color quartile scheme in rgba format
+     const colors = [
+       'rgba(215, 48, 39, 0.6)',    // #d73027 - Red (Strong brand2 advantage)
+       'rgba(253, 174, 97, 0.6)',   // #fdae61 - Orange (Moderate brand2 advantage)


*** FILE: components/ProjectConfigManager/ConceptMappingEditor.tsx
@@ lines 134-143 @@
- 
-   // Filter concepts based on search and category
-   const filteredConcepts = useMemo(() => {
-     return concepts.filter(concept => {
-       const matchesSearch = concept.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
-                           concept.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
-                           concept.keywords.some(k => k.toLowerCase().includes(searchTerm.toLowerCase()));
-       const matchesCategory = filterCategory === 'all' || concept.category === filterCategory;
-       
-       return matchesSearch && matchesCategory;
---
+ 
+   // Filter concepts based on search and category
+   const filteredConcepts = useMemo(() => {
+     return concepts.filter(concept: any => {
+       const matchesSearch = concept.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
+                           concept.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
+                           concept.keywords.some(k: any => k.toLowerCase().includes(searchTerm.toLowerCase()));
+       const matchesCategory = filterCategory === 'all' || concept.category === filterCategory;
+       
+       return matchesSearch && matchesCategory;
+     });
+   }, [concepts, searchTerm, filterCategory]);
+ 
@@ lines 146-152 @@
- 
-   // Get active connections
-   const activeConnections = useMemo(() => {
-     return connections.filter(conn => conn.isActive || showInactiveMappings);
-   }, [connections, showInactiveMappings]);
- 
-   // Initialize default concepts
---
+ 
+   // Get active connections
+   const activeConnections = useMemo(() => {
+     return connections.filter(conn: any => conn.isActive || showInactiveMappings);
+   }, [connections, showInactiveMappings]);
+ 
+   // Initialize default concepts
+   useEffect(() => {
+     if (concepts.length === 0) {
+       const defaultConcepts: ConceptNode[] = [
@@ lines 242-252 @@
-       const newSuggestions: ConceptSuggestion[] = [];
-       
-       // Analyze groups for concept mapping opportunities
-       groups.forEach(group => {
-         concepts.forEach(concept => {
-           // Check if group name/description matches concept keywords
-           const groupText = `${group.name} ${group.description || ''}`.toLowerCase();
-           const matchingKeywords = concept.keywords.filter(keyword => 
-             groupText.includes(keyword.toLowerCase())
-           );
-           
---
+       const newSuggestions: ConceptSuggestion[] = [];
+       
+       // Analyze groups for concept mapping opportunities
+       groups.forEach(group: any => {
+         concepts.forEach(concept: any => {
+           // Check if group name/description matches concept keywords
+           const groupText = `${group.name} ${group.description || ''}`.toLowerCase();
+           const matchingKeywords = concept.keywords.filter(keyword: any => 
+             groupText.includes(keyword.toLowerCase())
+           );
+           
+           if (matchingKeywords.length > 0) {
+             const confidence = Math.min(0.95, (matchingKeywords.length / concept.keywords.length) * 0.8 + 0.2);
+             
@@ lines 254-265 @@
-             const confidence = Math.min(0.95, (matchingKeywords.length / concept.keywords.length) * 0.8 + 0.2);
-             
-             // Check if this mapping already exists
-             const existingConnection = connections.find(conn => 
-               conn.conceptId === concept.id && conn.targetId === group.id
-             );
-             
-             if (!existingConnection) {
-               let existingSuggestion = newSuggestions.find(s => s.conceptName === concept.name);
-               
-               if (!existingSuggestion) {
-                 existingSuggestion = {
---
+             const confidence = Math.min(0.95, (matchingKeywords.length / concept.keywords.length) * 0.8 + 0.2);
+             
+             // Check if this mapping already exists
+             const existingConnection = connections.find(conn: any => 
+               conn.conceptId === concept.id && conn.targetId === group.id
+             );
+             
+             if (!existingConnection) {
+               let existingSuggestion = newSuggestions.find(s: any => s.conceptName === concept.name);
+               
+               if (!existingSuggestion) {
+                 existingSuggestion = {
+                   id: `suggestion_${concept.id}`,
+                   conceptName: concept.name,
+                   description: concept.description,
@@ lines 286-292 @@
-       });
-       
-       // Sort suggestions by priority
-       newSuggestions.sort((a, b) => b.priority - a.priority);
-       
-       setSuggestions(newSuggestions);
-     } catch (error) {
---
+       });
+       
+       // Sort suggestions by priority
+       newSuggestions.sort((a: any, b: any) => b.priority - a.priority);
+       
+       setSuggestions(newSuggestions);
+     } catch (error) {
+       console.error('Error generating suggestions:', error);
+     } finally {
+       setIsGeneratingSuggestions(false);
@@ lines 297-303 @@
-   }, [groups, concepts, connections]);
- 
-   // Create concept mapping
-   const createMapping = useCallback((conceptId: string, targetId: string, targetType: 'group' | 'layer', strength = 0.8) => {
-     const newConnection: MappingConnection = {
-       id: `mapping_${Date.now()}`,
-       conceptId,
---
+   }, [groups, concepts, connections]);
+ 
+   // Create concept mapping
+   const createMapping = useCallback((conceptId: string, targetId: string, targetType: 'group' | 'layer', strength: any = 0.8) => {
+     const newConnection: MappingConnection = {
+       id: `mapping_${Date.now()}`,
+       conceptId,
+       targetId,
+       targetType,
+       strength,
@@ lines 313-319 @@
-   setConnections((prev: MappingConnection[] | undefined) => [...(prev || []), newConnection]);
-     
-     // Update concept mappings
-   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept => {
-       if (concept.id === conceptId) {
-         const updatedConcept = { ...concept };
-         if (targetType === 'group') {
---
+   setConnections((prev: MappingConnection[] | undefined) => [...(prev || []), newConnection]);
+     
+     // Update concept mappings
+   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept: any => {
+       if (concept.id === conceptId) {
+         const updatedConcept = { ...concept };
+         if (targetType === 'group') {
+           updatedConcept.mappedGroups = [...updatedConcept.mappedGroups, targetId];
+         } else {
+           updatedConcept.mappedLayers = [...updatedConcept.mappedLayers, targetId];
@@ lines 347-365 @@
- 
-   // Remove concept mapping
-   const removeMapping = useCallback((connectionId: string) => {
-     const connection = connections.find(c => c.id === connectionId);
-     if (!connection) return;
-     
-   setConnections((prev: MappingConnection[] | undefined) => (prev || []).filter(c => c.id !== connectionId));
-     
-     // Update concept mappings
-   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept => {
-       if (concept.id === connection.conceptId) {
-         const updatedConcept = { ...concept };
-         if (connection.targetType === 'group') {
-           updatedConcept.mappedGroups = updatedConcept.mappedGroups.filter(id => id !== connection.targetId);
-         } else {
-           updatedConcept.mappedLayers = updatedConcept.mappedLayers.filter(id => id !== connection.targetId);
-         }
-         return updatedConcept;
-       }
---
+ 
+   // Remove concept mapping
+   const removeMapping = useCallback((connectionId: string) => {
+     const connection = connections.find(c: any => c.id === connectionId);
+     if (!connection) return;
+     
+   setConnections((prev: MappingConnection[] | undefined) => (prev || []).filter(c: any => c.id !== connectionId));
+     
+     // Update concept mappings
+   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept: any => {
+       if (concept.id === connection.conceptId) {
+         const updatedConcept = { ...concept };
+         if (connection.targetType === 'group') {
+           updatedConcept.mappedGroups = updatedConcept.mappedGroups.filter(id: any => id !== connection.targetId);
+         } else {
+           updatedConcept.mappedLayers = updatedConcept.mappedLayers.filter(id: any => id !== connection.targetId);
+         }
+         return updatedConcept;
+       }
+       return concept;
+     }));
+     
@@ lines 369-375 @@
-     // Update project configuration
-     const updatedMappings = {
-       ...config.conceptMappings,
-       connections: (config.conceptMappings?.connections || []).filter(c => c.id !== connectionId)
-     };
-     
-     const newConfig = { ...config, conceptMappings: updatedMappings };
---
+     // Update project configuration
+     const updatedMappings = {
+       ...config.conceptMappings,
+       connections: (config.conceptMappings?.connections || []).filter(c: any => c.id !== connectionId)
+     };
+     
+     const newConfig = { ...config, conceptMappings: updatedMappings };
+     onChange(newConfig, {
+       type: 'remove',
+       target: 'conceptMapping',
@@ lines 384-398 @@
- 
-   // Apply suggestion
-   const applySuggestion = useCallback((suggestion: ConceptSuggestion) => {
-     const concept = concepts.find(c => c.name === suggestion.conceptName);
-     if (!concept) return;
-     
-     suggestion.suggestedMappings.forEach(mapping => {
-       createMapping(concept.id, mapping.groupId, 'group', mapping.confidence);
-     });
-     
-     // Remove applied suggestion
-   setSuggestions((prev: ConceptSuggestion[] | undefined) => (prev || []).filter(s => s.id !== suggestion.id));
-   }, [concepts, createMapping]);
- 
-   // Create new concept
---
+ 
+   // Apply suggestion
+   const applySuggestion = useCallback((suggestion: ConceptSuggestion) => {
+     const concept = concepts.find(c: any => c.name === suggestion.conceptName);
+     if (!concept) return;
+     
+     suggestion.suggestedMappings.forEach(mapping: any => {
+       createMapping(concept.id, mapping.groupId, 'group', mapping.confidence);
+     });
+     
+     // Remove applied suggestion
+   setSuggestions((prev: ConceptSuggestion[] | undefined) => (prev || []).filter(s: any => s.id !== suggestion.id));
+   }, [concepts, createMapping]);
+ 
+   // Create new concept
+   const createConcept = useCallback((name: string, description: string, category: ConceptNode['category']) => {
+     const newConcept: ConceptNode = {
+       id: `concept_${Date.now()}`,
@@ lines 419-425 @@
- 
-   // Update concept
-   const updateConcept = useCallback((conceptId: string, updates: Partial<ConceptNode>) => {
-     setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept => 
-       concept.id === conceptId ? { ...concept, ...updates } : concept
-     ));
-   }, []);
---
+ 
+   // Update concept
+   const updateConcept = useCallback((conceptId: string, updates: Partial<ConceptNode>) => {
+     setConcepts((prev: ConceptNode[] | undefined) => (prev || []).map(concept: any => 
+       concept.id === conceptId ? { ...concept, ...updates } : concept
+     ));
+   }, []);
+ 
+   // Delete concept
+   const deleteConcept = useCallback((conceptId: string) => {
@@ lines 429-439 @@
-     if (!confirm('Are you sure you want to delete this concept? All mappings will be removed.')) return;
-     
-     // Remove all connections for this concept
-     const conceptConnections = connections.filter(c => c.conceptId === conceptId);
-     conceptConnections.forEach(conn => removeMapping(conn.id));
-     
-     // Remove concept
-   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).filter(c => c.id !== conceptId));
-     
-     if (selectedConceptId === conceptId) {
-       setSelectedConceptId(null);
---
+     if (!confirm('Are you sure you want to delete this concept? All mappings will be removed.')) return;
+     
+     // Remove all connections for this concept
+     const conceptConnections = connections.filter(c: any => c.conceptId === conceptId);
+     conceptConnections.forEach(conn: any => removeMapping(conn.id));
+     
+     // Remove concept
+   setConcepts((prev: ConceptNode[] | undefined) => (prev || []).filter(c: any => c.id !== conceptId));
+     
+     if (selectedConceptId === conceptId) {
+       setSelectedConceptId(null);
+     }
+   }, [connections, removeMapping, selectedConceptId]);
+ 
@@ lines 490-499 @@
-             {/* Concepts */}
-             <div className="space-y-4">
-               <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
-                 {filteredConcepts.map(concept => {
-                   const isSelected = selectedConceptId === concept.id;
-                   const mappedGroupsCount = concept.mappedGroups.length;
-                   const errors = validationErrors.filter(e => e.path.includes(`concepts.${concept.id}`));
-                   
-                   return (
-                     <div
---
+             {/* Concepts */}
+             <div className="space-y-4">
+               <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
+                 {filteredConcepts.map(concept: any => {
+                   const isSelected = selectedConceptId === concept.id;
+                   const mappedGroupsCount = concept.mappedGroups.length;
+                   const errors = validationErrors.filter(e: any => e.path.includes(`concepts.${concept.id}`));
+                   
+                   return (
+                     <div
+                       key={concept.id}
+                       className={`p-4 border rounded-lg cursor-pointer transition-all ${
+                         isSelected ? 'border-blue-500 bg-blue-50' : 'bg-white hover:bg-gray-50'
@@ lines 532-538 @@
-                       
-                       <div className="space-y-2">
-                         <div className="flex flex-wrap gap-1">
-                           {concept.keywords.slice(0, 3).map(keyword => (
-                             <Badge key={keyword} variant="secondary" className="text-xs">
-                               {keyword}
-                             </Badge>
---
+                       
+                       <div className="space-y-2">
+                         <div className="flex flex-wrap gap-1">
+                           {concept.keywords.slice(0, 3).map(keyword: any => (
+                             <Badge key={keyword} variant="secondary" className="text-xs">
+                               {keyword}
+                             </Badge>
+                           ))}
+                           {concept.keywords.length > 3 && (
+                             <Badge variant="secondary" className="text-xs">
@@ lines 593-601 @@
-         </CardHeader>
-         <CardContent>
-           <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
-             {groups.map(group => {
-               const isSelected = selectedGroupId === group.id;
-               const mappedConcepts = concepts.filter(c => c.mappedGroups.includes(group.id));
-               
-               return (
-                       <div
---
+         </CardHeader>
+         <CardContent>
+           <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
+             {groups.map(group: any => {
+               const isSelected = selectedGroupId === group.id;
+               const mappedConcepts = concepts.filter(c: any => c.mappedGroups.includes(group.id));
+               
+               return (
+                       <div
+                   key={group.id}
+                   className={`p-4 border-2 border-dashed rounded-lg transition-all ${
+                     isSelected ? 'border-green-500 bg-green-50' : 
@@ lines 632-638 @@
-                       Mapped Concepts ({mappedConcepts.length}):
-                     </div>
-                     <div className="flex flex-wrap gap-1">
-                       {mappedConcepts.map(concept => (
-                         <Badge key={concept.id} variant="default" className="text-xs">
-                           {concept.name}
-                         </Badge>
---
+                       Mapped Concepts ({mappedConcepts.length}):
+                     </div>
+                     <div className="flex flex-wrap gap-1">
+                       {mappedConcepts.map(concept: any => (
+                         <Badge key={concept.id} variant="default" className="text-xs">
+                           {concept.name}
+                         </Badge>
+                       ))}
+                       {mappedConcepts.length === 0 && (
+                         <span className="text-xs text-gray-400">No concepts mapped</span>
@@ lines 652-658 @@
-   );
- 
-   const renderConceptConfiguration = () => {
-     const selectedConcept = selectedConceptId ? concepts.find(c => c.id === selectedConceptId) : null;
-     
-     if (!selectedConcept) {
-       return (
---
+   );
+ 
+   const renderConceptConfiguration = () => {
+     const selectedConcept = selectedConceptId ? concepts.find(c: any => c.id === selectedConceptId) : null;
+     
+     if (!selectedConcept) {
+       return (
+         <Card>
+           <CardContent className="p-8 text-center">
+             <Brain className="h-12 w-12 text-gray-400 mx-auto mb-4" />
@@ lines 665-672 @@
-       );
-     }
-     
-     const mappedGroups = groups.filter(g => selectedConcept.mappedGroups.includes(g.id));
-     const conceptConnections = connections.filter(c => c.conceptId === selectedConcept.id);
-     
-     return (
-       <div className="space-y-6">
---
+       );
+     }
+     
+     const mappedGroups = groups.filter(g: any => selectedConcept.mappedGroups.includes(g.id));
+     const conceptConnections = connections.filter(c: any => c.conceptId === selectedConcept.id);
+     
+     return (
+       <div className="space-y-6">
+         {/* Concept Header */}
+         <Card>
+           <CardHeader>
@@ lines 711-717 @@
-                 <Label htmlFor="concept-category">Category</Label>
-                 <Select
-                   value={selectedConcept.category}
-                   onValueChange={(value) => updateConcept(selectedConcept.id, { category: value as ConceptNode['category'] })}
-                 >
-                   <SelectTrigger>
-                     <SelectValue />
---
+                 <Label htmlFor="concept-category">Category</Label>
+                 <Select
+                   value={selectedConcept.category}
+                   onValueChange={(value: any) => updateConcept(selectedConcept.id, { category: value as ConceptNode['category'] })}
+                 >
+                   <SelectTrigger>
+                     <SelectValue />
+                   </SelectTrigger>
+                   <SelectContent>
+                     <SelectItem value="demographic">Demographic</SelectItem>
@@ lines 744-750 @@
-                   id="concept-keywords"
-                   value={selectedConcept.keywords.join(', ')}
-                   onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateConcept(selectedConcept.id, { 
-                     keywords: e.target.value.split(',').map((k: string) => k.trim()).filter(k => k.length > 0)
-                   })}
-                 />
-             </div>
---
+                   id="concept-keywords"
+                   value={selectedConcept.keywords.join(', ')}
+                   onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateConcept(selectedConcept.id, { 
+                     keywords: e.target.value.split(',').map((k: string) => k.trim()).filter(k: any => k.length > 0)
+                   })}
+                 />
+             </div>
+ 
+             <div>
+               <Label htmlFor="concept-synonyms">Synonyms (comma-separated)</Label>
@@ lines 755-761 @@
-                   id="concept-synonyms"
-                   value={selectedConcept.synonyms.join(', ')}
-                   onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateConcept(selectedConcept.id, { 
-                     synonyms: e.target.value.split(',').map((s: string) => s.trim()).filter(s => s.length > 0)
-                   })}
-                 />
-             </div>
---
+                   id="concept-synonyms"
+                   value={selectedConcept.synonyms.join(', ')}
+                   onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateConcept(selectedConcept.id, { 
+                     synonyms: e.target.value.split(',').map((s: string) => s.trim()).filter(s: any => s.length > 0)
+                   })}
+                 />
+             </div>
+ 
+             <div>
+               <Label htmlFor="concept-patterns">Query Patterns (one per line)</Label>
@@ lines 766-772 @@
-                 id="concept-patterns"
-                 value={selectedConcept.queryPatterns.join('\n')}
-                 onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateConcept(selectedConcept.id, { 
-                   queryPatterns: e.target.value.split('\n').map((p: string) => p.trim()).filter(p => p.length > 0)
-                 })}
-                 rows={4}
-                 placeholder="show population data&#10;population in area&#10;demographic information"
---
+                 id="concept-patterns"
+                 value={selectedConcept.queryPatterns.join('\n')}
+                 onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateConcept(selectedConcept.id, { 
+                   queryPatterns: e.target.value.split('\n').map((p: string) => p.trim()).filter(p: any => p.length > 0)
+                 })}
+                 rows={4}
+                 placeholder="show population data&#10;population in area&#10;demographic information"
+               />
+             </div>
+           </CardContent>
@@ lines 785-792 @@
-           </CardHeader>
-           <CardContent>
-             <div className="space-y-2">
-               {mappedGroups.map(group => {
-                 const connection = conceptConnections.find(c => c.targetId === group.id);
-                 
-                 return (
-                   <div key={group.id} className="flex items-center justify-between p-3 border rounded-lg">
---
+           </CardHeader>
+           <CardContent>
+             <div className="space-y-2">
+               {mappedGroups.map(group: any => {
+                 const connection = conceptConnections.find(c: any => c.targetId === group.id);
+                 
+                 return (
+                   <div key={group.id} className="flex items-center justify-between p-3 border rounded-lg">
+                     <div className="flex items-center gap-2">
+                       <Layers className="h-4 w-4 text-green-500" />
+                       <div>
@@ lines 871-877 @@
- 
-       {/* Suggestions List */}
-       <div className="space-y-4">
-         {suggestions.map(suggestion => (
-           <Card key={suggestion.id}>
-             <CardContent className="p-4">
-               <div className="flex items-start justify-between">
---
+ 
+       {/* Suggestions List */}
+       <div className="space-y-4">
+         {suggestions.map(suggestion: any => (
+           <Card key={suggestion.id}>
+             <CardContent className="p-4">
+               <div className="flex items-start justify-between">
+                 <div className="flex-1">
+                   <div className="flex items-center gap-2 mb-2">
+                     <h4 className="font-medium">{suggestion.conceptName}</h4>
@@ lines 891-897 @@
-                   
-                   <div className="space-y-2">
-                     <div className="text-sm font-medium">Suggested Mappings:</div>
-                     {suggestion.suggestedMappings.map(mapping => (
-                       <div key={mapping.groupId} className="flex items-center justify-between p-2 bg-gray-50 rounded">
-                         <div className="flex items-center gap-2">
-                           <Layers className="h-3 w-3" />
---
+                   
+                   <div className="space-y-2">
+                     <div className="text-sm font-medium">Suggested Mappings:</div>
+                     {suggestion.suggestedMappings.map(mapping: any => (
+                       <div key={mapping.groupId} className="flex items-center justify-between p-2 bg-gray-50 rounded">
+                         <div className="flex items-center gap-2">
+                           <Layers className="h-3 w-3" />
+                           <span className="text-sm">{mapping.groupName}</span>
+                         </div>
+                         <div className="flex items-center gap-2">
@@ lines 970-976 @@
-         <Card>
-           <CardContent className="p-4 text-center">
-             <div className="text-2xl font-bold text-purple-600">
-               {activeConnections.reduce((sum, c) => sum + c.strength, 0) / activeConnections.length || 0}
-             </div>
-             <div className="text-sm text-gray-500">Avg Strength</div>
-           </CardContent>
---
+         <Card>
+           <CardContent className="p-4 text-center">
+             <div className="text-2xl font-bold text-purple-600">
+               {activeConnections.reduce((sum: any, c: any) => sum + c.strength, 0) / activeConnections.length || 0}
+             </div>
+             <div className="text-sm text-gray-500">Avg Strength</div>
+           </CardContent>
+         </Card>
+       </div>
+ 
@@ lines 987-995 @@
-         </CardHeader>
-         <CardContent>
-           <div className="space-y-4">
-             {concepts.map(concept => {
-               const conceptConnections = activeConnections.filter(c => c.conceptId === concept.id);
-               const avgStrength = conceptConnections.reduce((sum, c) => sum + c.strength, 0) / conceptConnections.length || 0;
-               const coverage = (conceptConnections.length / groups.length) * 100;
-               
-               return (
---
+         </CardHeader>
+         <CardContent>
+           <div className="space-y-4">
+             {concepts.map(concept: any => {
+               const conceptConnections = activeConnections.filter(c: any => c.conceptId === concept.id);
+               const avgStrength = conceptConnections.reduce((sum: any, c: any) => sum + c.strength, 0) / conceptConnections.length || 0;
+               const coverage = (conceptConnections.length / groups.length) * 100;
+               
+               return (
+                 <div key={concept.id} className="border rounded-lg p-4">
+                   <div className="flex items-center justify-between mb-2">
+                     <h4 className="font-medium">{concept.name}</h4>


*** FILE: lib/services/EndpointScoringService.ts
@@ lines 166-172 @@
-     const results: { [key: string]: EndpointData } = {};
-     
-     // Load data from all configured endpoints
-     const loadPromises = ENDPOINT_CONFIGS.map(async (config) => {
-       try {
-         const data = await this.loadSingleEndpoint(config.id, geometry);
-         return [config.id, data];
---
+     const results: { [key: string]: EndpointData } = {};
+     
+     // Load data from all configured endpoints
+     const loadPromises = ENDPOINT_CONFIGS.map(async (config: any) => {
+       try {
+         const data = await this.loadSingleEndpoint(config.id, geometry);
+         return [config.id, data];
+       } catch (error) {
+         console.warn(`[EndpointScoringService] Failed to load ${config.id}:`, error);
+         return [config.id, this.getDefaultEndpointData(config)];
@@ lines 239-245 @@
-     console.log(`[EndpointScoringService] Filtering ${records.length} records by geometry`);
-     
-     // Filter records based on geometry intersection
-     const filteredRecords = records.filter(record => this.isWithinGeometry(record, geometry));
-     
-     console.log(`[EndpointScoringService] Found ${filteredRecords.length} records within geometry`);
-     
---
+     console.log(`[EndpointScoringService] Filtering ${records.length} records by geometry`);
+     
+     // Filter records based on geometry intersection
+     const filteredRecords = records.filter(record: any => this.isWithinGeometry(record, geometry));
+     
+     console.log(`[EndpointScoringService] Found ${filteredRecords.length} records within geometry`);
+     
+     return filteredRecords;
+   }
+ 
@@ lines 254-260 @@
-     
-     if (filteredRecords.length === 0) {
-       console.warn(`[EndpointScoringService] No data found for ${endpointId}`);
-       const config = ENDPOINT_CONFIGS.find(c => c.id === endpointId);
-       return this.getDefaultEndpointData(config || {
-         id: endpointId,
-         name: endpointId,
---
+     
+     if (filteredRecords.length === 0) {
+       console.warn(`[EndpointScoringService] No data found for ${endpointId}`);
+       const config = ENDPOINT_CONFIGS.find(c: any => c.id === endpointId);
+       return this.getDefaultEndpointData(config || {
+         id: endpointId,
+         name: endpointId,
+         description: 'Unknown endpoint',
+         icon: 'help-circle',
+         type: 'single-score',
@@ lines 266-272 @@
-     }
-     
-     // Find the endpoint configuration
-     const config = ENDPOINT_CONFIGS.find(c => c.id === endpointId);
-     const scoreField = config?.primaryScoreField || 'strategic_score';
-     
-     // If single record, extract data directly
---
+     }
+     
+     // Find the endpoint configuration
+     const config = ENDPOINT_CONFIGS.find(c: any => c.id === endpointId);
+     const scoreField = config?.primaryScoreField || 'strategic_score';
+     
+     // If single record, extract data directly
+     if (filteredRecords.length === 1) {
+       const record = filteredRecords[0];
+       return this.extractEndpointDataFromRecord(record, scoreField);
@@ lines 318-329 @@
-    */
-   private aggregateMarketIntelligenceRecords(records: any[], scoreField: string): EndpointData {
-     const validScores = records
-       .map(r => r[scoreField])
-       .filter(score => typeof score === 'number' && score > 0);
-     
-     const totalPopulation = records.reduce((sum, r) => sum + (r.TOTPOP_CY || 0), 0);
-     const avgScore = validScores.length > 0 
-       ? validScores.reduce((sum, score) => sum + score, 0) / validScores.length 
-       : 0;
-     
-     // Population-weighted demographics
---
+    */
+   private aggregateMarketIntelligenceRecords(records: any[], scoreField: string): EndpointData {
+     const validScores = records
+       .map(r: any => r[scoreField])
+       .filter(score: any => typeof score === 'number' && score > 0);
+     
+     const totalPopulation = records.reduce((sum: any, r: any) => sum + (r.TOTPOP_CY || 0), 0);
+     const avgScore = validScores.length > 0 
+       ? validScores.reduce((sum: any, score: any) => sum + score, 0) / validScores.length 
+       : 0;
+     
+     // Population-weighted demographics
+     const avgIncome = this.calculatePopulationWeightedAverage(
+       records, 'MEDHINC_CY', 'TOTPOP_CY'
+     );
@@ lines 418-425 @@
-         importance_score: data.total / data.count,
-         rank: 0 // Will be set after sorting
-       }))
-       .sort((a, b) => (b.importance_score || 0) - (a.importance_score || 0))
-       .map((item, index) => ({...item, rank: index + 1}));
-   }
- 
-   /**
---
+         importance_score: data.total / data.count,
+         rank: 0 // Will be set after sorting
+       }))
+       .sort((a: any, b: any) => (b.importance_score || 0) - (a.importance_score || 0))
+       .map((item: any, index: any) => ({...item, rank: index + 1}));
+   }
+ 
+   /**
+    * Calculate centroid from multiple records
+    */
+   private calculateCentroid(records: any[]): [number, number] {
@@ lines 427-440 @@
-    */
-   private calculateCentroid(records: any[]): [number, number] {
-     const validCoords = records
-       .map(r => r.center_point)
-       .filter(coords => Array.isArray(coords) && coords.length === 2 && 
-                        typeof coords[0] === 'number' && typeof coords[1] === 'number');
-     
-     if (validCoords.length === 0) return [0, 0];
-     
-     const sumLng = validCoords.reduce((sum, coord) => sum + coord[0], 0);
-     const sumLat = validCoords.reduce((sum, coord) => sum + coord[1], 0);
-     
-     return [sumLng / validCoords.length, sumLat / validCoords.length];
-   }
---
+    */
+   private calculateCentroid(records: any[]): [number, number] {
+     const validCoords = records
+       .map(r: any => r.center_point)
+       .filter(coords: any => Array.isArray(coords) && coords.length === 2 && 
+                        typeof coords[0] === 'number' && typeof coords[1] === 'number');
+     
+     if (validCoords.length === 0) return [0, 0];
+     
+     const sumLng = validCoords.reduce((sum: any, coord: any) => sum + coord[0], 0);
+     const sumLat = validCoords.reduce((sum: any, coord: any) => sum + coord[1], 0);
+     
+     return [sumLng / validCoords.length, sumLat / validCoords.length];
+   }
+ 
+   /**
+    * Aggregate multiple data points when study area contains multiple features
@@ lines 465-503 @@
-     const weightedFields = ['median_income', 'median_age', 'average_household_size'];
- 
-     // Calculate averages for score fields
-     averageFields.forEach(field => {
-       const values = dataPoints
-         .map(item => item[field])
-         .filter(val => typeof val === 'number' && !isNaN(val));
-       
-       if (values.length > 0) {
-         const total = values.reduce((sum, val) => (sum as number) + (val as number), 0) as number;
-         aggregated[field] = Math.round(total / values.length * 100) / 100;
-       }
-     });
- 
-     // Calculate sums for population fields
-     sumFields.forEach(field => {
-       const values = dataPoints
-         .map(item => item[field])
-         .filter(val => typeof val === 'number' && !isNaN(val));
-       
-       if (values.length > 0) {
-         aggregated[field] = values.reduce((sum, val) => (sum as number) + (val as number), 0);
-       }
-     });
- 
-     // Calculate weighted averages for demographic fields
-     const totalPopulation = dataPoints.reduce((sum, item) => {
-       const pop = item.population || item.total_population || 1;
-       return sum + (typeof pop === 'number' ? pop : 1);
-     }, 0);
- 
-     weightedFields.forEach(field => {
-       let weightedSum = 0;
-       let totalWeight = 0;
- 
-       dataPoints.forEach(item => {
-         const value = item[field];
-         const weight = item.population || item.total_population || 1;
-         
---
+     const weightedFields = ['median_income', 'median_age', 'average_household_size'];
+ 
+     // Calculate averages for score fields
+     averageFields.forEach(field: any => {
+       const values = dataPoints
+         .map(item: any => item[field])
+         .filter(val: any => typeof val === 'number' && !isNaN(val));
+       
+       if (values.length > 0) {
+         const total = values.reduce((sum: any, val: any) => (sum as number) + (val as number), 0) as number;
+         aggregated[field] = Math.round(total / values.length * 100) / 100;
+       }
+     });
+ 
+     // Calculate sums for population fields
+     sumFields.forEach(field: any => {
+       const values = dataPoints
+         .map(item: any => item[field])
+         .filter(val: any => typeof val === 'number' && !isNaN(val));
+       
+       if (values.length > 0) {
+         aggregated[field] = values.reduce((sum: any, val: any) => (sum as number) + (val as number), 0);
+       }
+     });
+ 
+     // Calculate weighted averages for demographic fields
+     const totalPopulation = dataPoints.reduce((sum: any, item: any) => {
+       const pop = item.population || item.total_population || 1;
+       return sum + (typeof pop === 'number' ? pop : 1);
+     }, 0);
+ 
+     weightedFields.forEach(field: any => {
+       let weightedSum = 0;
+       let totalWeight = 0;
+ 
+       dataPoints.forEach(item: any => {
+         const value = item[field];
+         const weight = item.population || item.total_population || 1;
+         
+         if (typeof value === 'number' && !isNaN(value) && typeof weight === 'number') {
+           weightedSum += value * weight;
+           totalWeight += weight;
@@ lines 515-521 @@
-     // Aggregate array fields (like feature importance)
-     if (dataPoints[0].feature_importance && Array.isArray(dataPoints[0].feature_importance)) {
-       aggregated.feature_importance = this.aggregateFeatureImportance(
-         dataPoints.map(item => item.feature_importance).filter((arr): arr is NonNullable<EndpointData['feature_importance']> => Boolean(arr))
-       );
-     }
- 
---
+     // Aggregate array fields (like feature importance)
+     if (dataPoints[0].feature_importance && Array.isArray(dataPoints[0].feature_importance)) {
+       aggregated.feature_importance = this.aggregateFeatureImportance(
+         dataPoints.map(item: any => item.feature_importance).filter((arr: any): arr is NonNullable<EndpointData['feature_importance']> => Boolean(arr))
+       );
+     }
+ 
+     // Update metadata to reflect aggregation
+     aggregated.aggregation_info = {
+       source_count: dataPoints.length,
@@ lines 553-560 @@
-     // Combine all features and average their importance scores
-     const featureMap = new Map<string, { totalImportance: number, count: number }>();
- 
-     importanceArrays.forEach(features => {
-       features.forEach(feature => {
-         const name = feature.feature_name || feature.name;
-         const importance = feature.importance_score || feature.importance || 0;
-         
---
+     // Combine all features and average their importance scores
+     const featureMap = new Map<string, { totalImportance: number, count: number }>();
+ 
+     importanceArrays.forEach(features: any => {
+       features.forEach(feature: any => {
+         const name = feature.feature_name || feature.name;
+         const importance = feature.importance_score || feature.importance || 0;
+         
+         if (name) {
+           const existing = featureMap.get(name) || { totalImportance: 0, count: 0 };
+           featureMap.set(name, {
@@ lines 575-584 @@
-         importance_score: Math.round(data.totalImportance / data.count * 10000) / 10000, // 4 decimal precision
-         rank: 0 // Will be set after sorting
-       }))
-       .sort((a, b) => b.importance_score - a.importance_score);
- 
-     // Set ranks
-     aggregatedFeatures.forEach((feature, index) => {
-       feature.rank = index + 1;
-     });
- 
---
+         importance_score: Math.round(data.totalImportance / data.count * 10000) / 10000, // 4 decimal precision
+         rank: 0 // Will be set after sorting
+       }))
+       .sort((a: any, b: any) => b.importance_score - a.importance_score);
+ 
+     // Set ranks
+     aggregatedFeatures.forEach((feature: any, index: any) => {
+       feature.rank = index + 1;
+     });
+ 
+     return aggregatedFeatures;
+   }
+ 
@@ lines 645-651 @@
-    * Process raw endpoint data into standardized format
-    */
-   private processEndpointData(rawData: EndpointData, endpointId: string): EndpointData {
-     const config = ENDPOINT_CONFIGS.find(c => c.id === endpointId);
-     if (!config) {
-       return this.getDefaultEndpointData({ id: endpointId } as EndpointConfig);
-     }
---
+    * Process raw endpoint data into standardized format
+    */
+   private processEndpointData(rawData: EndpointData, endpointId: string): EndpointData {
+     const config = ENDPOINT_CONFIGS.find(c: any => c.id === endpointId);
+     if (!config) {
+       return this.getDefaultEndpointData({ id: endpointId } as EndpointConfig);
+     }
+ 
+     // Extract the primary score based on configuration
+     let overall_score = 0;
@@ lines 743-749 @@
-    * Get endpoint configuration by ID
-    */
-   public getEndpointConfig(endpointId: string): EndpointConfig | undefined {
-     return ENDPOINT_CONFIGS.find(config => config.id === endpointId);
-   }
- 
-   /**
---
+    * Get endpoint configuration by ID
+    */
+   public getEndpointConfig(endpointId: string): EndpointConfig | undefined {
+     return ENDPOINT_CONFIGS.find(config: any => config.id === endpointId);
+   }
+ 
+   /**
+    * Calculate composite score from all endpoint data
+    */
+   public calculateCompositeScore(endpointData: { [key: string]: EndpointData }): number {
@@ lines 751-761 @@
-    */
-   public calculateCompositeScore(endpointData: { [key: string]: EndpointData }): number {
-     const scores = Object.values(endpointData)
-       .map(data => data.overall_score || 0)
-       .filter(score => score > 0);
-     
-     if (scores.length === 0) return 0;
-     return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
-   }
- }
- 
---
+    */
+   public calculateCompositeScore(endpointData: { [key: string]: EndpointData }): number {
+     const scores = Object.values(endpointData)
+       .map(data: any => data.overall_score || 0)
+       .filter(score: any => score > 0);
+     
+     if (scores.length === 0) return 0;
+     return Math.round(scores.reduce((sum: any, score: any) => sum + score, 0) / scores.length);
+   }
+ }
+ 
+ // Export singleton instance
+ export const endpointScoringService = new EndpointScoringService();
+ export default endpointScoringService;


*** FILE: lib/analysis/strategies/processors/ClusterDataProcessor.ts
@@ lines 17-23 @@
-     
-     // Spatial clustering ONLY requires cluster_performance_score
-     const hasClusterFields = rawData.results.length === 0 || 
-       rawData.results.some(record => 
-         record && 
-         ((record as any).area_id || (record as any).id || (record as any).ID) &&
-         (record as any).cluster_performance_score !== undefined
---
+     
+     // Spatial clustering ONLY requires cluster_performance_score
+     const hasClusterFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => 
+         record && 
+         ((record as any).area_id || (record as any).id || (record as any).ID) &&
+         (record as any).cluster_performance_score !== undefined
+       );
+     
+     return hasClusterFields;
@@ lines 69-75 @@
-     // Use existing cluster_id and cluster_label from the dataset
-     const clusterMap = new Map<number, any[]>();
-     
-     rawRecords.forEach(record => {
-       // Use the predefined cluster_id from the dataset
-       const clusterId = Number((record as any).cluster_id);
-       const clusterLabel = (record as any).cluster_label || `Cluster ${clusterId}`;
---
+     // Use existing cluster_id and cluster_label from the dataset
+     const clusterMap = new Map<number, any[]>();
+     
+     rawRecords.forEach(record: any => {
+       // Use the predefined cluster_id from the dataset
+       const clusterId = Number((record as any).cluster_id);
+       const clusterLabel = (record as any).cluster_label || `Cluster ${clusterId}`;
+       
+       console.log('🔥 [ClusterDataProcessor] Using existing cluster_id:', clusterId, 'label:', clusterLabel, 'for record:', (record as any).ID);
+       
@@ lines 84-101 @@
-     
-     // Calculate average performance for each cluster and get top 5
-     const clusterPerformances = Array.from(clusterMap.entries()).map(([clusterId, records]) => {
-       const avgPerformance = records.reduce((sum, record) => 
-         sum + (Number((record as any).cluster_performance_score) || 0), 0) / records.length;
-       return { clusterId, records, avgPerformance };
-     });
-     
-     // For cluster visualization, show all 5 clusters as centroids instead of individual areas
-     console.log('🔍 [ClusterDataProcessor] All clusters before centroid creation:', clusterPerformances.map(c => `Cluster ${c.clusterId}: ${c.records.length} records, avg ${c.avgPerformance.toFixed(1)}`));
-     
-     // Create cluster centroid records (one representative record per cluster)
-     const clusterCentroids = clusterPerformances.map(cluster => {
-       // Find the most representative record for this cluster (highest similarity/performance)
-       const sortedRecords = cluster.records.sort((a, b) => {
-         const scoreA = Number(a.cluster_performance_score) || 0;
-         const scoreB = Number(b.cluster_performance_score) || 0;
-         return scoreB - scoreA;
---
+     
+     // Calculate average performance for each cluster and get top 5
+     const clusterPerformances = Array.from(clusterMap.entries()).map(([clusterId, records]) => {
+       const avgPerformance = records.reduce((sum: any, record: any) => 
+         sum + (Number((record as any).cluster_performance_score) || 0), 0) / records.length;
+       return { clusterId, records, avgPerformance };
+     });
+     
+     // For cluster visualization, show all 5 clusters as centroids instead of individual areas
+     console.log('🔍 [ClusterDataProcessor] All clusters before centroid creation:', clusterPerformances.map(c: any => `Cluster ${c.clusterId}: ${c.records.length} records, avg ${c.avgPerformance.toFixed(1)}`));
+     
+     // Create cluster centroid records (one representative record per cluster)
+     const clusterCentroids = clusterPerformances.map(cluster: any => {
+       // Find the most representative record for this cluster (highest similarity/performance)
+       const sortedRecords = cluster.records.sort((a: any, b: any) => {
+         const scoreA = Number(a.cluster_performance_score) || 0;
+         const scoreB = Number(b.cluster_performance_score) || 0;
+         return scoreB - scoreA;
+       });
+       
+       const representativeRecord = sortedRecords[0]; // Best record in cluster
@@ lines 123-134 @@
-       };
-     });
-     
-     console.log('🎯 [ClusterDataProcessor] Created', clusterCentroids.length, 'cluster centroids representing', clusterPerformances.reduce((sum, c) => sum + c.records.length, 0), 'total areas');
-     
-     // Use cluster centroids instead of individual records
-     const topClusterRecords = clusterCentroids;
-     
-     return topClusterRecords.map((record, index) => {
-       const area_id = `cluster_${(record as any).clusterId || index}`;
-       const area_name = `Cluster ${(record as any).clusterId || index + 1} (${(record as any).represented_areas} areas)`;
-       
---
+       };
+     });
+     
+     console.log('🎯 [ClusterDataProcessor] Created', clusterCentroids.length, 'cluster centroids representing', clusterPerformances.reduce((sum: any, c: any) => sum + c.records.length, 0), 'total areas');
+     
+     // Use cluster centroids instead of individual records
+     const topClusterRecords = clusterCentroids;
+     
+     return topClusterRecords.map((record: any, index: any) => {
+       const area_id = `cluster_${(record as any).clusterId || index}`;
+       const area_name = `Cluster ${(record as any).clusterId || index + 1} (${(record as any).represented_areas} areas)`;
+       
+   // Spatial clustering ONLY uses cluster_performance_score - no fallbacks
+   const clusterPerformanceScore = Number((record as any).cluster_performance_score);
+       
@@ lines 255-262 @@
-   }
- 
-   private calculateClusterStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const similarityScores = records.map(r => (r.properties as any).similarity_score || 0);
-     const clusterSizes = records.map(r => (r.properties as any).cluster_size || 0);
-     
-     if (similarityScores.length === 0) {
-       return {
---
+   }
+ 
+   private calculateClusterStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const similarityScores = records.map(r: any => (r.properties as any).similarity_score || 0);
+     const clusterSizes = records.map(r: any => (r.properties as any).cluster_size || 0);
+     
+     if (similarityScores.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         clusterCount: 0, avgClusterSize: 0, avgSimilarity: 0
+       };
@@ lines 265-285 @@
-       };
-     }
-     
-     const sorted = [...similarityScores].sort((a, b) => a - b);
-     const total = similarityScores.length;
-     const sum = similarityScores.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     const median = total % 2 === 0 
-       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
-       : sorted[Math.floor(total / 2)];
-     
-     const variance = similarityScores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Cluster-specific statistics
-     const uniqueClusters = new Set(records.map(r => r.value)).size;
-     const avgClusterSize = clusterSizes.reduce((a, b) => a + b, 0) / total;
-     
-     return {
-       total,
---
+       };
+     }
+     
+     const sorted = [...similarityScores].sort((a: any, b: any) => a - b);
+     const total = similarityScores.length;
+     const sum = similarityScores.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     const median = total % 2 === 0 
+       ? (sorted[Math.floor(total / 2) - 1] + sorted[Math.floor(total / 2)]) / 2
+       : sorted[Math.floor(total / 2)];
+     
+     const variance = similarityScores.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Cluster-specific statistics
+     const uniqueClusters = new Set(records.map(r: any => r.value)).size;
+     const avgClusterSize = clusterSizes.reduce((a: any, b: any) => a + b, 0) / total;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 298-304 @@
-     const clusterMap = new Map<number, GeographicDataPoint[]>();
-     
-     // Group records by cluster
-     records.forEach(record => {
-       const clusterId = (record as any).value;
-       if (!clusterMap.has(clusterId)) {
-         clusterMap.set(clusterId, []);
---
+     const clusterMap = new Map<number, GeographicDataPoint[]>();
+     
+     // Group records by cluster
+     records.forEach(record: any => {
+       const clusterId = (record as any).value;
+       if (!clusterMap.has(clusterId)) {
+         clusterMap.set(clusterId, []);
+       }
+       clusterMap.get(clusterId)!.push(record);
+     });
@@ lines 308-314 @@
-     
-     // Analyze each cluster
-     const clusterCharacteristics = Array.from(clusterMap.entries()).map(([clusterId, clusterRecords]) => {
-       const avgSimilarity = clusterRecords.reduce((sum, r) => sum + ((r.properties as any).similarity_score || 0), 0) / clusterRecords.length;
-       const size = clusterRecords.length;
-       const label = this.getClusterLabel(clusterId);
-       
---
+     
+     // Analyze each cluster
+     const clusterCharacteristics = Array.from(clusterMap.entries()).map(([clusterId, clusterRecords]) => {
+       const avgSimilarity = clusterRecords.reduce((sum: any, r: any) => sum + ((r.properties as any).similarity_score || 0), 0) / clusterRecords.length;
+       const size = clusterRecords.length;
+       const label = this.getClusterLabel(clusterId);
+       
+       // Calculate cluster centroid (average characteristics)
+       const centroid = this.calculateClusterCentroid(clusterRecords);
+       
@@ lines 322-330 @@
-         avgSimilarity,
-         centroid,
-         representativeAreas: clusterRecords
-           .sort((a, b) => ((b.properties as any).similarity_score || 0) - ((a.properties as any).similarity_score || 0))
-           .slice(0, 3)
-           .map(r => r.area_name)
-       };
-     });
-     
---
+         avgSimilarity,
+         centroid,
+         representativeAreas: clusterRecords
+           .sort((a: any, b: any) => ((b.properties as any).similarity_score || 0) - ((a.properties as any).similarity_score || 0))
+           .slice(0, 3)
+           .map(r: any => r.area_name)
+       };
+     });
+     
+     return {
+       clusters: clusterCharacteristics,
+       totalClusters: clusterCharacteristics.length,
@@ lines 340-346 @@
-     const numericFields = new Set<string>();
-     
-     // Identify numeric fields
-     clusterRecords.forEach(record => {
-       Object.entries((record as any).properties).forEach(([key, value]) => {
-         if (typeof value === 'number' && !isNaN(value)) {
-           numericFields.add(key);
---
+     const numericFields = new Set<string>();
+     
+     // Identify numeric fields
+     clusterRecords.forEach(record: any => {
+       Object.entries((record as any).properties).forEach(([key, value]) => {
+         if (typeof value === 'number' && !isNaN(value)) {
+           numericFields.add(key);
+         }
+       });
+     });
@@ lines 349-361 @@
-     });
-     
-     // Calculate averages for numeric fields
-     numericFields.forEach(field => {
-       const values = clusterRecords
-         .map(r => (r.properties as any)[field])
-         .filter(v => typeof v === 'number' && !isNaN(v)) as number[];
-       
-       if (values.length > 0) {
-         centroid[field] = values.reduce((a, b) => a + b, 0) / values.length;
-       }
-     });
-     
---
+     });
+     
+     // Calculate averages for numeric fields
+     numericFields.forEach(field: any => {
+       const values = clusterRecords
+         .map(r: any => (r.properties as any)[field])
+         .filter(v: any => typeof v === 'number' && !isNaN(v)) as number[];
+       
+       if (values.length > 0) {
+         centroid[field] = values.reduce((a: any, b: any) => a + b, 0) / values.length;
+       }
+     });
+     
+     return centroid;
+   }
+ 
@@ lines 367-373 @@
-     // In a real implementation, this would use proper distance metrics
-     
-     const clusterMap = new Map<number, GeographicDataPoint[]>();
-     records.forEach(record => {
-       const clusterId = (record as any).value;
-       if (!clusterMap.has(clusterId)) {
-         clusterMap.set(clusterId, []);
---
+     // In a real implementation, this would use proper distance metrics
+     
+     const clusterMap = new Map<number, GeographicDataPoint[]>();
+     records.forEach(record: any => {
+       const clusterId = (record as any).value;
+       if (!clusterMap.has(clusterId)) {
+         clusterMap.set(clusterId, []);
+       }
+       clusterMap.get(clusterId)!.push(record);
+     });
@@ lines 378-394 @@
-     if (clusterMap.size <= 1) return 0; // No meaningful clustering
-     
-     // For now, return average similarity score as a proxy
-     const avgSimilarity = records.reduce((sum, r) => sum + ((r.properties as any).similarity_score || 0), 0) / records.length;
-     return avgSimilarity;
-   }
- 
-   private processClusterFeatureImportance(rawFeatureImportance: any[]): any[] {
-     return rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getClusterFeatureDescription((item as any).feature || (item as any).name),
-       clusterContribution: (item as any).cluster_contribution || 'all' // Which clusters this feature most affects
-     })).sort((a, b) => b.importance - a.importance);
-   }
- 
-   private getClusterFeatureDescription(featureName: string): string {
---
+     if (clusterMap.size <= 1) return 0; // No meaningful clustering
+     
+     // For now, return average similarity score as a proxy
+     const avgSimilarity = records.reduce((sum: any, r: any) => sum + ((r.properties as any).similarity_score || 0), 0) / records.length;
+     return avgSimilarity;
+   }
+ 
+   private processClusterFeatureImportance(rawFeatureImportance: any[]): any[] {
+     return rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getClusterFeatureDescription((item as any).feature || (item as any).name),
+       clusterContribution: (item as any).cluster_contribution || 'all' // Which clusters this feature most affects
+     })).sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   private getClusterFeatureDescription(featureName: string): string {
+     const descriptions: Record<string, string> = {
+       'income': 'Economic clustering factor',
+       'age': 'Age-based demographic clustering',
@@ lines 426-432 @@
-     const clusterSizes = clusterAnalysis.clusters.map((c: any) => c.size);
-     const maxClusterSize = Math.max(...clusterSizes);
-     const minClusterSize = Math.min(...clusterSizes);
-     const avgDistanceToCenter = records.reduce((sum, r) => sum + ((r.properties as any).cluster_centroid_distance || 0), 0) / records.length;
-     
-     // Start with clustering explanation
-     let summary = `**🗺️ Spatial Clustering Methodology:** Areas are grouped based on similar demographic and economic characteristics. Similarity scores (0-100%) measure how well each area fits its assigned cluster. Distance scores measure proximity to cluster center characteristics.
---
+     const clusterSizes = clusterAnalysis.clusters.map((c: any) => c.size);
+     const maxClusterSize = Math.max(...clusterSizes);
+     const minClusterSize = Math.min(...clusterSizes);
+     const avgDistanceToCenter = records.reduce((sum: any, r: any) => sum + ((r.properties as any).cluster_centroid_distance || 0), 0) / records.length;
+     
+     // Start with clustering explanation
+     let summary = `**🗺️ Spatial Clustering Methodology:** Areas are grouped based on similar demographic and economic characteristics. Similarity scores (0-100%) measure how well each area fits its assigned cluster. Distance scores measure proximity to cluster center characteristics.
+ 
+ `;
+     
@@ lines 573-579 @@
-     // This is a simplified implementation - in practice, you'd analyze similarity scores
-     // across multiple clusters to find areas that bridge cluster characteristics
-     if (clusters.length >= 2) {
-       const sampleAreas = records.slice(0, 3).map(r => r.area_name);
-       bridgingAreas.push(...sampleAreas);
-     }
-     
---
+     // This is a simplified implementation - in practice, you'd analyze similarity scores
+     // across multiple clusters to find areas that bridge cluster characteristics
+     if (clusters.length >= 2) {
+       const sampleAreas = records.slice(0, 3).map(r: any => r.area_name);
+       bridgingAreas.push(...sampleAreas);
+     }
+     
+     return bridgingAreas;
+   }
+ 
@@ lines 611-617 @@
-       
-       // Analyze similarity patterns
-       const avgSimilarities = clusters.map((c: any) => c.avgSimilarity || 0);
-       const highSimilarityClusters = avgSimilarities.filter(s => s > 0.7).length;
-       
-       if (highSimilarityClusters > clusters.length * 0.6) {
-         patterns.push('Strong within-cluster cohesion suggests clear geographic boundaries');
---
+       
+       // Analyze similarity patterns
+       const avgSimilarities = clusters.map((c: any) => c.avgSimilarity || 0);
+       const highSimilarityClusters = avgSimilarities.filter(s: any => s > 0.7).length;
+       
+       if (highSimilarityClusters > clusters.length * 0.6) {
+         patterns.push('Strong within-cluster cohesion suggests clear geographic boundaries');
+       }
+     }
+     
@@ lines 631-637 @@
-     let totalLon = 0;
-     let validCoords = 0;
-     
-     records.forEach(record => {
-       if ((record as any).coordinates && Array.isArray((record as any).coordinates) && (record as any).coordinates.length >= 2) {
-         totalLon += (record as any).coordinates[0];
-         totalLat += (record as any).coordinates[1];
---
+     let totalLon = 0;
+     let validCoords = 0;
+     
+     records.forEach(record: any => {
+       if ((record as any).coordinates && Array.isArray((record as any).coordinates) && (record as any).coordinates.length >= 2) {
+         totalLon += (record as any).coordinates[0];
+         totalLat += (record as any).coordinates[1];
+         validCoords++;
+       }
+     });


*** FILE: lib/analytics/query-analysis.ts
@@ lines 212-218 @@
-   const conceptTermMap: { [term: string]: ConceptKey[] } = {};
-   for (const conceptKey in conceptsData) {
-     const key = conceptKey as ConceptKey;
-     conceptsData[key].terms.forEach(term => {
-       const lowerTerm = term.toLowerCase();
-       if (!conceptTermMap[lowerTerm]) {
-         conceptTermMap[lowerTerm] = [];
---
+   const conceptTermMap: { [term: string]: ConceptKey[] } = {};
+   for (const conceptKey in conceptsData) {
+     const key = conceptKey as ConceptKey;
+     conceptsData[key].terms.forEach(term: any => {
+       const lowerTerm = term.toLowerCase();
+       if (!conceptTermMap[lowerTerm]) {
+         conceptTermMap[lowerTerm] = [];
+       }
+       conceptTermMap[lowerTerm].push(key);
+     });
@@ lines 232-262 @@
-     addKeyword(layerId, layerId);
- 
-     // Add keywords from layer Name (split into words)
-     config.name?.match(/\b(\w+)\b/g)?.forEach(word => addKeyword(word, layerId));
- 
-     // Add keywords from Tags
-     config.metadata?.tags?.forEach(tag => {
-        addKeyword(tag, layerId);
-        // If a tag is also a concept term, add the concept name itself as a keyword too
-        if (conceptTermMap[tag.toLowerCase()]) {
-          conceptTermMap[tag.toLowerCase()].forEach(conceptName => addKeyword(String(conceptName), layerId));
-        }
-     });
- 
-     // Add keywords from associated Concept terms (if layer tags match any concept term)
-     const layerTagsLower = config.metadata?.tags?.map(t => t.toLowerCase()) || [];
-     const matchedConcepts = new Set<ConceptKey>();
-     layerTagsLower.forEach(tag => {
-         if (conceptTermMap[tag]) {
-             conceptTermMap[tag].forEach(conceptName => matchedConcepts.add(conceptName));
-         }
-     });
-     
-     matchedConcepts.forEach(conceptName => {
-         // Add the concept name itself
-         addKeyword(String(conceptName), layerId);
-         // Add all terms associated with that concept
-         conceptsData[conceptName].terms.forEach(term => addKeyword(term, layerId));
-     });
- 
-     // Add keywords from field names/aliases/labels (optional, can be noisy)
---
+     addKeyword(layerId, layerId);
+ 
+     // Add keywords from layer Name (split into words)
+     config.name?.match(/\b(\w+)\b/g)?.forEach(word: any => addKeyword(word, layerId));
+ 
+     // Add keywords from Tags
+     config.metadata?.tags?.forEach(tag: any => {
+        addKeyword(tag, layerId);
+        // If a tag is also a concept term, add the concept name itself as a keyword too
+        if (conceptTermMap[tag.toLowerCase()]) {
+          conceptTermMap[tag.toLowerCase()].forEach(conceptName: any => addKeyword(String(conceptName), layerId));
+        }
+     });
+ 
+     // Add keywords from associated Concept terms (if layer tags match any concept term)
+     const layerTagsLower = config.metadata?.tags?.map(t: any => t.toLowerCase()) || [];
+     const matchedConcepts = new Set<ConceptKey>();
+     layerTagsLower.forEach(tag: any => {
+         if (conceptTermMap[tag]) {
+             conceptTermMap[tag].forEach(conceptName: any => matchedConcepts.add(conceptName));
+         }
+     });
+     
+     matchedConcepts.forEach(conceptName: any => {
+         // Add the concept name itself
+         addKeyword(String(conceptName), layerId);
+         // Add all terms associated with that concept
+         conceptsData[conceptName].terms.forEach(term: any => addKeyword(term, layerId));
+     });
+ 
+     // Add keywords from field names/aliases/labels (optional, can be noisy)
+     // config.fields?.forEach(field => {
+     //   addKeyword(field.name, layerId);
+     //   addKeyword(field.alias, layerId);
@@ lines 293-300 @@
-   // console.log(`[analyzeQueryWithIndex] Received query: "${query}"`);
-   const lowerQuery = query.toLowerCase();
-   // More robust tokenization might be needed (e.g., handle punctuation, multi-word phrases)
-   const queryTokens = lowerQuery.match(/\b(\w+)\b/g)?.filter(token => token.length >= 3) || []; 
-   const normalizedTokens = queryTokens.map(token => normalizeToken(token)); // <-- Normalize tokens
- 
-   let matchedKeywordsCount = 0;
- 
---
+   // console.log(`[analyzeQueryWithIndex] Received query: "${query}"`);
+   const lowerQuery = query.toLowerCase();
+   // More robust tokenization might be needed (e.g., handle punctuation, multi-word phrases)
+   const queryTokens = lowerQuery.match(/\b(\w+)\b/g)?.filter(token: any => token.length >= 3) || []; 
+   const normalizedTokens = queryTokens.map(token: any => normalizeToken(token)); // <-- Normalize tokens
+ 
+   let matchedKeywordsCount = 0;
+ 
+   // console.log(`[analyzeQueryWithIndex] Query Tokens: ${queryTokens.join(', ')}`);
+ 
+   // Initialize scores at the start of the function
@@ lines 413-419 @@
- 
-   // --- Extract Fields & Confidence ---
-   const finalRelevantFieldNames = new Set<string>();
-   selectedLayerIds.forEach(id => {
-      const config = layerConfigs[id];
-      if(config?.rendererField) finalRelevantFieldNames.add(config.rendererField);
-      // Maybe add primary display fields if defined?
---
+ 
+   // --- Extract Fields & Confidence ---
+   const finalRelevantFieldNames = new Set<string>();
+   selectedLayerIds.forEach(id: any => {
+      const config = layerConfigs[id];
+      if(config?.rendererField) finalRelevantFieldNames.add(config.rendererField);
+      // Maybe add primary display fields if defined?
+      // config?.fields?.forEach(f => { if (f.isPrimaryDisplay) finalRelevantFieldNames.add(f.name); });
+   });
+ 
@@ lines 461-467 @@
-     comparisonParty: undefined,
-     topN: undefined,
-     entities: [], // Required by AnalysisResult
-     layers: selectedLayerIds.map(id => ({
-       layerId: id,
-       relevance: scores[id] || 0,
-       matchMethod: 'keyword',
---
+     comparisonParty: undefined,
+     topN: undefined,
+     entities: [], // Required by AnalysisResult
+     layers: selectedLayerIds.map(id: any => ({
+       layerId: id,
+       relevance: scores[id] || 0,
+       matchMethod: 'keyword',
+       confidence: scores[id] || 0,
+       reasons: []
+     })),
@@ lines 530-537 @@
-   const trendsKeywords = ['trend', 'trending', 'popularity', 'interest over time', 'search volume', 'google trends'];
-   const correlationKeywords = ['correlation', 'relationship', 'compare', 'versus', ' vs ', 'between', 'relate', 'connection'];
-   
-   return trendsKeywords.some(trend => lowerQuery.includes(trend)) && 
-          correlationKeywords.some(corr => lowerQuery.includes(corr));
- }
- 
- // Main analysis function (OLD - Keep for reference or remove later)
---
+   const trendsKeywords = ['trend', 'trending', 'popularity', 'interest over time', 'search volume', 'google trends'];
+   const correlationKeywords = ['correlation', 'relationship', 'compare', 'versus', ' vs ', 'between', 'relate', 'connection'];
+   
+   return trendsKeywords.some(trend: any => lowerQuery.includes(trend)) && 
+          correlationKeywords.some(corr: any => lowerQuery.includes(corr));
+ }
+ 
+ // Main analysis function (OLD - Keep for reference or remove later)
+ export async function analyzeQuery(
+   query: string,
+   layerConfigs: { [key: string]: LayerConfig }, 
@@ lines 602-614 @@
-       // Find layers tagged with this concept's terms
-       for (const layerId in layerConfigsObject) { // Use the imported object
-         const config = layerConfigsObject[layerId];
-         const tags = config.metadata?.tags?.map(t => t.toLowerCase()) || [];
- 
-         // Check if any concept term is present in the layer's tags
-         const layerMatchesConceptTag = matchingTerms.some((term: string) => tags.includes(term.toLowerCase()));
- 
-         // Check if the query itself contains terms related to the layer name/ID
-         const layerNameOrIdMatchesQuery = lowerQuery.split(/\s+|,|\band\b/).filter(word => word.trim().length > 2).some(qKeyword =>
-              layerId.toLowerCase().includes(qKeyword) ||
-              config.name.toLowerCase().includes(qKeyword)
-         );
---
+       // Find layers tagged with this concept's terms
+       for (const layerId in layerConfigsObject) { // Use the imported object
+         const config = layerConfigsObject[layerId];
+         const tags = config.metadata?.tags?.map(t: any => t.toLowerCase()) || [];
+ 
+         // Check if any concept term is present in the layer's tags
+         const layerMatchesConceptTag = matchingTerms.some((term: string) => tags.includes(term.toLowerCase()));
+ 
+         // Check if the query itself contains terms related to the layer name/ID
+         const layerNameOrIdMatchesQuery = lowerQuery.split(/\s+|,|\band\b/).filter(word: any => word.trim().length > 2).some(qKeyword: any =>
+              layerId.toLowerCase().includes(qKeyword) ||
+              config.name.toLowerCase().includes(qKeyword)
+         );
+ 
+         // <<< MODIFIED Condition: Prioritize Concept Tag Match >>>
+         if (layerMatchesConceptTag) {
@@ lines 647-653 @@
-   }
- 
-   // --- Explicit Sales Proxy Rule ---
-   const mentionsSales = concepts.spending.terms.some(term => lowerQuery.includes(term.toLowerCase()) && term !== 'spending'); // Check for buy/purchase etc.
-   const mentionsHighLow = lowerQuery.includes('high') || lowerQuery.includes('low') || lowerQuery.includes('concentration');
-   // Use the refined function which checks casing for "On"
-   const mentionedBrands = extractBrandKeywords(query); 
---
+   }
+ 
+   // --- Explicit Sales Proxy Rule ---
+   const mentionsSales = concepts.spending.terms.some(term: any => lowerQuery.includes(term.toLowerCase()) && term !== 'spending'); // Check for buy/purchase etc.
+   const mentionsHighLow = lowerQuery.includes('high') || lowerQuery.includes('low') || lowerQuery.includes('concentration');
+   // Use the refined function which checks casing for "On"
+   const mentionedBrands = extractBrandKeywords(query); 
+ 
+   // Store layers added by proxy separately for refinement
+   let proxyLayerIds = new Set<string>();
@@ lines 662-681 @@
-       matchedThemes.push('sales proxy');
-       
-       // Define relevant spending terms (excluding the generic 'spending')
-       const spendingKeywords = concepts.spending.terms.filter(t => t !== 'spending');
- 
-       mentionedBrands.forEach(brand => {
-           // --- NEW LOGIC: Search layers by tags --- 
-           let foundProxyLayerForBrand = false;
-      for (const layerId in layerConfigsObject) { // Use imported object
-         const config = layerConfigsObject[layerId];
-               const tags = config.metadata?.tags?.map(t => t.toLowerCase()) || [];
-               
-               // Check 1: Does the layer tag list contain the specific brand?
-               const hasBrandTag = tags.includes(brand.toLowerCase());
-               
-               // Check 2: Does the layer tag list contain a relevant spending keyword?
-               const hasSpendingTag = spendingKeywords.some(spendTerm => tags.includes(spendTerm.toLowerCase()));
-               
-               if (hasBrandTag && hasSpendingTag) {
-                   console.log(`[analyzeQuery][Sales Proxy - Tag Match] Found potential proxy layer '${layerId}' for brand '${brand}' via tags.`);
---
+       matchedThemes.push('sales proxy');
+       
+       // Define relevant spending terms (excluding the generic 'spending')
+       const spendingKeywords = concepts.spending.terms.filter(t: any => t !== 'spending');
+ 
+       mentionedBrands.forEach(brand: any => {
+           // --- NEW LOGIC: Search layers by tags --- 
+           let foundProxyLayerForBrand = false;
+      for (const layerId in layerConfigsObject) { // Use imported object
+         const config = layerConfigsObject[layerId];
+               const tags = config.metadata?.tags?.map(t: any => t.toLowerCase()) || [];
+               
+               // Check 1: Does the layer tag list contain the specific brand?
+               const hasBrandTag = tags.includes(brand.toLowerCase());
+               
+               // Check 2: Does the layer tag list contain a relevant spending keyword?
+               const hasSpendingTag = spendingKeywords.some(spendTerm: any => tags.includes(spendTerm.toLowerCase()));
+               
+               if (hasBrandTag && hasSpendingTag) {
+                   console.log(`[analyzeQuery][Sales Proxy - Tag Match] Found potential proxy layer '${layerId}' for brand '${brand}' via tags.`);
+                   proxyLayerIds.add(layerId); // Add layer identified via tags
+                   console.log(`[analyzeQuery][Sales Proxy] Added layer ${layerId}. Attempting to add renderer field.`);
+                   if (config.rendererField) {
@@ lines 719-725 @@
-   let finalIntent = determineQueryIntent(query); // Initialize with basic intent
-   let finalQueryType = determineQueryType(query); // Initialize with basic query type
-   
-   [...finalRelevantLayerIds].forEach(layerId => {
-     const layerConfig = layerConfigsObject[layerId]; // Use imported object
-     if (!layerConfig) return;
- 
---
+   let finalIntent = determineQueryIntent(query); // Initialize with basic intent
+   let finalQueryType = determineQueryType(query); // Initialize with basic query type
+   
+   [...finalRelevantLayerIds].forEach(layerId: any => {
+     const layerConfig = layerConfigsObject[layerId]; // Use imported object
+     if (!layerConfig) return;
+ 
+     const layerNameLower = layerConfig.name.toLowerCase();
+     const layerTags = layerConfig.metadata?.tags || [];
+     
@@ lines 727-737 @@
-     const layerTags = layerConfig.metadata?.tags || [];
-     
-     // Check if layer name or tags directly match keywords (using the new variable name)
-     const nameMatches = refinedQueryKeywordTokens.some(kw => layerNameLower.includes(kw));
-     const tagMatches = layerTags.some(tag => refinedQueryKeywordSet.has(tag.toLowerCase()));
-     const conceptMatches = (matchedConceptsToKeywords[layerId] || []).some(concept => 
-       refinedQueryKeywordSet.has(concept.toLowerCase()) || // Direct concept match
-       (concept === 'brands' && refinedQueryKeywordTokens.some(kw => layerNameLower.includes(kw))) // Brand name in layer name
-     );
- 
-     // --- Simplified Refinement Criteria --- 
---
+     const layerTags = layerConfig.metadata?.tags || [];
+     
+     // Check if layer name or tags directly match keywords (using the new variable name)
+     const nameMatches = refinedQueryKeywordTokens.some(kw: any => layerNameLower.includes(kw));
+     const tagMatches = layerTags.some(tag: any => refinedQueryKeywordSet.has(tag.toLowerCase()));
+     const conceptMatches = (matchedConceptsToKeywords[layerId] || []).some(concept: any => 
+       refinedQueryKeywordSet.has(concept.toLowerCase()) || // Direct concept match
+       (concept === 'brands' && refinedQueryKeywordTokens.some(kw: any => layerNameLower.includes(kw))) // Brand name in layer name
+     );
+ 
+     // --- Simplified Refinement Criteria --- 
+     // Keep the layer if:
+     // 1. It was added by the sales proxy OR
+     // 2. Its tags directly match a query keyword OR
@@ lines 758-769 @@
-        refinedLayerIds.push(layerId);
-        // Add relevant fields for kept layers
-        if (layerConfig.rendererField) refinedFieldNames.add(layerConfig.rendererField);
-        layerConfig.fields?.forEach(f => refinedFieldNames.add(f.name)); // Add all fields? Or just thematic?
-     }
-   });
- 
-   // Ensure proxy layers are included if they weren't already
-   proxyLayerIds.forEach(proxyLayerId => {
-     if (!refinedLayerIds.includes(proxyLayerId)) {
-       refinedLayerIds.push(proxyLayerId);
-       console.log(`[analyzeQuery][Refinement] Adding back missing proxy layer: ${proxyLayerId}`);
---
+        refinedLayerIds.push(layerId);
+        // Add relevant fields for kept layers
+        if (layerConfig.rendererField) refinedFieldNames.add(layerConfig.rendererField);
+        layerConfig.fields?.forEach(f: any => refinedFieldNames.add(f.name)); // Add all fields? Or just thematic?
+     }
+   });
+ 
+   // Ensure proxy layers are included if they weren't already
+   proxyLayerIds.forEach(proxyLayerId: any => {
+     if (!refinedLayerIds.includes(proxyLayerId)) {
+       refinedLayerIds.push(proxyLayerId);
+       console.log(`[analyzeQuery][Refinement] Adding back missing proxy layer: ${proxyLayerId}`);
+       // Add fields for proxy layer if needed
+       const layerConfig = layerConfigsObject[proxyLayerId]; // Use imported object
+       if (layerConfig?.rendererField) refinedFieldNames.add(layerConfig.rendererField);
@@ lines 812-818 @@
-   const conjunctionPattern = /\b(and|with|as well as|,)\b/;
-   const highPattern = /(high|top|most|highest|peak|concentration)/;
-   const correlationPattern = /(correlat|relationship|compare| vs |versus|between|relate|connection|association)/;
-   const matchedSubtypes = refinedLayerIds.map(layerId => layerConfigsObject[layerId].metadata?.tags?.map(t => t.toLowerCase()) || []).flat().filter(Boolean);
-   const uniqueSubtypes = new Set(matchedSubtypes);
- 
-   let queryType: AnalysisResult['queryType'] = 'unknown';
---
+   const conjunctionPattern = /\b(and|with|as well as|,)\b/;
+   const highPattern = /(high|top|most|highest|peak|concentration)/;
+   const correlationPattern = /(correlat|relationship|compare| vs |versus|between|relate|connection|association)/;
+   const matchedSubtypes = refinedLayerIds.map(layerId: any => layerConfigsObject[layerId].metadata?.tags?.map(t: any => t.toLowerCase()) || []).flat().filter(Boolean);
+   const uniqueSubtypes = new Set(matchedSubtypes);
+ 
+   let queryType: AnalysisResult['queryType'] = 'unknown';
+ 
+   // --- Detect joint high intent: two variables, conjunction, high-ness, and NOT correlation language ---
+   if (
@@ lines 892-898 @@
-     comparisonParty: undefined,
-     topN: undefined,
-     entities: [], // Required by AnalysisResult
-     layers: limitedLayerIds.map(id => ({
-       layerId: id,
-       relevance: scores[id] || 0,
-       matchMethod: 'keyword',
---
+     comparisonParty: undefined,
+     topN: undefined,
+     entities: [], // Required by AnalysisResult
+     layers: limitedLayerIds.map(id: any => ({
+       layerId: id,
+       relevance: scores[id] || 0,
+       matchMethod: 'keyword',
+       confidence: scores[id] || 0,
+       reasons: []
+     })),
@@ lines 1031-1037 @@
- 
-     checkAndScore(conceptEntry.concept.toLowerCase(), 3, "Matched concept name");
- 
-     conceptEntry.synonyms?.forEach(synonym => {
-       checkAndScore(synonym.toLowerCase(), 2, "Matched synonym");
-     });
- 
---
+ 
+     checkAndScore(conceptEntry.concept.toLowerCase(), 3, "Matched concept name");
+ 
+     conceptEntry.synonyms?.forEach(synonym: any => {
+       checkAndScore(synonym.toLowerCase(), 2, "Matched synonym");
+     });
+ 
+     if (score > 0) {
+       matchedLayers.push({
+         layerId: layerId,
@@ lines 1048-1054 @@
-     }
-   }
- 
-   matchedLayers.sort((a, b) => {
-     if (b.totalScore !== a.totalScore) {
-       return b.totalScore - a.totalScore;
-     }
---
+     }
+   }
+ 
+   matchedLayers.sort((a: any, b: any) => {
+     if (b.totalScore !== a.totalScore) {
+       return b.totalScore - a.totalScore;
+     }
+     return b.matchedConcepts.size - a.matchedConcepts.size;
+   });
+ 
@@ lines 1125-1136 @@
-     if (matchedLayers.length > 0) {
-       // PATCH: For multi-metric queries, include all layers with confidence >= 0.3
-       const confidenceThreshold = 0.3;
-       finalRelevantLayers = matchedLayers.filter(l => l.confidence >= confidenceThreshold).map(l => l.layerId);
-       finalRelevantFields = finalRelevantLayers.map(lid => layerConfigsObject[lid]?.rendererField || 'thematic_value');
-       if (finalRelevantLayers.length === 1) {
-         finalExplanation = `Identified layer '${conceptMap[finalRelevantLayers[0]]?.concept || finalRelevantLayers[0]}' (using field '${finalRelevantFields[0]}') from the query.`;
-       } else if (finalRelevantLayers.length > 1) {
-         finalExplanation = `Identified layers: ${finalRelevantLayers.map((lid, i) => `'${conceptMap[lid]?.concept || lid}' (field '${finalRelevantFields[i]}')`).join(', ')} from the query.`;
-         finalQueryType = 'correlation'; // Map multivariate to correlation type
-         finalIntent = 'comparison';
-       }
---
+     if (matchedLayers.length > 0) {
+       // PATCH: For multi-metric queries, include all layers with confidence >= 0.3
+       const confidenceThreshold = 0.3;
+       finalRelevantLayers = matchedLayers.filter(l: any => l.confidence >= confidenceThreshold).map(l: any => l.layerId);
+       finalRelevantFields = finalRelevantLayers.map(lid: any => layerConfigsObject[lid]?.rendererField || 'thematic_value');
+       if (finalRelevantLayers.length === 1) {
+         finalExplanation = `Identified layer '${conceptMap[finalRelevantLayers[0]]?.concept || finalRelevantLayers[0]}' (using field '${finalRelevantFields[0]}') from the query.`;
+       } else if (finalRelevantLayers.length > 1) {
+         finalExplanation = `Identified layers: ${finalRelevantLayers.map((lid: any, i: any) => `'${conceptMap[lid]?.concept || lid}' (field '${finalRelevantFields[i]}')`).join(', ')} from the query.`;
+         finalQueryType = 'correlation'; // Map multivariate to correlation type
+         finalIntent = 'comparison';
+       }
+       // Debug log for patch
+       console.log('[analyzeQueryWithConceptMap][PATCHED] Multi-metric relevantLayers:', finalRelevantLayers, 'relevantFields:', finalRelevantFields);
+     } else {
@@ lines 1152-1158 @@
-     entities: entities,
-     intent: finalIntent,
-     confidence: matchedLayers.length > 0 ? Math.min(1, matchedLayers[0].totalScore / 5) : 0.1,
-     layers: matchedLayers.map(l => ({
-       layerId: l.layerId,
-       relevance: l.relevance,
-       matchMethod: l.matchMethod,
---
+     entities: entities,
+     intent: finalIntent,
+     confidence: matchedLayers.length > 0 ? Math.min(1, matchedLayers[0].totalScore / 5) : 0.1,
+     layers: matchedLayers.map(l: any => ({
+       layerId: l.layerId,
+       relevance: l.relevance,
+       matchMethod: l.matchMethod,
+       confidence: l.confidence,
+       reasons: l.reasons
+     })),
@@ lines 1328-1334 @@
-     /(?:increase|decrease|improve|reduce).*by.*(?:%|percent|points)/i
-   ];
-   
-   return scenarioPatterns.some(pattern => pattern.test(query));
- }
- 
- export function detectThresholdQuery(query: string): boolean {
---
+     /(?:increase|decrease|improve|reduce).*by.*(?:%|percent|points)/i
+   ];
+   
+   return scenarioPatterns.some(pattern: any => pattern.test(query));
+ }
+ 
+ export function detectThresholdQuery(query: string): boolean {
+   const thresholdPatterns = [
+     /(?:at what|what level|what point|threshold|cutoff|minimum|maximum)/i,
+     /(?:above|below|over|under).*(?:level|point|threshold|value)/i,
@@ lines 1340-1346 @@
-     /(?:rates? increase|approval.*increase|performance.*improve)/i
-   ];
-   
-   return thresholdPatterns.some(pattern => pattern.test(query));
- }
- 
- export function detectSegmentQuery(query: string): boolean {
---
+     /(?:rates? increase|approval.*increase|performance.*improve)/i
+   ];
+   
+   return thresholdPatterns.some(pattern: any => pattern.test(query));
+ }
+ 
+ export function detectSegmentQuery(query: string): boolean {
+   const segmentPatterns = [
+     /(?:what characterizes|characteristics of|profile of|what makes)/i,
+     /(?:high.*performing|low.*performing|top.*performing|bottom.*performing)/i,
@@ lines 1352-1358 @@
-     /(?:distinguish|differentiate|unique.*about|special.*about)/i
-   ];
-   
-   return segmentPatterns.some(pattern => pattern.test(query));
- }
- 
- export function detectComparativeQuery(query: string): boolean {
---
+     /(?:distinguish|differentiate|unique.*about|special.*about)/i
+   ];
+   
+   return segmentPatterns.some(pattern: any => pattern.test(query));
+ }
+ 
+ export function detectComparativeQuery(query: string): boolean {
+   const comparativePatterns = [
+     /(?:compare|comparison|versus|vs\.?|against)/i,
+     /(?:urban.*rural|rural.*urban|city.*suburb|suburb.*city)/i,
@@ lines 1365-1369 @@
-     /(?:high.*income.*low.*income|rich.*poor|wealthy.*disadvantaged)/i
-   ];
-   
-   return comparativePatterns.some(pattern => pattern.test(query));
- }
---
+     /(?:high.*income.*low.*income|rich.*poor|wealthy.*disadvantaged)/i
+   ];
+   
+   return comparativePatterns.some(pattern: any => pattern.test(query));
+ }


*** FILE: components/phase4/AIInsightGenerator.tsx
@@ lines 99-109 @@
-   const strategicScores = analysisResult.map((item: any) => {
-     const props = item.properties || item;
-     return props.strategic_value_score || props.competitive_advantage_score || 0;
-   }).filter(score => score > 0);
-   
-   if (strategicScores.length > 0) {
-     const avgStrategic = strategicScores.reduce((a, b) => a + b, 0) / strategicScores.length;
-     const highStrategicCount = strategicScores.filter(score => score > 70).length;
-     
-     if (avgStrategic > 60) {
-       insights.push({
---
+   const strategicScores = analysisResult.map((item: any) => {
+     const props = item.properties || item;
+     return props.strategic_value_score || props.competitive_advantage_score || 0;
+   }).filter(score: any => score > 0);
+   
+   if (strategicScores.length > 0) {
+     const avgStrategic = strategicScores.reduce((a: any, b: any) => a + b, 0) / strategicScores.length;
+     const highStrategicCount = strategicScores.filter(score: any => score > 70).length;
+     
+     if (avgStrategic > 60) {
+       insights.push({
+         id: 'strategic-opportunity',
+         type: 'opportunity',
+         title: 'Strong Strategic Market Position Identified',
@@ lines 133-143 @@
-   const demographicScores = analysisResult.map((item: any) => {
-     const props = item.properties || item;
-     return props.demographic_opportunity_score || props.demographic_score || 0;
-   }).filter(score => score > 0);
-   
-   if (demographicScores.length > 0) {
-     const avgDemographic = demographicScores.reduce((a, b) => a + b, 0) / demographicScores.length;
-     const highDemoCount = demographicScores.filter(score => score > 75).length;
-     
-     if (highDemoCount > 0) {
-       insights.push({
---
+   const demographicScores = analysisResult.map((item: any) => {
+     const props = item.properties || item;
+     return props.demographic_opportunity_score || props.demographic_score || 0;
+   }).filter(score: any => score > 0);
+   
+   if (demographicScores.length > 0) {
+     const avgDemographic = demographicScores.reduce((a: any, b: any) => a + b, 0) / demographicScores.length;
+     const highDemoCount = demographicScores.filter(score: any => score > 75).length;
+     
+     if (highDemoCount > 0) {
+       insights.push({
+         id: 'demographic-pattern',
+         type: 'pattern',
+         title: 'Favorable Demographic Clustering Detected',
@@ lines 167-176 @@
-   const competitiveScores = analysisResult.map((item: any) => {
-     const props = item.properties || item;
-     return props.competitive_advantage_score || props.competitive_score || 0;
-   }).filter(score => score > 0);
-   
-   if (competitiveScores.length > 0) {
-     const lowCompetitiveCount = competitiveScores.filter(score => score < 30).length;
-     
-     if (lowCompetitiveCount > competitiveScores.length * 0.3) {
-       insights.push({
---
+   const competitiveScores = analysisResult.map((item: any) => {
+     const props = item.properties || item;
+     return props.competitive_advantage_score || props.competitive_score || 0;
+   }).filter(score: any => score > 0);
+   
+   if (competitiveScores.length > 0) {
+     const lowCompetitiveCount = competitiveScores.filter(score: any => score < 30).length;
+     
+     if (lowCompetitiveCount > competitiveScores.length * 0.3) {
+       insights.push({
+         id: 'competitive-risk',
+         type: 'risk',
+         title: 'Competitive Pressure in Multiple Markets',
@@ lines 198-205 @@
-   
-   // Growth prediction based on overall market health
-   if (strategicScores.length > 0 && demographicScores.length > 0) {
-     const overallScore = (strategicScores.reduce((a, b) => a + b, 0) / strategicScores.length + 
-                          demographicScores.reduce((a, b) => a + b, 0) / demographicScores.length) / 2;
-     
-     if (overallScore > 55) {
-       const growthPotential = Math.min(45, Math.max(15, (overallScore - 40) * 0.8));
---
+   
+   // Growth prediction based on overall market health
+   if (strategicScores.length > 0 && demographicScores.length > 0) {
+     const overallScore = (strategicScores.reduce((a: any, b: any) => a + b, 0) / strategicScores.length + 
+                          demographicScores.reduce((a: any, b: any) => a + b, 0) / demographicScores.length) / 2;
+     
+     if (overallScore > 55) {
+       const growthPotential = Math.min(45, Math.max(15, (overallScore - 40) * 0.8));
+       
+       insights.push({
+         id: 'growth-prediction',
@@ lines 244-255 @@
-     };
-   }
-   
-   const opportunities = insights.filter(i => i.type === 'opportunity');
-   const risks = insights.filter(i => i.type === 'risk');
-   const patterns = insights.filter(i => i.type === 'pattern');
-   const predictions = insights.filter(i => i.type === 'prediction');
-   
-   const avgConfidence = insights.reduce((acc, i) => acc + i.confidence, 0) / insights.length;
-   const dataPointCount = Array.isArray(analysisResult) ? analysisResult.length : 0;
-   
-   // Calculate ROI based on actual insights
---
+     };
+   }
+   
+   const opportunities = insights.filter(i: any => i.type === 'opportunity');
+   const risks = insights.filter(i: any => i.type === 'risk');
+   const patterns = insights.filter(i: any => i.type === 'pattern');
+   const predictions = insights.filter(i: any => i.type === 'prediction');
+   
+   const avgConfidence = insights.reduce((acc: any, i: any) => acc + i.confidence, 0) / insights.length;
+   const dataPointCount = Array.isArray(analysisResult) ? analysisResult.length : 0;
+   
+   // Calculate ROI based on actual insights
+   const baseROI = Math.max(10, Math.min(30, avgConfidence * 30));
+   const opportunityMultiplier = 1 + (opportunities.length * 0.3);
+   const riskMultiplier = Math.max(0.6, 1 - (risks.length * 0.2));
@@ lines 264-284 @@
-   return {
-     overview: `Analysis of ${dataPointCount} market areas reveals ${opportunities.length} key opportunities and ${risks.length} risk factors. Overall market conditions show ${avgConfidence > 0.8 ? 'strong' : avgConfidence > 0.6 ? 'moderate' : 'cautious'} potential for expansion.`,
-     keyFindings: [
-       ...insights.slice(0, 4).map(insight => 
-         `${insight.title}: ${Math.round(insight.confidence * 100)}% confidence`
-       ),
-       `${dataPointCount} market areas analyzed with ${Math.round(avgConfidence * 100)}% average confidence`
-     ],
-     recommendations: [
-       ...opportunities.slice(0, 2).flatMap(opp => opp.actionItems?.slice(0, 2) || []),
-       `Monitor ${risks.length} identified risk factors closely`
-     ],
-     risks: [
-       ...risks.slice(0, 3).map(risk => risk.title),
-       'Market volatility and competitive changes'
-     ],
-     opportunities: [
-       ...opportunities.slice(0, 3).map(opp => opp.title),
-       'Data-driven decision making advantage'
-     ],
-     confidenceScore: avgConfidence,
---
+   return {
+     overview: `Analysis of ${dataPointCount} market areas reveals ${opportunities.length} key opportunities and ${risks.length} risk factors. Overall market conditions show ${avgConfidence > 0.8 ? 'strong' : avgConfidence > 0.6 ? 'moderate' : 'cautious'} potential for expansion.`,
+     keyFindings: [
+       ...insights.slice(0, 4).map(insight: any => 
+         `${insight.title}: ${Math.round(insight.confidence * 100)}% confidence`
+       ),
+       `${dataPointCount} market areas analyzed with ${Math.round(avgConfidence * 100)}% average confidence`
+     ],
+     recommendations: [
+       ...opportunities.slice(0, 2).flatMap(opp: any => opp.actionItems?.slice(0, 2) || []),
+       `Monitor ${risks.length} identified risk factors closely`
+     ],
+     risks: [
+       ...risks.slice(0, 3).map(risk: any => risk.title),
+       'Market volatility and competitive changes'
+     ],
+     opportunities: [
+       ...opportunities.slice(0, 3).map(opp: any => opp.title),
+       'Data-driven decision making advantage'
+     ],
+     confidenceScore: avgConfidence,
+     roi: {
+       conservative: conservativeROI,
+       moderate: moderateROI,
@@ lines 353-359 @@
-       setExecutiveSummary(response.executiveSummary);
-       
-       // Notify parent components
-       response.insights.forEach(insight => onInsightGenerated?.(insight));
-       onSummaryGenerated?.(response.executiveSummary);
-       
-     } catch (error) {
---
+       setExecutiveSummary(response.executiveSummary);
+       
+       // Notify parent components
+       response.insights.forEach(insight: any => onInsightGenerated?.(insight));
+       onSummaryGenerated?.(response.executiveSummary);
+       
+     } catch (error) {
+       console.error('Error generating AI insights:', error);
+       
+       // Fallback to analysis-based insights on error
@@ lines 362-368 @@
-       // Fallback to analysis-based insights on error
-       const fallbackInsights = generateInsightsFromAnalysisData(analysisResult, analysisContext);
-       const filteredFallback = fallbackInsights.filter(
-         insight => insight.confidence >= (confidenceThreshold || config?.confidenceThreshold || 0.8)
-       ).slice(0, maxInsights || config?.maxInsightsPerAnalysis || 5);
-       
-       setInsights(filteredFallback);
---
+       // Fallback to analysis-based insights on error
+       const fallbackInsights = generateInsightsFromAnalysisData(analysisResult, analysisContext);
+       const filteredFallback = fallbackInsights.filter(
+         insight: any => insight.confidence >= (confidenceThreshold || config?.confidenceThreshold || 0.8)
+       ).slice(0, maxInsights || config?.maxInsightsPerAnalysis || 5);
+       
+       setInsights(filteredFallback);
+       setExecutiveSummary(generateExecutiveSummaryFromInsights(filteredFallback, analysisResult));
+     } finally {
+       setIsGenerating(false);
@@ lines 390-396 @@
-   // Group insights by type
-   const groupedInsights = useMemo(() => {
-     const groups: Record<string, AIInsight[]> = {};
-     insights.forEach(insight => {
-       if (!groups[insight.type]) {
-         groups[insight.type] = [];
-       }
---
+   // Group insights by type
+   const groupedInsights = useMemo(() => {
+     const groups: Record<string, AIInsight[]> = {};
+     insights.forEach(insight: any => {
+       if (!groups[insight.type]) {
+         groups[insight.type] = [];
+       }
+       groups[insight.type].push(insight);
+     });
+     return groups;
@@ lines 465-471 @@
-       </div>
-       
-       {/* Content */}
-       <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as any)}>
-         <TabsList className="grid w-full grid-cols-2">
-           <TabsTrigger value="insights" className="text-xs">
-             Insights ({insights.length})
---
+       </div>
+       
+       {/* Content */}
+       <Tabs value={activeTab} onValueChange={(v: any) => setActiveTab(v as any)}>
+         <TabsList className="grid w-full grid-cols-2">
+           <TabsTrigger value="insights" className="text-xs">
+             Insights ({insights.length})
+           </TabsTrigger>
+           <TabsTrigger value="summary" className="text-xs">Executive Summary</TabsTrigger>
+         </TabsList>
@@ lines 483-489 @@
-                     {type} ({typeInsights.length})
-                   </h4>
-                   
-                   {typeInsights.map(insight => {
-                     const Icon = getInsightIcon(insight.type);
-                     
-                     return (
---
+                     {type} ({typeInsights.length})
+                   </h4>
+                   
+                   {typeInsights.map(insight: any => {
+                     const Icon = getInsightIcon(insight.type);
+                     
+                     return (
+                       <Card
+                         key={insight.id}
+                         className={cn(
@@ lines 530-536 @@
-                             <Button
-                               size="sm"
-                               variant="ghost"
-                               onClick={(e) => {
-                                 e.stopPropagation();
-                                 copyInsight(insight);
-                               }}
---
+                             <Button
+                               size="sm"
+                               variant="ghost"
+                               onClick={(e: any) => {
+                                 e.stopPropagation();
+                                 copyInsight(insight);
+                               }}
+                               className="text-xs"
+                             >
+                               <Copy className="w-3 h-3" />
@@ lines 553-559 @@
-                                 <div className="space-y-2">
-                                   <h5 className="text-xs font-semibold">Supporting Data</h5>
-                                   <div className="grid grid-cols-1 gap-2">
-                                     {insight.supportingData.map((data, i) => (
-                                       <div
-                                         key={i}
-                                         className="flex items-center justify-between text-xs p-2 rounded bg-muted"
---
+                                 <div className="space-y-2">
+                                   <h5 className="text-xs font-semibold">Supporting Data</h5>
+                                   <div className="grid grid-cols-1 gap-2">
+                                     {insight.supportingData.map((data: any, i: any) => (
+                                       <div
+                                         key={i}
+                                         className="flex items-center justify-between text-xs p-2 rounded bg-muted"
+                                       >
+                                         <span className="text-muted-foreground">
+                                           {data.metric}
@@ lines 578-584 @@
-                                 <div className="space-y-2">
-                                   <h5 className="text-xs font-semibold">Recommended Actions</h5>
-                                   <ul className="space-y-1">
-                                     {insight.actionItems.map((action, i) => (
-                                       <li key={i} className="flex items-start gap-2 text-xs">
-                                         <ChevronRight className="w-3 h-3 mt-0.5 text-muted-foreground" />
-                                         <span>{action}</span>
---
+                                 <div className="space-y-2">
+                                   <h5 className="text-xs font-semibold">Recommended Actions</h5>
+                                   <ul className="space-y-1">
+                                     {insight.actionItems.map((action: any, i: any) => (
+                                       <li key={i} className="flex items-start gap-2 text-xs">
+                                         <ChevronRight className="w-3 h-3 mt-0.5 text-muted-foreground" />
+                                         <span>{action}</span>
+                                       </li>
+                                     ))}
+                                   </ul>
@@ lines 638-644 @@
-                 <div>
-                   <h5 className="text-xs font-semibold mb-2">Key Findings</h5>
-                   <ul className="space-y-1">
-                     {executiveSummary.keyFindings.map((finding, i) => (
-                       <li key={i} className="flex items-start gap-2 text-xs">
-                         <CheckCircle className="w-3 h-3 mt-0.5 text-green-500" />
-                         <span>{finding}</span>
---
+                 <div>
+                   <h5 className="text-xs font-semibold mb-2">Key Findings</h5>
+                   <ul className="space-y-1">
+                     {executiveSummary.keyFindings.map((finding: any, i: any) => (
+                       <li key={i} className="flex items-start gap-2 text-xs">
+                         <CheckCircle className="w-3 h-3 mt-0.5 text-green-500" />
+                         <span>{finding}</span>
+                       </li>
+                     ))}
+                   </ul>
@@ lines 679-685 @@
-                       Opportunities
-                     </h5>
-                     <ul className="space-y-1">
-                       {executiveSummary.opportunities.map((opp, i) => (
-                         <li key={i} className="text-xs">• {opp}</li>
-                       ))}
-                     </ul>
---
+                       Opportunities
+                     </h5>
+                     <ul className="space-y-1">
+                       {executiveSummary.opportunities.map((opp: any, i: any) => (
+                         <li key={i} className="text-xs">• {opp}</li>
+                       ))}
+                     </ul>
+                   </div>
+                   <div>
+                     <h5 className="text-xs font-semibold mb-2 text-red-600">
@@ lines 689-695 @@
-                       Risks
-                     </h5>
-                     <ul className="space-y-1">
-                       {executiveSummary.risks.map((risk, i) => (
-                         <li key={i} className="text-xs">• {risk}</li>
-                       ))}
-                     </ul>
---
+                       Risks
+                     </h5>
+                     <ul className="space-y-1">
+                       {executiveSummary.risks.map((risk: any, i: any) => (
+                         <li key={i} className="text-xs">• {risk}</li>
+                       ))}
+                     </ul>
+                   </div>
+                 </div>
+               </CardContent>
@@ lines 714-726 @@
-       {insights.length > 0 && (
-         <div className="flex items-center justify-between pt-4 border-t text-xs text-muted-foreground">
-           <div className="flex items-center gap-4">
-             <span>{insights.filter(i => i.type === 'opportunity').length} opportunities</span>
-             <span>{insights.filter(i => i.type === 'risk').length} risks</span>
-             <span>{insights.filter(i => i.type === 'pattern').length} patterns</span>
-           </div>
-           <div>
-             Avg confidence: {Math.round(
-               insights.reduce((acc, i) => acc + i.confidence, 0) / insights.length * 100
-             )}%
-           </div>
-         </div>
---
+       {insights.length > 0 && (
+         <div className="flex items-center justify-between pt-4 border-t text-xs text-muted-foreground">
+           <div className="flex items-center gap-4">
+             <span>{insights.filter(i: any => i.type === 'opportunity').length} opportunities</span>
+             <span>{insights.filter(i: any => i.type === 'risk').length} risks</span>
+             <span>{insights.filter(i: any => i.type === 'pattern').length} patterns</span>
+           </div>
+           <div>
+             Avg confidence: {Math.round(
+               insights.reduce((acc: any, i: any) => acc + i.confidence, 0) / insights.length * 100
+             )}%
+           </div>
+         </div>
+       )}
+     </div>
+   );


*** FILE: lib/analysis/strategies/processors/OutlierDetectionProcessor.ts
@@ lines 18-24 @@
-     
-     // Validate that we have expected fields for outlier detection
-     const hasRequiredFields = rawData.results.length === 0 || 
-       rawData.results.some(record => 
-         record && 
-         ((record as any).area_id || (record as any).id || (record as any).ID) &&
-         ((record as any).outlier_score !== undefined || 
---
+     
+     // Validate that we have expected fields for outlier detection
+     const hasRequiredFields = rawData.results.length === 0 || 
+       rawData.results.some(record: any => 
+         record && 
+         ((record as any).area_id || (record as any).id || (record as any).ID) &&
+         ((record as any).outlier_score !== undefined || 
+          (record as any).value !== undefined || 
+          (record as any).score !== undefined ||
+          // Check for outlier-relevant fields
@@ lines 501-509 @@
-    */
-   private rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
-     // Sort by outlier score descending and assign ranks
-     const sorted = [...records].sort((a, b) => b.value - a.value);
-     
-     return sorted.map((record, index) => ({
-       ...record,
-       rank: index + 1
-     }));
---
+    */
+   private rankRecords(records: GeographicDataPoint[]): GeographicDataPoint[] {
+     // Sort by outlier score descending and assign ranks
+     const sorted = [...records].sort((a: any, b: any) => b.value - a.value);
+     
+     return sorted.map((record: any, index: any) => ({
+       ...record,
+       rank: index + 1
+     }));
+   }
+ 
+   /**
@@ lines 513-519 @@
-    * Process feature importance with outlier focus
-    */
-   private processOutlierFeatureImportance(rawFeatureImportance: any[]): any[] {
-     const outlierFeatures = rawFeatureImportance.map(item => ({
-       feature: (item as any).feature || (item as any).name || 'unknown',
-       importance: Number((item as any).importance || (item as any).value || 0),
-       description: this.getOutlierFeatureDescription((item as any).feature || (item as any).name)
---
+    * Process feature importance with outlier focus
+    */
+   private processOutlierFeatureImportance(rawFeatureImportance: any[]): any[] {
+     const outlierFeatures = rawFeatureImportance.map(item: any => ({
+       feature: (item as any).feature || (item as any).name || 'unknown',
+       importance: Number((item as any).importance || (item as any).value || 0),
+       description: this.getOutlierFeatureDescription((item as any).feature || (item as any).name)
+     }));
+ 
+     // Add outlier-specific synthetic features if none provided
@@ lines 529-535 @@
-       ];
-     }
- 
-     return outlierFeatures.sort((a, b) => b.importance - a.importance);
-   }
- 
-   /**
---
+       ];
+     }
+ 
+     return outlierFeatures.sort((a: any, b: any) => b.importance - a.importance);
+   }
+ 
+   /**
+    * Get outlier-specific feature descriptions
+    */
+   private getOutlierFeatureDescription(featureName: string): string {
@@ lines 568-574 @@
-    * Calculate outlier-specific statistics
-    */
-   private calculateOutlierStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
-     const values = records.map(r => r.value).filter(v => !isNaN(v));
-     
-     if (values.length === 0) {
-       return {
---
+    * Calculate outlier-specific statistics
+    */
+   private calculateOutlierStatistics(records: GeographicDataPoint[]): AnalysisStatistics {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v));
+     
+     if (values.length === 0) {
+       return {
+         total: 0, mean: 0, median: 0, min: 0, max: 0, stdDev: 0,
+         percentile25: 0, percentile75: 0, iqr: 0, outlierCount: 0
+       };
@@ lines 577-585 @@
-       };
-     }
-     
-     const sorted = [...values].sort((a, b) => a - b);
-     const total = values.length;
-     const sum = values.reduce((a, b) => a + b, 0);
-     const mean = sum / total;
-     
-     // Calculate percentiles
---
+       };
+     }
+     
+     const sorted = [...values].sort((a: any, b: any) => a - b);
+     const total = values.length;
+     const sum = values.reduce((a: any, b: any) => a + b, 0);
+     const mean = sum / total;
+     
+     // Calculate percentiles
+     const p25Index = Math.floor(total * 0.25);
+     const p75Index = Math.floor(total * 0.75);
+     const medianIndex = Math.floor(total * 0.5);
@@ lines 594-607 @@
-       : sorted[medianIndex];
-     
-     // Calculate standard deviation
-     const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / total;
-     const stdDev = Math.sqrt(variance);
-     
-     // Calculate IQR and outliers
-     const iqr = percentile75 - percentile25;
-     const lowerBound = percentile25 - 1.5 * iqr;
-     const upperBound = percentile75 + 1.5 * iqr;
-     const outlierCount = values.filter(v => v < lowerBound || v > upperBound).length;
-     
-     return {
-       total,
---
+       : sorted[medianIndex];
+     
+     // Calculate standard deviation
+     const variance = values.reduce((acc: any, val: any) => acc + Math.pow(val - mean, 2), 0) / total;
+     const stdDev = Math.sqrt(variance);
+     
+     // Calculate IQR and outliers
+     const iqr = percentile75 - percentile25;
+     const lowerBound = percentile25 - 1.5 * iqr;
+     const upperBound = percentile75 + 1.5 * iqr;
+     const outlierCount = values.filter(v: any => v < lowerBound || v > upperBound).length;
+     
+     return {
+       total,
+       mean,
+       median,
+       min: sorted[0],
@@ lines 635-644 @@
-     summary += `Average outlier score: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
-     
-     // Calculate outlier category distribution
-     const strongOutliers = records.filter(r => r.value >= 60).length;
-     const moderateOutliers = records.filter(r => r.value >= 40 && r.value < 60).length;
-     const mildOutliers = records.filter(r => r.value >= 20 && r.value < 40).length;
-     const normalRange = records.filter(r => r.value < 20).length;
-     
-     summary += `Outlier distribution: ${strongOutliers} strong outliers (${(strongOutliers/records.length*100).toFixed(1)}%), `;
-     summary += `${moderateOutliers} moderate outliers (${(moderateOutliers/records.length*100).toFixed(1)}%), `;
---
+     summary += `Average outlier score: ${statistics.mean.toFixed(1)} (range: ${statistics.min.toFixed(1)}-${statistics.max.toFixed(1)}). `;
+     
+     // Calculate outlier category distribution
+     const strongOutliers = records.filter(r: any => r.value >= 60).length;
+     const moderateOutliers = records.filter(r: any => r.value >= 40 && r.value < 60).length;
+     const mildOutliers = records.filter(r: any => r.value >= 20 && r.value < 40).length;
+     const normalRange = records.filter(r: any => r.value < 20).length;
+     
+     summary += `Outlier distribution: ${strongOutliers} strong outliers (${(strongOutliers/records.length*100).toFixed(1)}%), `;
+     summary += `${moderateOutliers} moderate outliers (${(moderateOutliers/records.length*100).toFixed(1)}%), `;
+     summary += `${mildOutliers} mild outliers (${(mildOutliers/records.length*100).toFixed(1)}%), `;
+     summary += `${normalRange} normal range (${(normalRange/records.length*100).toFixed(1)}%).
+ 
@@ lines 650-669 @@
-     // Top outlier markets (5-8 areas)
-     const topOutliers = records.slice(0, 8);
-     if (topOutliers.length > 0) {
-       const significantOutliers = topOutliers.filter(r => r.value >= 50);
-       if (significantOutliers.length > 0) {
-         summary += `**Most Exceptional Markets:** `;
-         const outlierNames = significantOutliers.slice(0, 10).map(r => `${r.area_name} (${r.value.toFixed(1)})`);;
-         summary += `${outlierNames.join(', ')}. `;
-         
-         const avgTopOutlier = significantOutliers.reduce((sum, r) => sum + r.value, 0) / significantOutliers.length;
-         summary += `These markets show exceptional outlier characteristics with average score ${avgTopOutlier.toFixed(1)}. `;
-       }
-     }
-     
-     // Outlier type breakdown
-     if (records.length > 0) {
-       const outlierTypes = records.reduce((acc, record) => {
-         const type = (record as any).properties.outlier_type || 'Unknown';
-         acc[type] = (acc[type] || 0) + 1;
-         return acc;
---
+     // Top outlier markets (5-8 areas)
+     const topOutliers = records.slice(0, 8);
+     if (topOutliers.length > 0) {
+       const significantOutliers = topOutliers.filter(r: any => r.value >= 50);
+       if (significantOutliers.length > 0) {
+         summary += `**Most Exceptional Markets:** `;
+         const outlierNames = significantOutliers.slice(0, 10).map(r: any => `${r.area_name} (${r.value.toFixed(1)})`);;
+         summary += `${outlierNames.join(', ')}. `;
+         
+         const avgTopOutlier = significantOutliers.reduce((sum: any, r: any) => sum + r.value, 0) / significantOutliers.length;
+         summary += `These markets show exceptional outlier characteristics with average score ${avgTopOutlier.toFixed(1)}. `;
+       }
+     }
+     
+     // Outlier type breakdown
+     if (records.length > 0) {
+       const outlierTypes = records.reduce((acc: any, record: any) => {
+         const type = (record as any).properties.outlier_type || 'Unknown';
+         acc[type] = (acc[type] || 0) + 1;
+         return acc;
+       }, {} as Record<string, number>);
+       
+       const topOutlierTypes = Object.entries(outlierTypes)
@@ lines 685-696 @@
-     // Statistical outliers
-     if (records.length > 0) {
-       const statisticalOutliers = records
-         .filter(r => ((r.properties as any).statistical_outlier_level || 0) >= 50)
-         .slice(0, 5);
-       
-       if (statisticalOutliers.length > 0) {
-         summary += `**Statistical Outliers:** `;
-         const statNames = statisticalOutliers.map(r => 
-           `${r.area_name} (${((r.properties as any).statistical_outlier_level || 0).toFixed(1)}% deviation)`
-         );
-         summary += `${statNames.join(', ')}. `;
---
+     // Statistical outliers
+     if (records.length > 0) {
+       const statisticalOutliers = records
+         .filter(r: any => ((r.properties as any).statistical_outlier_level || 0) >= 50)
+         .slice(0, 5);
+       
+       if (statisticalOutliers.length > 0) {
+         summary += `**Statistical Outliers:** `;
+         const statNames = statisticalOutliers.map(r: any => 
+           `${r.area_name} (${((r.properties as any).statistical_outlier_level || 0).toFixed(1)}% deviation)`
+         );
+         summary += `${statNames.join(', ')}. `;
+         summary += `These markets show extreme statistical deviations requiring investigation. `;
+       }
+     }
@@ lines 701-712 @@
-     // Performance extremes
-     if (records.length > 0) {
-       const performanceExtremes = records
-         .filter(r => ((r.properties as any).performance_extreme_level || 0) >= 60)
-         .slice(0, 5);
-       
-       if (performanceExtremes.length > 0) {
-         summary += `**Performance Extremes:** `;
-         const extremeNames = performanceExtremes.map(r => 
-           `${r.area_name} (${((r.properties as any).performance_extreme_level || 0).toFixed(1)}% extreme)`
-         );
-         summary += `${extremeNames.join(', ')}. `;
---
+     // Performance extremes
+     if (records.length > 0) {
+       const performanceExtremes = records
+         .filter(r: any => ((r.properties as any).performance_extreme_level || 0) >= 60)
+         .slice(0, 5);
+       
+       if (performanceExtremes.length > 0) {
+         summary += `**Performance Extremes:** `;
+         const extremeNames = performanceExtremes.map(r: any => 
+           `${r.area_name} (${((r.properties as any).performance_extreme_level || 0).toFixed(1)}% extreme)`
+         );
+         summary += `${extremeNames.join(', ')}. `;
+         summary += `These markets demonstrate exceptional performance levels. `;
+       }
+     }
@@ lines 717-728 @@
-     // Contextually unique markets
-     if (records.length > 0) {
-       const uniqueMarkets = records
-         .filter(r => ((r.properties as any).contextual_uniqueness_level || 0) >= 50)
-         .slice(0, 5);
-       
-       if (uniqueMarkets.length > 0) {
-         summary += `**Contextually Unique Markets:** `;
-         const uniqueNames = uniqueMarkets.map(r => r.area_name);
-         summary += `${uniqueNames.join(', ')}. `;
-         summary += `These markets have unique characteristics within their economic/geographic context. `;
-       }
---
+     // Contextually unique markets
+     if (records.length > 0) {
+       const uniqueMarkets = records
+         .filter(r: any => ((r.properties as any).contextual_uniqueness_level || 0) >= 50)
+         .slice(0, 5);
+       
+       if (uniqueMarkets.length > 0) {
+         summary += `**Contextually Unique Markets:** `;
+         const uniqueNames = uniqueMarkets.map(r: any => r.area_name);
+         summary += `${uniqueNames.join(', ')}. `;
+         summary += `These markets have unique characteristics within their economic/geographic context. `;
+       }
+     }
+     
+     // Strategic insights
@@ lines 731-743 @@
-     // Strategic insights
-     summary += `**Outlier Insights:** ${statistics.total} geographic areas analyzed for exceptional characteristics and outlier patterns. `;
-     
-     const extremeOutliers = records.filter(r => r.value >= 70).length;
-     if (extremeOutliers > 0) {
-       summary += `${extremeOutliers} markets (${(extremeOutliers/records.length*100).toFixed(1)}%) show extreme outlier patterns requiring detailed analysis. `;
-     }
-     
-     // Rare combinations
-     const rareMarkets = records.filter(r => ((r.properties as any).rarity_level || 0) >= 30).length;
-     if (rareMarkets > 0) {
-       summary += `${rareMarkets} markets exhibit rare characteristic combinations offering unique opportunities or challenges. `;
-     }
---
+     // Strategic insights
+     summary += `**Outlier Insights:** ${statistics.total} geographic areas analyzed for exceptional characteristics and outlier patterns. `;
+     
+     const extremeOutliers = records.filter(r: any => r.value >= 70).length;
+     if (extremeOutliers > 0) {
+       summary += `${extremeOutliers} markets (${(extremeOutliers/records.length*100).toFixed(1)}%) show extreme outlier patterns requiring detailed analysis. `;
+     }
+     
+     // Rare combinations
+     const rareMarkets = records.filter(r: any => ((r.properties as any).rarity_level || 0) >= 30).length;
+     if (rareMarkets > 0) {
+       summary += `${rareMarkets} markets exhibit rare characteristic combinations offering unique opportunities or challenges. `;
+     }
+     
+     // Actionable recommendations
+     summary += `**Investigation Recommendations:** `;
@@ lines 769-775 @@
-    * Create direct renderer for outlier detection visualization
-    */
-   private createOutlierRenderer(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use inverted colors for outlier detection: Green (normal) -> Orange -> Red (extreme outlier)
---
+    * Create direct renderer for outlier detection visualization
+    */
+   private createOutlierRenderer(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use inverted colors for outlier detection: Green (normal) -> Orange -> Red (extreme outlier)
+     const outlierColors = [
+       [26, 152, 80, 0.6],    // #1a9850 - Green (normal behavior)
+       [166, 217, 106, 0.6],  // #a6d96a - Light Green
@@ lines 783-789 @@
-     return {
-       type: 'class-breaks',
-       field: this.scoreField, // Direct field reference
-       classBreakInfos: quartileBreaks.map((breakRange, i) => ({
-         minValue: breakRange.min,
-         maxValue: breakRange.max,
-         symbol: {
---
+     return {
+       type: 'class-breaks',
+       field: this.scoreField, // Direct field reference
+       classBreakInfos: quartileBreaks.map((breakRange: any, i: any) => ({
+         minValue: breakRange.min,
+         maxValue: breakRange.max,
+         symbol: {
+           type: 'simple-fill',
+           color: outlierColors[i], // Direct array format
+           outline: { color: [0, 0, 0, 0], width: 0 }
@@ lines 805-811 @@
-    * Create direct legend for outlier detection
-    */
-   private createOutlierLegend(records: any[]): any {
-     const values = records.map(r => r.value).filter(v => !isNaN(v)).sort((a, b) => a - b);
-     const quartileBreaks = this.calculateQuartileBreaks(values);
-     
-     // Use RGBA format with correct opacity to match features
---
+    * Create direct legend for outlier detection
+    */
+   private createOutlierLegend(records: any[]): any {
+     const values = records.map(r: any => r.value).filter(v: any => !isNaN(v)).sort((a: any, b: any) => a - b);
+     const quartileBreaks = this.calculateQuartileBreaks(values);
+     
+     // Use RGBA format with correct opacity to match features
+     const colors = [
+       'rgba(26, 152, 80, 0.6)',    // Normal behavior
+       'rgba(166, 217, 106, 0.6)',  // Mild outlier  


*** FILE: lib/clustering/ClusteringService.ts
@@ lines 194-200 @@
-     }
- 
-     // Calculate total population
-     const totalPopulation = records.reduce((sum, record) => {
-       const population = this.extractPopulation(record.properties || {});
-       return sum + population;
-     }, 0);
---
+     }
+ 
+     // Calculate total population
+     const totalPopulation = records.reduce((sum: any, record: any) => {
+       const population = this.extractPopulation(record.properties || {});
+       return sum + population;
+     }, 0);
+ 
+     // Calculate geographic spread (simplified - would need actual lat/lng for real calculation)
+     const geographicSpread = {
@@ lines 234-240 @@
-   private convertAnalysisToClusteringData(data: ProcessedAnalysisData): AnalysisData {
-     console.log(`[ClusteringService] 📍 Converting ${data.records?.length || 0} records for clustering`);
-     
-     const features = (data.records || []).map((record, index) => {
-       // Prefer shared resolver for robust ZIP/FSA extraction, with fallbacks
-       let resolvedZip = getZip({ ...(record.properties as any), area_name: record.area_name });
-       if (!resolvedZip && record.area_name) {
---
+   private convertAnalysisToClusteringData(data: ProcessedAnalysisData): AnalysisData {
+     console.log(`[ClusteringService] 📍 Converting ${data.records?.length || 0} records for clustering`);
+     
+     const features = (data.records || []).map((record: any, index: any) => {
+       // Prefer shared resolver for robust ZIP/FSA extraction, with fallbacks
+       let resolvedZip = getZip({ ...(record.properties as any), area_name: record.area_name });
+       if (!resolvedZip && record.area_name) {
+         const match = record.area_name.match(/^\d{4,5}/);
+         resolvedZip = match ? match[0] : record.area_name;
+       }
@@ lines 297-304 @@
- 
-     console.log(`[ClusteringService] 📍 Converted features summary:`, {
-       totalFeatures: features.length,
-       sampleCentroids: features.slice(0, 3).map(f => f.geometry.centroid),
-       uniqueCentroids: new Set(features.map(f => JSON.stringify(f.geometry.centroid))).size
-     });
- 
-     return {
---
+ 
+     console.log(`[ClusteringService] 📍 Converted features summary:`, {
+       totalFeatures: features.length,
+       sampleCentroids: features.slice(0, 3).map(f: any => f.geometry.centroid),
+       uniqueCentroids: new Set(features.map(f: any => JSON.stringify(f.geometry.centroid))).size
+     });
+ 
+     return {
+       type: data.type || 'analysis',
+       features
+     };
@@ lines 547-554 @@
-     
-     // Create a map of ZIP codes to cluster assignments
-     const zipToClusterMap = new Map();
-     clusteringResult.clusters.forEach(cluster => {
-       cluster.zipCodes.forEach(zipCode => {
-         zipToClusterMap.set(zipCode, {
-           clusterId: cluster.clusterId,
-           clusterName: cluster.name,
---
+     
+     // Create a map of ZIP codes to cluster assignments
+     const zipToClusterMap = new Map();
+     clusteringResult.clusters.forEach(cluster: any => {
+       cluster.zipCodes.forEach(zipCode: any => {
+         zipToClusterMap.set(zipCode, {
+           clusterId: cluster.clusterId,
+           clusterName: cluster.name,
+           clusterCentroid: cluster.centroid
+         });
+       });
@@ lines 560-571 @@
-     console.log(`[ClusteringService] 🎯 Creating clustered ZIP records - preserving original ZIP geometries`);
-     console.log(`[ClusteringService] 🎯 Cluster assignments:`, {
-       totalClusters: clusteringResult.clusters.length,
-       clusterSizes: clusteringResult.clusters.map(c => ({ id: c.clusterId, name: c.name, zipCount: c.zipCodes.length })),
-       totalMappedZips: zipToClusterMap.size
-     });
-     
-     // Transform each original ZIP code record to include cluster assignment
-     (originalResult.data.records || []).forEach(record => {
-       // Extract ZIP code more reliably - prefer zip_code over geo_id (geo_id often lacks leading zeros)
-       let zipCode = record.properties?.zip_code || record.properties?.geo_id;
-       
---
+     console.log(`[ClusteringService] 🎯 Creating clustered ZIP records - preserving original ZIP geometries`);
+     console.log(`[ClusteringService] 🎯 Cluster assignments:`, {
+       totalClusters: clusteringResult.clusters.length,
+       clusterSizes: clusteringResult.clusters.map(c: any => ({ id: c.clusterId, name: c.name, zipCount: c.zipCodes.length })),
+       totalMappedZips: zipToClusterMap.size
+     });
+     
+     // Transform each original ZIP code record to include cluster assignment
+     (originalResult.data.records || []).forEach(record: any => {
+       // Extract ZIP code more reliably - prefer zip_code over geo_id (geo_id often lacks leading zeros)
+       let zipCode = record.properties?.zip_code || record.properties?.geo_id;
+       
+       // If no direct ZIP code field, extract from area_name (e.g., "11234 (Brooklyn)" -> "11234")
+       if (!zipCode && record.area_name) {
+         const match = record.area_name.match(/^\d{4,5}/);
@@ lines 725-731 @@
-     // Extract all coordinates from ZIP code geometries that have been joined with boundaries
-     const allCoordinates: [number, number][] = [];
-     
-     zipRecords.forEach(record => {
-       if (record.geometry?.type === 'Polygon' && record.geometry.coordinates?.[0]) {
-         // Extract coordinates from polygon rings
-         record.geometry.coordinates[0].forEach((coord: [number, number]) => {
---
+     // Extract all coordinates from ZIP code geometries that have been joined with boundaries
+     const allCoordinates: [number, number][] = [];
+     
+     zipRecords.forEach(record: any => {
+       if (record.geometry?.type === 'Polygon' && record.geometry.coordinates?.[0]) {
+         // Extract coordinates from polygon rings
+         record.geometry.coordinates[0].forEach((coord: [number, number]) => {
+           allCoordinates.push(coord);
+         });
+       } else if (record.geometry?.type === 'Point' && record.geometry.coordinates) {
@@ lines 743-750 @@
-     }
-     
-     // Calculate bounding box for the territory
-     const lons = allCoordinates.map(coord => coord[0]);
-     const lats = allCoordinates.map(coord => coord[1]);
-     const minLon = Math.min(...lons);
-     const maxLon = Math.max(...lons);
-     const minLat = Math.min(...lats);
---
+     }
+     
+     // Calculate bounding box for the territory
+     const lons = allCoordinates.map(coord: any => coord[0]);
+     const lats = allCoordinates.map(coord: any => coord[1]);
+     const minLon = Math.min(...lons);
+     const maxLon = Math.max(...lons);
+     const minLat = Math.min(...lats);
+     const maxLat = Math.max(...lats);
+     
+     // Add padding to create a proper territory boundary
@@ lines 776-786 @@
-       return 'Clustering could not be applied to this analysis.';
-     }
- 
-     const validClusters = result.clusters.filter(c => c.isValid);
-     const totalPopulation = validClusters.reduce((sum, c) => sum + c.totalPopulation, 0);
-     const avgPopulation = validClusters.length > 0 ? totalPopulation / validClusters.length : 0;
-     const avgZipCodes = validClusters.length > 0 ? 
-       validClusters.reduce((sum, c) => sum + c.zipCodes.length, 0) / validClusters.length : 0;
- 
-     let summary = `The analysis has been organized into ${validClusters.length} distinct market territories for campaign deployment. `;
-     summary += `Each territory averages ${Math.round(avgZipCodes)} ZIP codes and serves ${Math.round(avgPopulation).toLocaleString()} people. `;
---
+       return 'Clustering could not be applied to this analysis.';
+     }
+ 
+     const validClusters = result.clusters.filter(c: any => c.isValid);
+     const totalPopulation = validClusters.reduce((sum: any, c: any) => sum + c.totalPopulation, 0);
+     const avgPopulation = validClusters.length > 0 ? totalPopulation / validClusters.length : 0;
+     const avgZipCodes = validClusters.length > 0 ? 
+       validClusters.reduce((sum: any, c: any) => sum + c.zipCodes.length, 0) / validClusters.length : 0;
+ 
+     let summary = `The analysis has been organized into ${validClusters.length} distinct market territories for campaign deployment. `;
+     summary += `Each territory averages ${Math.round(avgZipCodes)} ZIP codes and serves ${Math.round(avgPopulation).toLocaleString()} people. `;
+     summary += `These ${validClusters.length} territories represent strategic groupings of the original ${result.totalZipCodes} ZIP codes, optimized for efficient market penetration and resource allocation. `;
+     
+     if (result.unclustered.length > 0) {
@@ lines 821-830 @@
-     // Create named clusters with their top ZIP codes
-     console.log('🎯 [CLUSTER ANALYSIS] Processing clusters for analysis:', {
-       totalClusters: clusteringResult.clusters.length,
-       clusterIds: clusteringResult.clusters.map(c => ({ id: c.clusterId, name: c.name, zipCount: c.zipCodes.length }))
-     });
-     
-     const namedClusters = clusteringResult.clusters.map(cluster => {
-       const namedCluster = this.createNamedCluster(cluster, clusteredZipRecords, endpointConfig);
-       console.log(`🎯 [CLUSTER ANALYSIS] Created named cluster:`, {
-         originalClusterId: cluster.clusterId,
---
+     // Create named clusters with their top ZIP codes
+     console.log('🎯 [CLUSTER ANALYSIS] Processing clusters for analysis:', {
+       totalClusters: clusteringResult.clusters.length,
+       clusterIds: clusteringResult.clusters.map(c: any => ({ id: c.clusterId, name: c.name, zipCount: c.zipCodes.length }))
+     });
+     
+     const namedClusters = clusteringResult.clusters.map(cluster: any => {
+       const namedCluster = this.createNamedCluster(cluster, clusteredZipRecords, endpointConfig);
+       console.log(`🎯 [CLUSTER ANALYSIS] Created named cluster:`, {
+         originalClusterId: cluster.clusterId,
+         originalName: cluster.name,
+         finalClusterName: namedCluster?.name,
+         zipCount: namedCluster?.zipCount,
@@ lines 838-850 @@
-     });
- 
-     // Filter out any null clusters and sort by strategic importance
-   const validNamedClusters = namedClusters.filter(cluster => cluster !== null);
-     // Keep clusters in original ID order to match map legend - do NOT sort by score
-     validNamedClusters.sort((a, b) => a.originalClusterId - b.originalClusterId);
-     
-     console.log(`🎯 [CLUSTER ANALYSIS] Final clusters for text generation:`, {
-       totalClusters: validNamedClusters.length,
-       clusterSummary: validNamedClusters.map(c => ({ 
-         name: c.name, 
-         zipCount: c.zipCount, 
-         avgScore: c.avgScore.toFixed(1) 
---
+     });
+ 
+     // Filter out any null clusters and sort by strategic importance
+   const validNamedClusters = namedClusters.filter(cluster: any => cluster !== null);
+     // Keep clusters in original ID order to match map legend - do NOT sort by score
+     validNamedClusters.sort((a: any, b: any) => a.originalClusterId - b.originalClusterId);
+     
+     console.log(`🎯 [CLUSTER ANALYSIS] Final clusters for text generation:`, {
+       totalClusters: validNamedClusters.length,
+       clusterSummary: validNamedClusters.map(c: any => ({ 
+         name: c.name, 
+         zipCount: c.zipCount, 
+         avgScore: c.avgScore.toFixed(1) 
+       }))
+     });
+     
@@ lines 855-861 @@
-     let analysis = this.generateClusterIntroduction(validNamedClusters, endpointConfig);
-     
-     // Add detailed cluster analysis
-   validNamedClusters.forEach((cluster) => {
-       // Use cluster ID + 1 to match legend numbering (cluster ID 0 = ①, cluster ID 1 = ②, etc.)
-       const displayNumber = cluster.originalClusterId + 1;
-       analysis += this.generateClusterDetails(cluster, displayNumber, endpointConfig, validNamedClusters.length);
---
+     let analysis = this.generateClusterIntroduction(validNamedClusters, endpointConfig);
+     
+     // Add detailed cluster analysis
+   validNamedClusters.forEach((cluster: any) => {
+       // Use cluster ID + 1 to match legend numbering (cluster ID 0 = ①, cluster ID 1 = ②, etc.)
+       const displayNumber = cluster.originalClusterId + 1;
+       analysis += this.generateClusterDetails(cluster, displayNumber, endpointConfig, validNamedClusters.length);
+     });
+ 
+     // Add strategic recommendations
@@ lines 927-940 @@
-    */
-   private createNamedCluster(cluster: any, clusteredZipRecords: any[], config: any): any {
-     // Find ZIP codes belonging to this cluster
-     const clusterZips = clusteredZipRecords.filter(record => 
-       record.cluster_id === cluster.clusterId
-     );
-     
-     console.log(`🎯 [CLUSTER ANALYSIS] Creating cluster ${cluster.clusterId} (original: ${cluster.name}):`, {
-       expectedZipCount: cluster.zipCodes?.length,
-       foundZipCount: clusterZips.length,
-       sampleZips: clusterZips.slice(0, 5).map(z => ({ area: z.area_name, clusterId: z.cluster_id, score: z.value }))
-     });
- 
-     if (clusterZips.length === 0) {
---
+    */
+   private createNamedCluster(cluster: any, clusteredZipRecords: any[], config: any): any {
+     // Find ZIP codes belonging to this cluster
+     const clusterZips = clusteredZipRecords.filter(record: any => 
+       record.cluster_id === cluster.clusterId
+     );
+     
+     console.log(`🎯 [CLUSTER ANALYSIS] Creating cluster ${cluster.clusterId} (original: ${cluster.name}):`, {
+       expectedZipCount: cluster.zipCodes?.length,
+       foundZipCount: clusterZips.length,
+       sampleZips: clusterZips.slice(0, 5).map(z: any => ({ area: z.area_name, clusterId: z.cluster_id, score: z.value }))
+     });
+ 
+     if (clusterZips.length === 0) {
+       console.log(`🎯 [CLUSTER ANALYSIS] ❌ No ZIP codes found for cluster ${cluster.clusterId}`);
+       return null;
+     }
@@ lines 943-949 @@
-     }
- 
-     // Find highest population ZIP for naming (using population or score as fallback)
-     const leadZip = clusterZips.reduce((max, zip) => {
-       const maxPop = max.properties?.total_population || max.properties?.totpop_cy || 0;
-       const zipPop = zip.properties?.total_population || zip.properties?.totpop_cy || 0;
-       return zipPop > maxPop ? zip : max;
---
+     }
+ 
+     // Find highest population ZIP for naming (using population or score as fallback)
+     const leadZip = clusterZips.reduce((max: any, zip: any) => {
+       const maxPop = max.properties?.total_population || max.properties?.totpop_cy || 0;
+       const zipPop = zip.properties?.total_population || zip.properties?.totpop_cy || 0;
+       return zipPop > maxPop ? zip : max;
+     });
+ 
+     // Extract cluster name using shared resolver (city-focused label)
@@ lines 958-985 @@
-     console.log(`🎯 [CLUSTER ANALYSIS] Generated cluster name: "${clusterName}" for cluster ${cluster.clusterId}`);
-     
-     // Calculate cluster statistics with better error handling
-     const scores = clusterZips.map(zip => {
-       const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
-       return isNaN(score) ? 0 : score;
-     }).filter(score => score > 0); // Remove zeros and invalid scores
-     
-     const avgScore = scores.length > 0 ? scores.reduce((sum, score) => sum + score, 0) / scores.length : 0;
-     const maxScore = scores.length > 0 ? Math.max(...scores) : 0;
-     const minScore = scores.length > 0 ? Math.min(...scores) : 0;
- 
-     // Get top 5 ZIP codes in this cluster for detailed description
-   const topZips = clusterZips
-       .filter(zip => {
-         const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
-         return !isNaN(score) && score > 0;
-       })
-       .sort((a, b) => {
-         const scoreA = a.value || a.properties?.[config.scoreField] || a.properties?.strategic_value_score || 0;
-         const scoreB = b.value || b.properties?.[config.scoreField] || b.properties?.strategic_value_score || 0;
-         return scoreB - scoreA;
-       })
-       .slice(0, 5)
-       .map(zip => {
-     const normalizedZipCode = getZip(zip);
-         const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
- 
---
+     console.log(`🎯 [CLUSTER ANALYSIS] Generated cluster name: "${clusterName}" for cluster ${cluster.clusterId}`);
+     
+     // Calculate cluster statistics with better error handling
+     const scores = clusterZips.map(zip: any => {
+       const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
+       return isNaN(score) ? 0 : score;
+     }).filter(score: any => score > 0); // Remove zeros and invalid scores
+     
+     const avgScore = scores.length > 0 ? scores.reduce((sum: any, score: any) => sum + score, 0) / scores.length : 0;
+     const maxScore = scores.length > 0 ? Math.max(...scores) : 0;
+     const minScore = scores.length > 0 ? Math.min(...scores) : 0;
+ 
+     // Get top 5 ZIP codes in this cluster for detailed description
+   const topZips = clusterZips
+       .filter(zip: any => {
+         const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
+         return !isNaN(score) && score > 0;
+       })
+       .sort((a: any, b: any) => {
+         const scoreA = a.value || a.properties?.[config.scoreField] || a.properties?.strategic_value_score || 0;
+         const scoreB = b.value || b.properties?.[config.scoreField] || b.properties?.strategic_value_score || 0;
+         return scoreB - scoreA;
+       })
+       .slice(0, 5)
+       .map(zip: any => {
+     const normalizedZipCode = getZip(zip);
+         const score = zip.value || zip.properties?.[config.scoreField] || zip.properties?.strategic_value_score || 0;
+ 
+     // Prefer a robust, human-friendly label via shared resolver
+     const name = resolveAreaName(zip, { mode: 'zipCity' });
+ 
@@ lines 996-1002 @@
-     console.log(`🎯 [CLUSTER ANALYSIS] Top ZIP codes for cluster "${clusterName}":`, topZips);
-     
-     // Calculate population-weighted market shares for the cluster
-     const totalPopulation = clusterZips.reduce((sum, zip) => 
-       sum + (zip.properties?.total_population || zip.properties?.totpop_cy || 0), 0
-     );
-     
---
+     console.log(`🎯 [CLUSTER ANALYSIS] Top ZIP codes for cluster "${clusterName}":`, topZips);
+     
+     // Calculate population-weighted market shares for the cluster
+     const totalPopulation = clusterZips.reduce((sum: any, zip: any) => 
+       sum + (zip.properties?.total_population || zip.properties?.totpop_cy || 0), 0
+     );
+     
+     const clusterMarketShares = this.calculateClusterMarketShares(clusterZips, totalPopulation);
+     
+     return {
@@ lines 1067-1073 @@
-     let weightedAdidasShare = 0;
-     let weightedJordanShare = 0;
- 
-     clusterZips.forEach(zip => {
-       const population = zip.properties?.total_population || zip.properties?.totpop_cy || 0;
-       const weight = population / totalPopulation;
-       
---
+     let weightedAdidasShare = 0;
+     let weightedJordanShare = 0;
+ 
+     clusterZips.forEach(zip: any => {
+       const population = zip.properties?.total_population || zip.properties?.totpop_cy || 0;
+       const weight = population / totalPopulation;
+       
+       const nikeShare = zip.properties?.mp30034a_b_p || zip.properties?.nike_market_share || 0;
+       const adidasShare = zip.properties?.mp30029a_b_p || zip.properties?.adidas_market_share || 0;
+       const jordanShare = zip.properties?.mp30032a_b_p || zip.properties?.jordan_market_share || 0;
@@ lines 1104-1111 @@
-    * Generate cluster analysis introduction
-    */
-   private generateClusterIntroduction(clusters: any[], config: any): string {
-     const totalZips = clusters.reduce((sum, cluster) => sum + cluster.zipCount, 0);
-     const avgScore = clusters.reduce((sum, cluster) => sum + cluster.avgScore, 0) / clusters.length;
-     
-     return `**${config.name} - Territory Clustering Results**
- 
---
+    * Generate cluster analysis introduction
+    */
+   private generateClusterIntroduction(clusters: any[], config: any): string {
+     const totalZips = clusters.reduce((sum: any, cluster: any) => sum + cluster.zipCount, 0);
+     const avgScore = clusters.reduce((sum: any, cluster: any) => sum + cluster.avgScore, 0) / clusters.length;
+     
+     return `**${config.name} - Territory Clustering Results**
+ 
+ This ${config.focus} analysis has identified ${clusters.length} distinct market territories comprising ${totalZips.toLocaleString()} ZIP codes. The territories are strategically grouped based on ${config.scoreName.toLowerCase()} scores, with an average ${config.scoreName.toLowerCase()} of ${avgScore.toFixed(1)}. Each territory represents a cohesive market area optimized for ${config.recommendations}.
+ 
+ **Territory Analysis:**
@@ lines 1228-1234 @@
-     
-     // Territory-specific strategies
-     recommendations += `**2. Territory-Specific Market Entry Strategies:**\n`;
-   clusters.slice(0, 3).forEach((cluster) => {
-       recommendations += `- **${cluster.name}**: `;
-       if (cluster.marketShares?.marketGap > 70) {
-         recommendations += `High market gap (${cluster.marketShares.marketGap.toFixed(1)}%) - aggressive store expansion and digital marketing campaigns\n`;
---
+     
+     // Territory-specific strategies
+     recommendations += `**2. Territory-Specific Market Entry Strategies:**\n`;
+   clusters.slice(0, 3).forEach((cluster: any) => {
+       recommendations += `- **${cluster.name}**: `;
+       if (cluster.marketShares?.marketGap > 70) {
+         recommendations += `High market gap (${cluster.marketShares.marketGap.toFixed(1)}%) - aggressive store expansion and digital marketing campaigns\n`;
+       } else if (cluster.marketShares?.marketGap > 50) {
+         recommendations += `Moderate market gap (${cluster.marketShares.marketGap.toFixed(1)}%) - targeted pop-up stores and partnership opportunities\n`;
+       } else {

