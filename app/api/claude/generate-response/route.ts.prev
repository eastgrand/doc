/* eslint-disable @typescript-eslint/no-unused-vars */
import { NextResponse } from 'next/server';
import { Anthropic } from '@anthropic-ai/sdk';
import { layers, LayerConfig } from '@/config/layers';
import { handleUpload, type HandleUploadBody } from '@vercel/blob/client';
// import { Readable } from 'stream'; // Might not be needed if using ReadableStream directly
// Remove the problematic import
// import { streamToBuffer } from '@vercel/blob/utils';
import type { AnalysisResponse, ProcessedLayerResult } from '@/types/geospatial-chat';
import { NextRequest } from 'next/server';

// --- Interface Definitions ---

interface FeatureProperties {
  [key: string]: any;
}

// Note: FeatureObject is less relevant now as we primarily handle FeatureProperties lists
interface GeometryData {
    type: string;
    coordinates: number[] | number[][] | number[][][];
}

interface FeatureObject {
  id?: string;
  type?: string;
  properties: FeatureProperties;
  attributes?: FeatureProperties; // Kept for potential legacy compatibility, but focus is on properties
  geometry?: GeometryData;
}

// Represents the structure within the blob *after* optimization
interface OptimizedLayerData {
  layerId: string;
  features: FeatureProperties[]; // Array of attribute objects
  layerName?: string; // Optional, might be added by frontend
  layerType?: string; // Optional
  // Other potential metadata from optimization...
}

// Represents the overall structure uploaded to the blob
interface UploadDataType {
  features: OptimizedLayerData[]; // Array of optimized layer data
  totalFeatures: number;
  timestamp: string;
  isComplete: boolean;
  query?: string;
  context?: any;
}

// Type for intermediate processing step
interface ProcessedLayer extends OptimizedLayerData {
    statistics?: LayerStatistics | null; // Optional stats if calculated
    topFeatures?: TopFeature[]; // Optional top features if calculated
}

// Other interfaces (LayerStatistics, TopFeature, RequestBody, CorrelationMetadata, etc.) remain largely the same as before
// ... (keep existing interface definitions for LayerStatistics, TopFeature, RequestBody, CorrelationMetadata, etc.) ...
interface LayerStatistics {
  count: number;
  min: number;
  max: number;
  mean: number;
  median: number;
  stdDev: number;
  quartiles: {
    q1: number;
    q3: number;
  };
}

interface TopFeature {
  zipCode: string;
  description: string | null;
  value: number;
}

interface RequestBody {
  messages: Array<{
    role: string;
    content: string;
  }>;
  metadata: any; // Keep metadata field
  blobUrl?: string;
}

interface CorrelationMetadata {
  pearson: number;
  spearman: number;
  kendall: number;
  pValue: number;
  spatialStats: {
    moransI: number;
    getisOrdG: number;
    hotspots: number;
    coldspots: number;
    outliers: number;
  };
}


// --- Configuration ---
export const runtime = 'edge';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;
export const fetchCache = 'force-no-store';
export const revalidate = 0;

// --- Initialize Anthropic Client ---
const anthropicApiKey = process.env.ANTHROPIC_API_KEY;
if (!anthropicApiKey) {
  console.error('[Claude] ERROR: ANTHROPIC_API_KEY environment variable is missing or empty');
}
console.log('[Claude] API Key available:', !!anthropicApiKey, typeof anthropicApiKey === 'string' ? `Length: ${anthropicApiKey.length}` : 'Invalid type');

const anthropic = new Anthropic({
  apiKey: anthropicApiKey || '',
});

// --- System Prompt ---
const systemPrompt = `You are an expert geospatial data analyst specializing in ZIP code level consumer insights. Your task is to analyze and explain geographic patterns that help marketing, sales, and sponsorship professionals make data-driven decisions.

Important data structure information:
- The data contains a critical field called "thematic_value" which is the normalized numeric value used for visualization on the map
- When analyzing numeric patterns, ALWAYS use "thematic_value" for your analysis to ensure consistency with the map visualization
- The map's colors are directly based on the "thematic_value" field, so your insights must reference this field

Your task is to analyze geographic patterns in this data and provide clear insights relevant to the user's query. Be specific and actionable in your recommendations.`;

// Add logger after the prompt is defined
console.log('[Claude DEBUG] 🔍 Constructed system prompt with length:', systemPrompt.length);

// --- Helper Functions ---

// Checks if a layer is demographic based on config
function isDemographicLayer(layerId: string): boolean {
  const layerConfig = layers[layerId];
  return layerConfig?.description?.toLowerCase().includes('population') ||
          layerConfig?.description?.toLowerCase().includes('demographic') ||
          layerConfig?.metadata?.tags?.includes('demographics') ||
          false;
}

// **MODIFIED** Gets relevant fields based on available attributes and query
function getRelevantFields(attributes: FeatureProperties, query: string): string[] {
  const availableFields = Object.keys(attributes);
  
  // Log available fields to help debug
  console.log('[getRelevantFields] Query:', query);
  console.log('[getRelevantFields] Available fields:', availableFields);
  
  const queryLower = query.toLowerCase();
  
  // For brand-related queries
  if (queryLower.includes('nike') || queryLower.includes('adidas') || queryLower.includes('brand') || 
      queryLower.includes('lululemon') || queryLower.includes('alo') || queryLower.includes('jordan') ||
      queryLower.includes('shoes')) {
    const brandFields = availableFields.filter(f => 
      (f.toLowerCase().includes('bought') && 
      (f.toLowerCase().includes('shoes') || f.toLowerCase().includes('athletic'))) ||
      f.toLowerCase().includes('nike') || 
      f.toLowerCase().includes('adidas') || 
      f.toLowerCase().includes('alo') ||
      f.toLowerCase().includes('jordan') ||
      f.toLowerCase().includes('lululemon')
    );
    
    if (brandFields.length > 0) {
      console.log('[getRelevantFields] Found brand fields:', brandFields);
      return brandFields;
    }
  }
  
  // For sports fan related queries
  if (queryLower.includes('fan') || queryLower.includes('sports') || 
      queryLower.includes('nba') || queryLower.includes('nfl') || 
      queryLower.includes('mlb') || queryLower.includes('nhl') ||
      queryLower.includes('soccer') || queryLower.includes('exercise')) {
    const sportsFields = availableFields.filter(f => 
      f.toLowerCase().includes('fan') || 
      f.toLowerCase().includes('sports') ||
      f.toLowerCase().includes('participated') ||
      f.toLowerCase().includes('exercise') ||
      f.toLowerCase().includes('gym')
    );
    
    if (sportsFields.length > 0) {
      console.log('[getRelevantFields] Found sports fields:', sportsFields);
      return sportsFields;
    }
  }
  
  // For income/wealth related queries
  if (queryLower.includes('income') || queryLower.includes('wealth') || 
      queryLower.includes('affluent') || queryLower.includes('rich') ||
      queryLower.includes('disposable')) {
    const incomeFields = availableFields.filter(f => 
      f.toLowerCase().includes('income') || 
      f.toLowerCase().includes('wealth') || 
      f.toLowerCase().includes('disposable')
    );
    
    if (incomeFields.length > 0) {
      console.log('[getRelevantFields] Found income fields:', incomeFields);
      return incomeFields;
    }
  }
  
  // For demographic queries
  if (queryLower.includes('demographic') || queryLower.includes('population') || 
      queryLower.includes('diversity')) {
    const demographicFields = availableFields.filter(f => 
      f.toLowerCase().includes('population') || 
      f.toLowerCase().includes('diversity') ||
      f.toLowerCase().includes('household') ||
      f.toLowerCase().includes('age')
    );
    
    if (demographicFields.length > 0) {
      console.log('[getRelevantFields] Found demographic fields:', demographicFields);
      return demographicFields;
    }
  }
  
  // Prioritize based on broader query categories
  if (queryLower.includes('population') || queryLower.includes('demographic')) {
    const popFields = availableFields.filter(f => f.toLowerCase().includes('population') || f.toLowerCase().includes('total'));
    if (popFields.length > 0) {
      console.log('[getRelevantFields] Found population fields:', popFields);
      return popFields;
    }
  }
  if (queryLower.includes('income') || queryLower.includes('economic')) {
    const econFields = availableFields.filter(f => f.toLowerCase().includes('income') || f.toLowerCase().includes('economic'));
    if (econFields.length > 0) {
      console.log('[getRelevantFields] Found economic fields:', econFields);
      return econFields;
    }
  }
  if (queryLower.includes('age')) {
    const ageFields = availableFields.filter(f => f.toLowerCase().includes('age'));
    if (ageFields.length > 0) {
      console.log('[getRelevantFields] Found age fields:', ageFields);
      return ageFields;
    }
  }
  
  // Find numeric fields available in the attributes (excluding OBJECTID)
  const numericFields = availableFields.filter(f => 
    f.toUpperCase() !== 'OBJECTID' && 
    typeof attributes[f] === 'number' && 
    !isNaN(attributes[f])
  );
  
  if (numericFields.length > 0) {
    console.log('[getRelevantFields] Found numeric fields:', numericFields);
    return numericFields;
  }
  
  // MODIFIED: As a last resort, return all fields that have non-empty values
  // This ensures we always have some relevant fields rather than none
  const nonEmptyFields = availableFields.filter(f => 
    attributes[f] !== null && 
    attributes[f] !== undefined && 
    attributes[f] !== "" &&
    f.toUpperCase() !== 'OBJECTID'
  );
  
  console.log('[getRelevantFields] No specific matches found. Using all non-empty fields:', nonEmptyFields);
  return nonEmptyFields;
}

// Formats field value based on layer config (if available)
const formatFieldValue = (value: any, layerConfig: LayerConfig | undefined): string => {
  if (typeof value === 'number') {
    if (layerConfig?.metadata?.valueType === 'count') {
      return Math.round(value).toLocaleString();
    } else if (layerConfig?.fields?.some(f => f.label?.includes('$'))) {
      return `$${value.toLocaleString()}`;
    } else {
      return value.toLocaleString(); // Default numeric format
    }
  }
  return String(value);
};

// **MODIFIED** Sorts a list of attribute objects by a field value
function sortAttributesByField(attributeList: FeatureProperties[], field: string): FeatureProperties[] {
  return [...attributeList].sort((a, b) => {
    const valueA = Number(a[field]);
    const valueB = Number(b[field]);

    if (isNaN(valueA) && !isNaN(valueB)) return 1;
    if (!isNaN(valueA) && isNaN(valueB)) return -1;
    if (isNaN(valueA) && isNaN(valueB)) return 0;
    
    return valueB - valueA; // Descending order
  });
}

// **MODIFIED** Gets location name from an attribute object
function getLocationName(attributes: FeatureProperties): string {
  // Look inside properties if it exists, otherwise use attributes directly
  const propsToCheck = attributes.properties || attributes;

  // First try name fields in this specific order of priority
  const nameFields = [
    'name', 'NAME', 'FEDNAME', 'CSDNAME', 'ZIP', 'ZIPCODE', 'ZIP_CODE', 
    'POSTAL', 'FSA', 'CFSAUID', 'ID', 'DESCRIPTION', 'AREA', 'CITY', 
    'MUNICIPALITY', 'REGION', 'DISTRICT', 'HOOD', 'NEIGHBORHOOD'
  ]; 
  
  for (const field of nameFields) {
    if (propsToCheck[field] && propsToCheck[field].toString().trim()) {
      return String(propsToCheck[field]).trim();
    }
  }
  
  // Then look for any field that contains these name-related terms
  const nameContainFields = Object.keys(propsToCheck).filter(key => 
    key.toLowerCase().includes('name') || 
    key.toLowerCase().includes('city') ||
    key.toLowerCase().includes('district') ||
    key.toLowerCase().includes('area') ||
    key.toLowerCase().includes('hood') ||
    key.toLowerCase().includes('zone')
  );
  
  for (const field of nameContainFields) {
    if (propsToCheck[field] && propsToCheck[field].toString().trim()) {
      return String(propsToCheck[field]).trim();
    }
  }
  
  // If we still don't have a name, try ZIP code or ID
  const zipOrId = getZIPCode(attributes);
  if (zipOrId) {
    return `Location ${zipOrId}`;
  }
  
  // Fallback to any string value
  for (const [key, value] of Object.entries(propsToCheck)) {
    if (typeof value === 'string' && value.trim()) {
      if (!['OBJECTID', 'FEDUID', 'CSDUID', 'PRUID'].includes(key.toUpperCase())) {
        return value.trim();
      }
    }
  }
  
  // Ultimate fallback - use OBJECTID or any ID
  for (const idField of ['OBJECTID', 'OID', 'FID', 'ID']) {
    if (propsToCheck[idField]) {
      return `Area ${propsToCheck[idField]}`;
    }
  }
  
  return 'Unknown Location';
}

// **MODIFIED** Gets ZIP/FSA code from an attribute object
function getZIPCode(attributes: FeatureProperties): string {
  // Look inside properties if it exists, otherwise use attributes directly
  const propsToCheck = attributes.properties || attributes;

  // Try ZIP-specific fields first
  const zipFields = ['ZIP', 'ZIPCODE', 'ZIP_CODE', 'POSTAL', 'FSA', 'POSTCODE', 'POSTAL_CODE'];
  for (const field of zipFields) {
    const zip = propsToCheck[field];
    if (zip && zip.toString().trim()) {
      return zip.toString().trim();
    }
  }

  // Try ID fields next
  const idFields = ['CFSAUID', 'ID', 'CSDUID', 'FEDUID', 'OBJECTID']; 
  for (const field of idFields) {
    if (propsToCheck[field]) {
      return propsToCheck[field].toString().trim();
    }
  }

  // Look for any field that contains 'zip', 'code', or 'postal'
  const possibleZipFields = Object.keys(propsToCheck).filter(key =>
    key.toLowerCase().includes('zip') ||
    key.toLowerCase().includes('code') ||
    key.toLowerCase().includes('postal')
  );
  
  for (const field of possibleZipFields) {
    const val = propsToCheck[field];
    if (val && val.toString().trim()) {
      return val.toString().trim();
    }
  }

  return 'ID-' + (propsToCheck.OBJECTID || Math.floor(Math.random() * 10000));
}

// Correlation calculation functions (calculateCorrelation, calculatePearson, etc.)
// These likely need adaptation if the input structure `LayerFeatures[]` changes.
// Assuming they might be called later with appropriately structured data or are unused for now.
// --- Keep existing correlation functions: calculateCorrelation, calculatePearson, calculateSpearman, calculateKendall, calculatePValue, calculateSpatialStats, rankValues, tDistributionCDF, betaRegularized, logGamma, betaContinuedFraction, calculateMoransI, calculateGetisOrdG ---
// ... (paste existing correlation helper functions here if they are still used elsewhere) ...
// NOTE: If correlation is needed, these functions will need refactoring
// to accept the { layerId, features: FeatureProperties[] } structure.


// Helper function to convert ReadableStream to Buffer
async function streamToBufferHelper(stream: ReadableStream<Uint8Array>): Promise<Buffer> {
    const reader = stream.getReader();
    const chunks: Uint8Array[] = [];
    
    // Replace constant condition with proper loop
    let reading = true;
    while (reading) {
        const { done, value } = await reader.read();
        if (done) {
            reading = false;
        } else if (value) {
            chunks.push(value);
        }
    }
    
    // Rest of the function remains the same
    let totalLength = 0;
    chunks.forEach(chunk => {
        totalLength += chunk.length;
    });
    const result = new Uint8Array(totalLength);
    let offset = 0;
    chunks.forEach(chunk => {
        result.set(chunk, offset);
        offset += chunk.length;
    });
    return Buffer.from(result); // Keep Buffer for now, will decode later
}

// --- POST Request Handler ---
export async function POST(req: NextRequest) {
    const body = await req.json();
    const { messages, metadata, blobUrl } = body;

    console.log('[Claude DEBUG] 🔍 Received POST request');
    console.log('[Claude DEBUG] 🔍 Request metadata:', JSON.stringify(metadata));
    console.log('[Claude DEBUG] 🔍 Blob URL provided:', !!blobUrl);
    console.log('[Claude DEBUG] 🔍 Messages count:', messages?.length || 0);

    // Add error message for missing data
    let dataNotFoundMessage = `I don't have sufficient data to answer this question based on the available dataset...`;

    if (!blobUrl) {
        console.error('[Claude DEBUG] ❌ Blob URL is missing from request');
        return NextResponse.json({ error: 'Blob URL is missing' }, { status: 400 });
    }

    try {
        // Get the last user query from messages
        const userQuery = messages[messages.length - 1]?.content || '';
        if (!userQuery) {
            console.error('[Claude DEBUG] ❌ User query is missing from messages');
            return NextResponse.json({ error: 'User query is missing from messages' }, { status: 400 });
        }

        // Fetch blob data
        console.log('[Claude DEBUG] 🔍 Fetching data from blob:', blobUrl.substring(0, 50) + '...');
        const blobResponse = await fetch(blobUrl);

        console.log('[Claude DEBUG] 🔍 Blob fetch response status:', blobResponse.status, blobResponse.statusText);
        if (!blobResponse.ok) {
            console.error(`[Claude DEBUG] ❌ Failed to fetch blob data: ${blobResponse.status} ${blobResponse.statusText}`);
            return NextResponse.json({ content: dataNotFoundMessage });
        }

        // Get blob data as stream
        const blobStream = blobResponse.body;
        if (!blobStream) {
            console.error('[Claude] No stream in blob response');
            return NextResponse.json({ content: dataNotFoundMessage });
        }

        // Convert stream to buffer using helper function
        const blobBuffer = await streamToBufferHelper(blobStream);
        
        // Parse data from buffer
        const uploadData = JSON.parse(blobBuffer.toString()) as UploadDataType;
        
        if (!uploadData || !uploadData.features || uploadData.features.length === 0) {
            console.error('[Claude] No valid feature data in blob');
            return NextResponse.json({ content: dataNotFoundMessage });
        }

        console.log('[Claude DEBUG] 🔍 Successfully parsed blob data with structure:', {
            hasFeatures: !!uploadData?.features,
            featureCount: uploadData?.features?.length || 0,
            totalFeatures: uploadData?.totalFeatures || 0,
            isComplete: uploadData?.isComplete || false
        });

        // Add more detailed logging about the features data structure
        const firstFeatureSet = uploadData.features[0];
        const hasThematicValue = firstFeatureSet?.features?.some(f => 
          f.properties && f.properties.thematic_value !== undefined
        );

        console.log('[Claude] Feature data quality check:', {
          hasFeatureSets: uploadData.features.length > 0,
          firstSetFeatureCount: firstFeatureSet?.features?.length || 0,
          hasThematicValue,
          rendererField: uploadData.context?.rendererField || 'unknown',
          fieldsInFirstFeature: firstFeatureSet?.features?.[0]?.properties 
            ? Object.keys(firstFeatureSet.features[0].properties).slice(0, 10) 
            : []
        });

        // If thematic_value is missing, add warning to the log
        if (!hasThematicValue) {
          console.warn('[Claude] WARNING: thematic_value field missing from features. This may affect AI analysis quality.');
        }

        // Debug blob data structure - specifically check for thematic_value
        try {
            if (uploadData.features.length > 0 && uploadData.features[0].features.length > 0) {
                const sampleFeature = uploadData.features[0].features[0];
                const props = sampleFeature.properties || {};
                console.log('[Claude DEBUG] Sample feature structure:', {
                    hasProperties: !!sampleFeature.properties,
                    propertyKeys: Object.keys(props),
                    hasThematicValue: props.hasOwnProperty('thematic_value'),
                    thematicValueType: props.thematic_value !== undefined ? typeof props.thematic_value : 'undefined',
                    thematicValue: props.thematic_value,
                    rendererField: uploadData.context?.rendererField,
                    hasRendererField: uploadData.context?.rendererField ? 
                        props.hasOwnProperty(uploadData.context.rendererField) : false
                });

                // Check more samples for thematic_value
                let thematicValueCount = 0;
                let totalChecked = 0;
                
                // Check up to 10 features across layers
                for (const layer of uploadData.features) {
                    for (let i = 0; i < Math.min(10, layer.features.length); i++) {
                        totalChecked++;
                        const feature = layer.features[i];
                        if (feature.properties && feature.properties.thematic_value !== undefined) {
                            thematicValueCount++;
                        }
                    }
                }
                
                console.log(`[Claude DEBUG] Thematic value check: ${thematicValueCount} of ${totalChecked} checked features have thematic_value`);
            } else {
                console.warn('[Claude DEBUG] No features available to check structure');
            }
        } catch (e) {
            console.error('[Claude DEBUG] Error checking blob data structure:', e);
        }

        // Process layers data for AI analysis
        const processedLayersData: OptimizedLayerData[] = uploadData.features;
        
        // Verify layers data
        console.log('[Claude] Processing layers data with', processedLayersData.length, 'layers');
        processedLayersData.forEach((layer, idx) => {
          console.log(`[Claude] Layer ${idx}: ${layer.layerId} with ${layer.features?.length || 0} features`);
        });

        // Exit if no valid layers
        if (!processedLayersData || processedLayersData.length === 0) {
            console.error('[Claude] No valid layers found in blob data');
            return NextResponse.json({ content: dataNotFoundMessage });
        }

        // Determine primary layer and perform analysis
        const primaryLayerData = processedLayersData[0]; // Use first layer as primary
        const primaryLayerConfig = layers[primaryLayerData.layerId];
                
        if (!primaryLayerData.features || primaryLayerData.features.length === 0) {
            console.error('[Claude] No feature attributes in primary layer');
            return NextResponse.json({ content: dataNotFoundMessage });
        }
        
        // Log primary layer info
        console.log('[Claude] Primary layer analysis:', {
          layerId: primaryLayerData.layerId,
          layerName: primaryLayerConfig?.name || primaryLayerData.layerName || primaryLayerData.layerId,
          featuresCount: primaryLayerData.features.length
        });

        // --- Basic statistics generation ---
        const fieldStats: Record<string, any> = {};
        const categoricalStats: Record<string, Record<string, number>> = {};
        const numericFields = new Set<string>();
        const categoricalFields = new Set<string>();
        const booleanFields = new Set<string>();

        console.log('[Claude] Starting field analysis and value collection from OPTIMIZED data...');
        
        // Process each layer's features to gather field statistics
        processedLayersData.forEach((layerData, layerIndex) => {
          console.log(`[Claude] Processing Layer ${layerIndex}: ${layerData.layerId}`);
          const attributeList = layerData.features; // Array of attribute objects
          if (!attributeList || !Array.isArray(attributeList)) {
             console.warn(`[Claude] Layer ${layerData.layerId} has no valid attribute list.`);
             return;
          }
          
          // Process each feature's attributes
          attributeList.forEach((attributes, featureIndex) => {
            if (!attributes) {
              console.warn(`[Claude] Attribute object ${featureIndex} in layer ${layerData.layerId} is null/undefined.`);
              return;
            }
            
            // Determine where the actual fields are (directly in attributes or nested in properties)
            const fieldsSource = attributes.properties || attributes;
            
            // Process each field in the feature
            for (const [field, value] of Object.entries(fieldsSource)) {
              // Skip special fields and empty values
              if (field === 'FID' || field === 'OBJECTID' || field === 'id' || 
                  field === 'identifierField' || field === 'error' || 
                  value === null || value === undefined) {
                  continue;
              }
              
              // Categorize fields
              if (typeof value === 'number' && !isNaN(value)) {
                  // Exclude OBJECTID unless it's the only numeric field later
                  if (field.toUpperCase() !== 'OBJECTID') {
                      numericFields.add(field);
                      
                      // Initialize field stats
                      if (!fieldStats[field]) {
                          fieldStats[field] = {
                              count: 0,
                              min: Infinity,
                              max: -Infinity,
                              sum: 0,
                              values: [] // To calculate median and quartiles
                          };
                      }
                      
                      // Update field stats
                      fieldStats[field].count++;
                      fieldStats[field].min = Math.min(fieldStats[field].min, value);
                      fieldStats[field].max = Math.max(fieldStats[field].max, value);
                      fieldStats[field].sum += value;
                      fieldStats[field].values.push(value);
                  }
              } else if (typeof value === 'string') {
                  // Special handling for geographic identifiers
                  const upperField = field.toUpperCase();
                  if (upperField === 'FEDNAME') {
                      categoricalFields.add(field);
                      if (!categoricalStats[field]) categoricalStats[field] = {};
                      categoricalStats[field][value] = (categoricalStats[field][value] || 0) + 1;
                  } else {
                      // Text fields with numeric content
                      const numValue = parseFloat(value);
                      if (!isNaN(numValue)) {
                          numericFields.add(field);
                          
                          // Initialize field stats for numeric string fields
                          if (!fieldStats[field]) {
                              fieldStats[field] = {
                                  count: 0,
                                  min: Infinity,
                                  max: -Infinity,
                                  sum: 0,
                                  values: [] // To calculate median and quartiles
                              };
                          }
                          
                          // Update field stats
                          fieldStats[field].count++;
                          fieldStats[field].min = Math.min(fieldStats[field].min, numValue);
                          fieldStats[field].max = Math.max(fieldStats[field].max, numValue);
                          fieldStats[field].sum += numValue;
                          fieldStats[field].values.push(numValue);
                      } else {
                          categoricalFields.add(field);
                          if (!categoricalStats[field]) categoricalStats[field] = {};
                          categoricalStats[field][value] = (categoricalStats[field][value] || 0) + 1;
                      }
                  }
              } else if (typeof value === 'boolean') {
                  booleanFields.add(field);
                  if (!categoricalStats[field]) categoricalStats[field] = { 'true': 0, 'false': 0 };
                  categoricalStats[field][value.toString()] = (categoricalStats[field][value.toString()] || 0) + 1;
              }
            }
          });
        });
        
        console.log('[Claude] Field analysis complete.');
        console.log('[Claude] Numeric Fields Found:', Array.from(numericFields));
        console.log('[Claude] Categorical Fields Found:', Array.from(categoricalFields));

        // Construct the analysis prompt
        const analysisPrompt = `Question: ${userQuery}\n\nAvailable Data Overview:\n${processedLayersData.map(layerData => {
            // Get the layer name
            const name = layerData.layerName || layers[layerData.layerId]?.name || layerData.layerId;
            // Get feature count
            const featureCount = layerData.features.length;
            return `- ${name}: ${featureCount} records`;
        }).join('\n')}

Statistical Summary:
${numericFields.size > 0 ?
            `Numeric Fields Analysis:\n${Object.entries(fieldStats).map(([field, stats]) =>
                `- ${field}: Range from ${formatFieldValue((stats as any).min, layers[primaryLayerData.layerId])} to ${formatFieldValue((stats as any).max, layers[primaryLayerData.layerId])}, Average: ${formatFieldValue((stats as any).mean, layers[primaryLayerData.layerId])}`
).join('\n')}` : ''}`;

      // Log the final analysis prompt length
      console.log(`[Claude] Analysis prompt length: ${analysisPrompt.length} chars`);
      console.log(`[Claude] Analysis prompt first 200 chars: ${analysisPrompt.substring(0, 200)}...`)

      // --- Construct the final userMessage based on analysis type ---
      let userMessage = '';

      // --- RESTRUCTURED: Prioritize Correlation Check --- 
      if (metadata?.analysisType === 'correlation' && metadata?.primaryField && metadata?.comparisonField) {
        // For correlation analysis
        const primaryField = metadata.primaryField;
        const comparisonField = metadata.comparisonField;
        const primaryFieldName = primaryField.replace(/_/g, ' ');
        const comparisonFieldName = comparisonField.replace(/_/g, ' ');
        
        userMessage = `Based on the ZIP code level data, analyze the correlation between ${primaryFieldName} and ${comparisonFieldName}. Provide actionable marketing insights relevant to the business question: "${userQuery}".

${analysisPrompt}

Focus your analysis on:
1. Describing the relationship between ${primaryFieldName} and ${comparisonFieldName}
2. Identifying key ZIP codes where both values are high
3. Recommending specific marketing strategies based on this correlation
4. Explaining geographic patterns relevant to campaign planning

Your response should provide concrete recommendations for marketers on how to use this correlation to:
- Target the most promising geographic areas
- Create messaging that leverages the relationship between these factors
- Optimize marketing spend based on these insights`;
      } else {
        // Extract highest and lowest values for the primary field
        // This assumes the primaryField is set in metadata or can be inferred
        const primaryField = metadata?.primaryField || 
                           Object.keys(fieldStats).find(f => f.toLowerCase().includes('value')) || 
                           Object.keys(fieldStats)[0];
        
        if (!primaryField || !fieldStats[primaryField]) {
          console.warn('[Claude] Primary field not found or has no stats:', primaryField);
          return NextResponse.json({ 
            content: dataNotFoundMessage
          });
        }
        
        // --- Extract location with highest value ---
        let highestValue = -Infinity;
        let highestFeature = null;
        
        for (const feature of primaryLayerData.features) {
          const props = feature.properties || feature;
          if (!props) continue;
          
          const value = props[primaryField];
          if (value === null || value === undefined) continue;
          
          const numValue = typeof value === 'number' ? value : parseFloat(value);
          if (isNaN(numValue)) continue;
          
          if (numValue > highestValue) {
            highestValue = numValue;
            highestFeature = props;
          }
        }
        
        // Get location name from highest feature
        const highestLocationName = highestFeature 
          ? getLocationName(highestFeature)
          : "Unknown location";
        
        // Format the highest value
        const highestFormattedValue = highestFeature 
          ? formatFieldValue(highestValue, layers[primaryLayerData.layerId])
          : "N/A";
        
        console.log('[Claude] Highest value info:', {
          location: highestLocationName,
          value: highestFormattedValue,
          field: primaryField
        });
        // --- End Extract Highest/Lowest --- 

        // Get primary layer name 
        const primaryLayerName = primaryLayerData.layerName || 
                              layers[primaryLayerData.layerId]?.name || 
                              primaryLayerData.layerId;
        
        // Format the field name to be more human-readable
        const primaryFieldName = primaryField.replace(/_/g, ' ');

        // Construct the user message using the extracted high/low info
        userMessage = `Based on the ZIP code level data, analyze the distribution and patterns for ${primaryLayerName} (${primaryFieldName}). Provide actionable marketing insights relevant to the business question: "${userQuery}".

${analysisPrompt}

Focus your analysis on:
1. Identifying high-value ZIP codes for ${primaryFieldName} - especially highlight ${highestLocationName} (${highestFormattedValue}) and other top-performing areas.
2. Describing geographic concentrations that would be valuable for targeted marketing.
3. Providing specific, actionable recommendations for marketers based on this data.
4. Comparing different ZIP code areas and what this means for campaign planning.

Connect your insights directly to marketing applications such as:
- Where to focus advertising dollars
- Target demographics for campaigns
- Potential sponsorship or partnership opportunities
- Retail location strategy
- Digital marketing geo-targeting recommendations

IMPORTANT: Focus on business implications rather than just data description. Address the marketer's question directly with practical recommendations.`;
      }

      // --- Call Anthropic API ---
      console.log('[Claude] Preparing to call Anthropic API...');
      console.log('[Claude DEBUG] 🔍 System prompt length:', systemPrompt.length);
      console.log('[Claude DEBUG] 🔍 User message length:', userMessage.length);
      
      // Log first part of user message for debugging
      console.log('[Claude DEBUG] 🔍 User message preview:', userMessage.substring(0, 500) + '...');
      
      try {
        console.log('[Claude DEBUG] 🔍 Calling Anthropic API with model: claude-3-5-sonnet-20240620');
        const response = await anthropic.messages.create({
          model: 'claude-3-5-sonnet-20240620',
          max_tokens: 4000,
          temperature: 0.7,
          system: systemPrompt,
          messages: [
            {
              role: 'user',
              content: userMessage,
            },
          ],
        });
        
        console.log('[Claude DEBUG] 🔍 Received response from Anthropic API');
        console.log('[Claude DEBUG] 🔍 Response has content blocks:', response.content?.length || 0);
        
        const responseContent = response.content?.find(block => block.type === 'text')?.text || 'No text content received from AI.';

        if (!responseContent || responseContent === 'No text content received from AI.') {
          console.error('[Claude] No valid text content in response:', response.content);
        }

        console.log('[Claude] AI Response Start:', responseContent.substring(0, 200) + '...');

        // --- Return response ---
        const analysisResponse: AnalysisResponse = {
          content: responseContent,
        };

        return NextResponse.json(analysisResponse);
      } catch (apiError) {
        console.error('[Claude] Error calling Anthropic API:', apiError);
        return NextResponse.json({ 
          error: apiError instanceof Error ? apiError.message : 'Error calling AI API',
          content: 'I encountered an error while analyzing your data. Please try again with a different query.'
        }, { status: 500 });
      }

    } catch (error) {
      console.error('[Claude DEBUG] ❌ ERROR in POST handler:', error);
      console.error('[Claude DEBUG] ❌ Error type:', error instanceof Error ? error.constructor.name : typeof error);
      console.error('[Claude DEBUG] ❌ Error message:', error instanceof Error ? error.message : String(error));
      if (error instanceof Error && error.stack) {
          console.error('[Claude DEBUG] ❌ Stack trace:', error.stack);
      }
      
      return NextResponse.json({
        content: `I'm sorry, but I encountered an error while analyzing the data. Error details: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
}

// --- OPTIONS Handler ---
export async function OPTIONS(request: Request) {
  return NextResponse.json({}, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}